{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VoDEx: Volumetric Data and Experiment Manager","text":"<p>VoDEx is an open-source Python library that streamlines the management and analysis of volumetric functional imaging data. It offers a suite of tools for creating, organizing, and storing information pertaining to image acquisition and time annotation. Additionally, it allows for the retrieval of image data based on specific experimental conditions, enabling researchers to access and analyze the data easily. VoDEx is available as both a standalone Python package and a napari plugin, providing a user-friendly solution for processing volumetric functional imaging data, even for researchers without extensive programming experience.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To get started with <code>VoDEx</code>, please see Quick Start and Examples.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>The API contains the technical implementation of the <code>VoDEx</code> project code.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are very welcome. Please see Contributions for more details.</p>"},{"location":"#data","title":"Data","text":"<p>Some toy datasets are available in Data.</p>"},{"location":"#database","title":"Database","text":"<p>Schematics of the database structure used by VoDEx is available in Database.</p>"},{"location":"#gui","title":"GUI","text":"<p>For a quick start with napari-vodex see napari_vodex.</p>"},{"location":"#license","title":"License","text":"<p>Distributed under the terms of the [BSD-3] license, <code>vodex</code> is free and open source software.</p>"},{"location":"#citing-vodex","title":"Citing VoDEx","text":"<p>If you use VoDEx in your research, please cite our paper:</p> <p>Anna Nadtochiy, Peter Luu, Scott E Fraser, Thai V Truong, VoDEx: a Python library for time annotation and management of volumetric functional imaging data, Bioinformatics, Volume 39, Issue 9, September 2023, btad568,  https://doi.org/10.1093/bioinformatics/btad568</p> <p> </p>"},{"location":"contribute/","title":"Contributions","text":"<p>Contributions are very welcome. Tests can be run with tox, please ensure the coverage at least stays the same before you submit a pull request.</p> <p>Don't know how to contribute? Here are some ides:</p>"},{"location":"contribute/#add-support-for-new-image-types","title":"Add support for new image types","text":"<p>Currently vodex only supports TIFF images, but you can add support for other image types.</p> <p>I will try to create a more detailed description, but in a nutshell this can be done as follows:</p> <p>To add support for a new image type, you will need to create a new loader class in vodex.loaders module. Modify the Loader class by subclassing it and filling out the implementation of <code>get_frame_dtype</code>, <code>get_frame_size</code>, <code>get_frames_in_file</code> and <code>load_frames</code> methods. It is important that these methods have the inputs and outputs as specified in Loader.</p> <p>Once you have created the new class, you need to add your new supported file types, extensions and the corresponding loader that you implemented to the <code>VX_SUPPORTED_TYPES</code>, <code>VX_EXTENSION_TO_TYPE</code> and <code>VX_EXTENSION_TO_LOADER</code> dictionaries at the beginning of the vodex.core module.</p> <p>After this is done, vodex and napari-vodex should be able to work with your image format!</p>"},{"location":"contribute/#add-experiment-initialization-from-a-yaml-config-file","title":"Add Experiment initialization from a .yaml config file","text":"<p>Currently a new experiment is initialized with a python script. This is sometimes not convenient, and it would be great to have an initialization from a .yaml config file as an option. You can modify Experiment to add something like a <code>from_config</code> method (or whichever way you wish to name it) :)  </p>"},{"location":"data/","title":"Data","text":""},{"location":"data/#toy-dataset","title":"Toy Dataset","text":"<p> To test vodex we are using a simple toy dataset, where each image frame is labeled with the experimental conditions as well as the frame number and volume slice.</p> <p>You can download the toy dataset from GitHub.  </p>"},{"location":"data/#image-data-structure","title":"Image Data structure","text":"<p> The toy dataset movie consists of 42 frames.</p> <p>Each 10 frames make one volume, so the whole recording consists of 4 full volumes and two extra frames at the end of the recording.</p> <p>The movie is split into 3 TIFF files:</p> <ul> <li>7 frames in the first file,</li> <li>18 frames in the second file and</li> <li>17 frames in the third one.</li> </ul> <p> </p>"},{"location":"data/#time-annotation-structure","title":"Time Annotation Structure","text":"<p>We are tracking 3 types of toy experimental conditions in this dataset:</p> <p>1. c label: a condition label that appears in the middle of the screen. It takes c1, c2, c3 values.</p> c label is a Cycle: The movie starts with a c1 label for 10 frames, then c2 for 10 frames, followed by c3 for another 10 frames. This pattern repeats until the end of the recording c1 10 frames c2 10 frames c3 10 frames <p>2. shape: a circle or a square shapes on the screen.</p> shape is a Cycle: There is circle on the screen for the first 5 frames, then a square for 10 frames, then a circle again for 5 frames. This pattern repeats until the end of the recording. c 5 frames s 10 frames c 5 frames <p>3. light: whether the background is bright or dark, with the light being on or off respectively.</p> light is a Timeline: The light is off for the first 10 frames, then on for 20 frames and then off again for 12 frames. off 10 frames on 20 frames off 12 frames <p>See a frame-by-frame labels in the image on the left [click on image to zoom in].</p>"},{"location":"data/#database","title":"Database","text":"<p>You can find an example of the database for the Toy Dataset on GitHub.</p>"},{"location":"db/","title":"Database","text":"<p>Vodex stores the information about the experiment in a SQLite database.</p> <p>There are the following tables:</p> <ul> <li><code>Files</code> : stores the filenames relative to the main directory (<code>FileName</code>) and number of frames in each file (<code>NumFrames</code>)</li> <li><code>AnnotationTypes</code>: stores the types of annotations (<code>Name</code>) and descriptions (<code>Description</code>) which is optional.</li> <li><code>Frames</code>: links each frame in the experiment to the file (<code>FileId</code>) and a frame in that file (<code>FrameInFile</code>)</li> <li><code>Cycles</code>: IF the annotation (<code>AnnotationTypeId</code>) was created from a cycle, stores the cycle as a json string (<code>Structure</code>)</li> <li><code>AnnotationTypeLabels</code>: for each annotation type (<code>AnnotationTypeId</code>) stores the names of the labels (<code>Name</code>) and their descriptions (<code>Description</code>) which are optional.</li> <li><code>Volumes</code>: links each frame in the experiment (<code>FrameId</code>) to the volume (<code>VolumeId</code>) and a slice in that volume (<code>SliceInVolume</code>)</li> <li><code>CycleIterations</code>: links each frame in the experiment (<code>FrameId</code>) to the cycle (<code>CycleId</code>) and the iteration of that cycle (<code>CycleIteration</code>)</li> <li><code>Annotations</code>: links each frame in the experiment (<code>FrameId</code>) to the label (<code>AnnotationTypeLabelId</code>)</li> <li><code>Options</code>: stores some additional information as a <code>Key</code> - <code>Value</code> pair. Contains the following keys:<ul> <li><code>data_dir</code>: the directory with the image Files</li> <li><code>frames_per_volume</code>: frames per volume parameter</li> <li><code>num_head_frames</code>: number of frames at the beginning of the recording that do not form a full volume</li> <li><code>num_tail_frames</code>: number of frames at the end of the recording that do not form a full volume</li> <li><code>num_full_volumes</code>: number of full volumes in the recording</li> </ul> </li> </ul> <p>See diagram for more details.</p> <p>You can explore each table in more details using the database for the Toy Dataset. We recommend using a DB Browser for SQLite to explore the database content. It is also a good place to test out your queries if you want to add some functionality to the dbmethods module.</p>"},{"location":"examples/","title":"Examples","text":"<p>This section contains the links to the projects that used <code>vodex</code> in their analysis pipeline.</p>"},{"location":"examples/#numan-numerosity-analysis","title":"NumAn: Numerosity analysis","text":"<p>NumAn is a growing collection of methods for neuron segmentation and calcium signal analysis. Existing tools for neural segmentation (Pachitariu et al., 2017, Giovannucci et al., 2019) are optimized for 2D data and attempt to identify all active neurons in the recorded volume, which is a hard computational task that requires data to have a high signal-to-noise ratio. The method that we implemented in NumAn is based on the fMRI analysis: it generates a statistical parametric map in 3D to highlight differences in the neural activity during each visual stimulus (Friston et al., 1994). One neuron occupies multiple voxels in the image, all of which will show a similar response to stimuli. We cluster the adjacent voxels with similar statistics to identify individual neurons and extract the signals, Figure 3.4. Although this approach restricts the use of our tool to studies that focus on neural response to stimuli, it is more robust for data with a low signal-to-noise ratio, where other tools fail.</p> <p>NumAn uses VoDEx to implement batch-processing of the large datasets and to manage complex time annotations. Example of the NumAn pipeline can be found on GitHub.</p>"},{"location":"install/","title":"Installation","text":"<p>We recommend that you run these commands in a virtual environment.</p>"},{"location":"install/#from-pypi-or-conda","title":"From PyPI or conda","text":"<p>If you simply plan to use <code>vodex</code> as is, you can install the latest version via pip: <pre><code>pip install vodex\n</code></pre> or conda: <pre><code>conda install vodex -c conda-forge\n</code></pre></p>"},{"location":"install/#from-source","title":"From source","text":"<p>If you wish to modify and contribute to <code>vodex</code> install it locally in editable mode. This way, any changes you make to your copy of the package will reflect directly in your environment.</p> <pre><code>git clone https://github.com/LemonJust/vodex.git\ncd vodex\npip install -e .\n</code></pre> <p>Note: Use autoreload when working with packages in editable mode in IPython.</p>"},{"location":"api/","title":"Index","text":"<p>This part of the project documentation is a reference for the technical implementation of the <code>VoDEx</code> project code.</p> <p>VoDEx contains classes that assist in the creation, organization, and storage of information related to image acquisition and time annotation, allowing for the search and retrieval of image data based on specific conditions. This functionality is split into five modules: core, annotation, dbmethods, experiment, and loaders.</p> <ul> <li> <p>The core module provides the basic functionality for retrieving image data information.</p> </li> <li> <p>The annotation module handles the construction, validation, and storage of time annotation. For cyclic events, VoDEx keeps track of cycle iterations, which is important in behavioral experiments where the subject might become habituated to the repeated stimulus or learn over the course of the experiment.</p> </li> <li> <p>The dbmethods module abstracts the SQL calls, providing an easy-to-use interface to populate the SQLite database in which VoDEx stores information, and to query the database.</p> </li> <li> <p>The loaders module contains classes designed to load image data from specific file types, with current support for TIFF, and allows for easy addition of support for other file formats (see Contributions for more details).</p> </li> <li> <p>The experiment module contains the Experiment class, connecting all the functionalities of the VoDEx package and serving as the main point of entry for interacting with the package.</p> </li> </ul>"},{"location":"api/#core","title":"core","text":"<p>This module provides the core classes for loading and preprocessing imaging data.</p> <p>'ImageLoader' is the core class that loads the image data and selects the appropriate loader based on the file type. It also collects information about the data type and number of frames per file.</p> <p>'FileManager', 'FrameManager', and 'VolumeManager' are core classes that preprocess information about the experiment data. The 'FileManager' class contains information about the location and file type of the image files, while the 'FrameManager' class contains information about the number of frames in the experiment and the mapping of frames to files. The 'VolumeManager' class contains information about the image volumes in the experiment, including the number of frames per volume and the mapping of frames to volumes.</p>"},{"location":"api/#experiment","title":"experiment","text":"<p>This module contains the 'Experiment' class, which provides a summary of the information about an experiment. The class can initialise, save, and load the database, search for frames based on volumes or annotations, and load image data using the appropriate loader. To initialise the database, it integrates the information from the FileManager, FrameManager, VolumeManager, as well as Annotations, to create a database.</p>"},{"location":"api/#annotation","title":"annotation","text":"<p>This module provides the classes for constructing time annotations for imaging data.</p> <p>'TimeLabel', 'Labels', 'Cycle', 'Timeline', and 'Annotation' classes help to construct and store time annotations. The 'TimeLabel' class stores information about specific time-located events during the experiment, such as a specific condition described by a group and label. The 'Labels' class stores information about a group of time labels, such as temperature, light, sound, image on the screen, drug, or behavior. The 'Cycle' class stores and preprocesses information about repeated cycles of labels, useful for creating annotations for periodic conditions. The 'Timeline' class stores and preprocesses information about the sequence of labels, useful for creating annotations for non-periodic conditions. Finally, the 'Annotation' class stores and preprocesses information about the time annotation of the experiment; it uses either the 'Cycle' or 'Timeline' classes to initialize the annotation.</p>"},{"location":"api/#loaders","title":"loaders","text":"<p>This module contains classes for loading and collecting information from various file types.</p> <p>It includes:</p> <p>'Loader' - A generic class for loading files. Can be subclassed to create custom loaders for different file types.</p> <p>'TiffLoader' - A class for working with TIFF image files. A subclass of Loader, it can be used to determine the data type of the images, the number of frames in each TIFF file, and load frames from TIFF files.</p> <p>Additional loaders can be created to work with other file types. See  Contributions for details.</p>"},{"location":"api/#dbmethods","title":"dbmethods","text":"<p>This module contains classes that provide a consistent and easy-to-use interface for interacting with the SQLite database.</p> <p>DbWriter - A class that writes information to the database. It abstracts the SQLite calls and allows for easy creation, population, and saving of the database.</p> <p>DbReader - A class that reads information from the database. It abstracts the SQLite calls and allows for easy querying and retrieval of data from the database.</p> <p>DbExporter - A class that transforms the information from the database into the core classes, such as 'FileManager', 'VolumeManager', 'Labels', 'Timeline', 'Cycle' and 'Annotation', making it easier to view and edit with the data.</p>"},{"location":"api/annotation/","title":"vodex.annotation","text":"<p>This module provides the classes for constructing time annotations for imaging data.</p> <p>'TimeLabel', 'Labels', 'Cycle', 'Timeline', and 'Annotation' classes help to construct and store time annotations. The 'TimeLabel' class stores information about specific time-located events during the experiment, such as a specific condition described by a group and label. The 'Labels' class stores information about a group of time labels, such as temperature, light, sound, image on the screen, drug, or behavior. The 'Cycle' class stores and preprocesses information about repeated cycles of labels, useful for creating annotations for periodic conditions. The 'Timeline' class stores and preprocesses information about the sequence of labels, useful for creating annotations for non-periodic conditions. Finally, the 'Annotation' class stores and preprocesses information about the time annotation of the experiment; it uses either the 'Cycle' or 'Timeline' classes to initialize the annotation.</p>"},{"location":"api/annotation/#src.vodex.annotation.Annotation","title":"<code>Annotation</code>","text":"<p>Time annotation of the experiment.</p> <p>Either frame_to_label_dict or n_frames need to be provided to infer the number of frames. If both are provided , they need to agree.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>Labels</code> <p>Labels used to build the annotation</p> required <code>info</code> <code>str</code> <p>a short description of the annotation</p> <code>None</code> <code>frame_to_label</code> <code>List[TimeLabel]</code> <p>what label it is for each frame</p> required <code>frame_to_cycle</code> <code>List[int]</code> <p>what cycle it is for each frame</p> <code>None</code> <code>cycle</code> <code>Cycle</code> <p>for annotation from cycles keeps the cycle</p> <code>None</code> <code>n_frames</code> <code>int</code> <p>total number of frames, will be inferred from frame_to_label if not provided</p> required Source code in <code>src/vodex/annotation.py</code> <pre><code>class Annotation:\n    \"\"\"\n    Time annotation of the experiment.\n\n    Either frame_to_label_dict or n_frames need to be provided to infer the number of frames.\n    If both are provided , they need to agree.\n\n    Args:\n        labels: Labels used to build the annotation\n        info: a short description of the annotation\n        frame_to_label: what label it is for each frame\n        frame_to_cycle: what cycle it is for each frame\n        cycle: for annotation from cycles keeps the cycle\n        n_frames: total number of frames, will be inferred from frame_to_label if not provided\n    \"\"\"\n\n    def __init__(self, n_frames: int, labels: Labels,\n                 frame_to_label: List[TimeLabel], info: str = None,\n                 cycle: Cycle = None, frame_to_cycle: List[int] = None):\n\n        # get total experiment length in frames, check that it is consistent\n        if frame_to_label is not None:\n            assert n_frames == len(\n                frame_to_label), f\"The number of frames in the frame_to_label,\" \\\n                                 f\"{len(frame_to_label)},\" \\\n                                 f\"and the number of frames provided,\" \\\n                                 f\"{n_frames}, do not match.\"\n        self.n_frames = n_frames\n        self.frame_to_label = frame_to_label\n        self.labels = labels\n        self.name = self.labels.group\n        self.info = info\n        self.cycle = None\n\n        # None if the annotation is not from a cycle\n        assert (frame_to_cycle is None) == (\n                cycle is None), \"Creating Annotation: \" \\\n                                \"You have to provide both cycle and frame_to_cycle.\"\n        # if cycle is provided , check the input and add the info\n        if cycle is not None and frame_to_cycle is not None:\n            # check that frame_to_cycle is int\n            assert all(\n                isinstance(n, (int, np.integer)) for n in\n                frame_to_cycle), \"frame_to_cycle should be a list of int\"\n            assert n_frames == len(\n                frame_to_cycle), f\"The number of frames in the frame_to_cycle,\" \\\n                                 f\"{len(frame_to_cycle)},\" \\\n                                 f\"and the number of frames provided,\" \\\n                                 f\"{n_frames}, do not match.\"\n            self.cycle = cycle\n            self.frame_to_cycle = frame_to_cycle\n\n    def __eq__(self, other):\n        if isinstance(other, Annotation):\n            is_same = [\n                self.n_frames == other.n_frames,\n                self.frame_to_label == other.frame_to_label,\n                self.labels == other.labels,\n                self.name == other.name,\n                self.info == other.info\n            ]\n            # if one of the annotations has a cycle but the other doesn't\n            if (self.cycle is None) != (other.cycle is None):\n                return False\n            # if both have a cycle, compare cycles as well\n            elif self.cycle is not None:\n                is_same.extend([self.cycle == other.cycle,\n                                self.frame_to_cycle == other.frame_to_cycle])\n            return np.all(is_same)\n        else:\n            print(\n                f\"__eq__ is Not Implemented for {Annotation} and {type(other)}\")\n            return NotImplemented\n\n    @classmethod\n    def from_cycle(cls, n_frames: int, labels: Labels, cycle: Cycle,\n                   info: str = None):\n        \"\"\"\n        Creates an Annotation object from Cycle.\n\n        Args:\n            n_frames: total number of frames, must be provided\n            labels: Labels used to build the annotation\n            cycle: the cycle to create annotation from\n            info: a short description of the annotation\n        Returns:\n            (Annotation): Annotation object\n        \"\"\"\n        frame_to_label = cycle.fit_labels_to_frames(n_frames)\n        frame_to_cycle = cycle.fit_cycles_to_frames(n_frames)\n        return cls(n_frames, labels, frame_to_label, info=info,\n                   cycle=cycle, frame_to_cycle=frame_to_cycle)\n\n    @classmethod\n    def from_timeline(cls, n_frames: int, labels: Labels, timeline: Timeline,\n                      info: str = None):\n        \"\"\"\n        Creates an Annotation object from Timeline.\n\n        Args:\n            n_frames: total number of frames, must be provided\n            labels: Labels used to build the annotation\n            timeline: the timeline to create annotation from\n            info: a short description of the annotation\n        Returns:\n            (Annotation): Annotation object\n        \"\"\"\n        assert n_frames == timeline.full_length, \"number of frames and total timing should be the same\"\n        # make a fake cycle the length of the whole recording\n        frame_to_label = timeline.per_frame_list\n        return cls(n_frames, labels, frame_to_label, info=info)\n\n    @classmethod\n    def from_df(cls, n_frames: int, df: pd.DataFrame,\n                timing_conversion: Optional[dict] = None,\n                is_cycle: bool = False, info: Optional[str] = None):\n        \"\"\"\n        Creates an Annotation object from a dataframe.\n\n        Args:\n            n_frames: total number of frames, must be provided\n            df: dataframe with columns 'frame' and 'label'\n            timing_conversion: a dictionary to convert the timing of the annotation.\n                For example, if you want to convert the timing from frames to seconds,\n                and you were recording at 30 frames per second, you can use\n                timing_conversion = {'frames': 1, 'seconds': 1/30}\n                You can list multiple units in the dictionary, and the timing will be converted to all of them,\n                for example if there are also 10 frames per volume, you can use:\n                timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n                You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n                but it must be consistent with the other units. the rest of the values.\n                for example this is valid for the example above:\n                timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n                If timing_conversion is None, then the timing is not converted\n                and 'duration_frames' must be provided in the dataframe.\n            is_cycle: if True, the annotation is for a cycle\n            info: a short description of the annotation\n        Returns:\n            (Annotation): Annotation object\n        \"\"\"\n        if is_cycle:\n            cycle = Cycle.from_df(df, timing_conversion=timing_conversion)\n            labels = Labels.from_df(df)\n            return cls.from_cycle(n_frames, labels, cycle, info=info)\n        else:\n            timeline = Timeline.from_df(df, timing_conversion=timing_conversion)\n            labels = Labels.from_df(df)\n            return cls.from_timeline(n_frames, labels, timeline, info=info)\n\n    def get_timeline(self) -&gt; Timeline:\n        \"\"\"\n        Transforms frame_to_label to Timeline\n\n        Returns:\n            timeline of the resulting annotation\n        \"\"\"\n        duration = []\n        labels = []\n        for label, group in groupby(self.frame_to_label):\n            duration.append(sum(1 for _ in group))\n            labels.append(label)\n        return Timeline(labels, duration)\n\n    def cycle_info(self) -&gt; str:\n        \"\"\"\n        Creates and returns a description of a cycle.\n\n        Returns:\n            human-readable information about the cycle.\n        \"\"\"\n        if self.cycle is None:\n            cycle_info = \"Annotation doesn't have a cycle\"\n        else:\n            cycle_info = f\"{self.cycle.fit_frames(self.n_frames)} full cycles\" \\\n                         f\" [{self.n_frames / self.cycle.cycle_length} exactly]\\n\"\n            cycle_info = cycle_info + self.cycle.__str__()\n        return cycle_info\n\n    def __str__(self):\n        description = f\"Annotation type: {self.name}\\n\"\n        if self.info is not None:\n            description = description + f\"{self.info}\\n\"\n        description = description + f\"Total frames : {self.n_frames}\\n\"\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Annotation.cycle_info","title":"<code>cycle_info()</code>","text":"<p>Creates and returns a description of a cycle.</p> <p>Returns:</p> Type Description <code>str</code> <p>human-readable information about the cycle.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def cycle_info(self) -&gt; str:\n    \"\"\"\n    Creates and returns a description of a cycle.\n\n    Returns:\n        human-readable information about the cycle.\n    \"\"\"\n    if self.cycle is None:\n        cycle_info = \"Annotation doesn't have a cycle\"\n    else:\n        cycle_info = f\"{self.cycle.fit_frames(self.n_frames)} full cycles\" \\\n                     f\" [{self.n_frames / self.cycle.cycle_length} exactly]\\n\"\n        cycle_info = cycle_info + self.cycle.__str__()\n    return cycle_info\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Annotation.from_cycle","title":"<code>from_cycle(n_frames, labels, cycle, info=None)</code>  <code>classmethod</code>","text":"<p>Creates an Annotation object from Cycle.</p> <p>Parameters:</p> Name Type Description Default <code>n_frames</code> <code>int</code> <p>total number of frames, must be provided</p> required <code>labels</code> <code>Labels</code> <p>Labels used to build the annotation</p> required <code>cycle</code> <code>Cycle</code> <p>the cycle to create annotation from</p> required <code>info</code> <code>str</code> <p>a short description of the annotation</p> <code>None</code> <p>Returns:     (Annotation): Annotation object</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_cycle(cls, n_frames: int, labels: Labels, cycle: Cycle,\n               info: str = None):\n    \"\"\"\n    Creates an Annotation object from Cycle.\n\n    Args:\n        n_frames: total number of frames, must be provided\n        labels: Labels used to build the annotation\n        cycle: the cycle to create annotation from\n        info: a short description of the annotation\n    Returns:\n        (Annotation): Annotation object\n    \"\"\"\n    frame_to_label = cycle.fit_labels_to_frames(n_frames)\n    frame_to_cycle = cycle.fit_cycles_to_frames(n_frames)\n    return cls(n_frames, labels, frame_to_label, info=info,\n               cycle=cycle, frame_to_cycle=frame_to_cycle)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Annotation.from_df","title":"<code>from_df(n_frames, df, timing_conversion=None, is_cycle=False, info=None)</code>  <code>classmethod</code>","text":"<p>Creates an Annotation object from a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>n_frames</code> <code>int</code> <p>total number of frames, must be provided</p> required <code>df</code> <code>DataFrame</code> <p>dataframe with columns 'frame' and 'label'</p> required <code>timing_conversion</code> <code>Optional[dict]</code> <p>a dictionary to convert the timing of the annotation. For example, if you want to convert the timing from frames to seconds, and you were recording at 30 frames per second, you can use timing_conversion = {'frames': 1, 'seconds': 1/30} You can list multiple units in the dictionary, and the timing will be converted to all of them, for example if there are also 10 frames per volume, you can use: timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10} You must include 'frames' in the dictionary! The value of frames does not have to be 1, but it must be consistent with the other units. the rest of the values. for example this is valid for the example above: timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}. If timing_conversion is None, then the timing is not converted and 'duration_frames' must be provided in the dataframe.</p> <code>None</code> <code>is_cycle</code> <code>bool</code> <p>if True, the annotation is for a cycle</p> <code>False</code> <code>info</code> <code>Optional[str]</code> <p>a short description of the annotation</p> <code>None</code> <p>Returns:     (Annotation): Annotation object</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_df(cls, n_frames: int, df: pd.DataFrame,\n            timing_conversion: Optional[dict] = None,\n            is_cycle: bool = False, info: Optional[str] = None):\n    \"\"\"\n    Creates an Annotation object from a dataframe.\n\n    Args:\n        n_frames: total number of frames, must be provided\n        df: dataframe with columns 'frame' and 'label'\n        timing_conversion: a dictionary to convert the timing of the annotation.\n            For example, if you want to convert the timing from frames to seconds,\n            and you were recording at 30 frames per second, you can use\n            timing_conversion = {'frames': 1, 'seconds': 1/30}\n            You can list multiple units in the dictionary, and the timing will be converted to all of them,\n            for example if there are also 10 frames per volume, you can use:\n            timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n            You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n            but it must be consistent with the other units. the rest of the values.\n            for example this is valid for the example above:\n            timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n            If timing_conversion is None, then the timing is not converted\n            and 'duration_frames' must be provided in the dataframe.\n        is_cycle: if True, the annotation is for a cycle\n        info: a short description of the annotation\n    Returns:\n        (Annotation): Annotation object\n    \"\"\"\n    if is_cycle:\n        cycle = Cycle.from_df(df, timing_conversion=timing_conversion)\n        labels = Labels.from_df(df)\n        return cls.from_cycle(n_frames, labels, cycle, info=info)\n    else:\n        timeline = Timeline.from_df(df, timing_conversion=timing_conversion)\n        labels = Labels.from_df(df)\n        return cls.from_timeline(n_frames, labels, timeline, info=info)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Annotation.from_timeline","title":"<code>from_timeline(n_frames, labels, timeline, info=None)</code>  <code>classmethod</code>","text":"<p>Creates an Annotation object from Timeline.</p> <p>Parameters:</p> Name Type Description Default <code>n_frames</code> <code>int</code> <p>total number of frames, must be provided</p> required <code>labels</code> <code>Labels</code> <p>Labels used to build the annotation</p> required <code>timeline</code> <code>Timeline</code> <p>the timeline to create annotation from</p> required <code>info</code> <code>str</code> <p>a short description of the annotation</p> <code>None</code> <p>Returns:     (Annotation): Annotation object</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_timeline(cls, n_frames: int, labels: Labels, timeline: Timeline,\n                  info: str = None):\n    \"\"\"\n    Creates an Annotation object from Timeline.\n\n    Args:\n        n_frames: total number of frames, must be provided\n        labels: Labels used to build the annotation\n        timeline: the timeline to create annotation from\n        info: a short description of the annotation\n    Returns:\n        (Annotation): Annotation object\n    \"\"\"\n    assert n_frames == timeline.full_length, \"number of frames and total timing should be the same\"\n    # make a fake cycle the length of the whole recording\n    frame_to_label = timeline.per_frame_list\n    return cls(n_frames, labels, frame_to_label, info=info)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Annotation.get_timeline","title":"<code>get_timeline()</code>","text":"<p>Transforms frame_to_label to Timeline</p> <p>Returns:</p> Type Description <code>Timeline</code> <p>timeline of the resulting annotation</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def get_timeline(self) -&gt; Timeline:\n    \"\"\"\n    Transforms frame_to_label to Timeline\n\n    Returns:\n        timeline of the resulting annotation\n    \"\"\"\n    duration = []\n    labels = []\n    for label, group in groupby(self.frame_to_label):\n        duration.append(sum(1 for _ in group))\n        labels.append(label)\n    return Timeline(labels, duration)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle","title":"<code>Cycle</code>","text":"<p>Stores and preprocesses information about the repeated cycle of labels. Use it to create annotation when you have some periodic conditions. For example: light on , light off, light on, light off... will be made of list of labels [light_on, light_off] that repeat to cover the whole tie of the experiment. All labels must be from the same label group. Create multiple cycles to describe different label groups.</p> <p>Parameters:</p> Name Type Description Default <code>label_order</code> <code>List[TimeLabel]</code> <p>a list of labels in the right order in which they follow</p> required <code>duration</code> <code>Union[NDArray, List[int]]</code> <p>duration of the corresponding labels, in frames (based on your imaging). Note that these are frames, not volumes !</p> required <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>the name of the cycle, the same as the name of the grou p of the labels.</p> <code>label_order</code> <code>List[TimeLabel]</code> <p>the order in which the labels follow in a cycle.</p> <code>duration</code> <code>List[int]</code> <p>the duration of each label from the label_order ( in frames )</p> <code>cycle_length</code> <code>int</code> <p>the length of the cycle ( in frames )</p> <code>per_frame_list</code> <code>List[TimeLabel]</code> <p>mapping of frames to corresponding frames for one full cycle only.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>class Cycle:\n    \"\"\"\n    Stores and preprocesses information about the repeated cycle of labels.\n    Use it to create annotation when you have some periodic conditions.\n    For example: light on , light off, light on, light off... will be made of list of labels [light_on, light_off]\n    that repeat to cover the whole tie of the experiment. All labels must be from the same label group.\n    Create multiple cycles to describe different label groups.\n\n    Args:\n        label_order: a list of labels in the right order in which they follow\n        duration: duration of the corresponding labels, in frames (based on your imaging).\n            Note that these are frames, not volumes !\n\n    Attributes:\n        name: the name of the cycle, the same as the name of the grou p of the labels.\n        label_order: the order in which the labels follow in a cycle.\n        duration: the duration of each label from the label_order ( in frames )\n        cycle_length: the length of the cycle ( in frames )\n        per_frame_list: mapping of frames to corresponding frames for one full cycle only.\n    \"\"\"\n\n    def __init__(self, label_order: List[TimeLabel],\n                 duration: Union[npt.NDArray, List[int]]):\n        # check that all labels are from the same group\n        label_group = label_order[0].group\n        for label in label_order:\n            assert label.group == label_group, \\\n                f\"All labels should be from the same group, but got {label.group} and {label_group}\"\n        assert label_group is not None, \\\n            f\"All labels should be from the same group, label group can not be None\"\n\n        # check that timing is int\n        assert all(isinstance(n, (int, np.integer)) for n in\n                   duration), \"timing should be a list of int\"\n\n        self.name: str = label_group\n        self.label_order: List[TimeLabel] = label_order\n        self.duration: List[int] = list_of_int(duration)\n        self.cycle_length: int = sum(self.duration)\n        # list the length of the cycle, each element is the TimeLabel\n        # TODO : turn it into an index ?\n        self.per_frame_list: List[TimeLabel] = self._get_label_per_frame()\n\n    def __eq__(self, other):\n        if isinstance(other, Cycle):\n            is_same = [\n                self.name == other.name,\n                self.label_order == other.label_order,\n                self.duration == other.duration,\n                self.cycle_length == other.cycle_length,\n                self.per_frame_list == other.per_frame_list\n            ]\n\n            return np.all(is_same)\n        else:\n            print(f\"__eq__ is Not Implemented for {Cycle} and {type(other)}\")\n            return NotImplemented\n\n    def _get_label_per_frame(self) -&gt; List[TimeLabel]:\n        \"\"\"\n        Creates a list of labels per frame for one cycle only.\n\n        Returns:\n            labels per frame for one full cycle\n        \"\"\"\n        per_frame_label_list = []\n        for (label_time, label) in zip(self.duration, self.label_order):\n            per_frame_label_list.extend(label_time * [label])\n        return per_frame_label_list\n\n    def __str__(self):\n        description = f\"Cycle : {self.name}\\n\"\n        description = description + f\"Length: {self.cycle_length}\\n\"\n        for (label_time, label) in zip(self.duration, self.label_order):\n            description = description + f\"Label {label.name}: for {label_time} frames\\n\"\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n\n    def fit_frames(self, n_frames: int) -&gt; int:\n        \"\"\"\n        Calculates how many cycles you need to fully cover n_frames.\n        Assumes the cycle starts at the beginning of the recording.\n\n        Args:\n            n_frames: number of frames to cover, must be &gt;= 0.\n\n        Returns:\n            number of cycles (n_cycles) necessary to cover n_frames:\n            n_cycles*self.cycle_length &gt;= n_frames\n        \"\"\"\n        assert n_frames &gt;= 0, \"n_frames must be positive\"\n        n_cycles = int(np.ceil(n_frames / self.cycle_length))\n        return n_cycles\n\n    def fit_labels_to_frames(self, n_frames: int) -&gt; List[TimeLabel]:\n        \"\"\"\n        Create a list of labels corresponding to each frame in the range of n_frames\n\n        Args:\n            n_frames: number of frames to fit labels to, must be &gt;= 0.\n\n        Returns:\n            labels per frame for each frame in range of n_frames\n        \"\"\"\n        n_cycles = self.fit_frames(n_frames)\n        label_per_frame_list = np.tile(self.per_frame_list, n_cycles)\n        # crop the tail\n        return list(label_per_frame_list[0:n_frames])\n\n    def fit_cycles_to_frames(self, n_frames: int) -&gt; List[int]:\n        \"\"\"\n        Create a list of cycle ids (what cycle iteration it is) corresponding to each frame in the range of n_frames\n\n        Args:\n            n_frames: number of frames to fit cycle iterations to, must be &gt;= 0.\n        Returns:\n            cycle id per frame for each frame in range of n_frames\n        \"\"\"\n        n_cycles = self.fit_frames(n_frames)\n        cycle_per_frame_list = []\n        for n in np.arange(n_cycles):\n            cycle_per_frame_list.extend([int(n)] * self.cycle_length)\n        # crop the tail\n        return cycle_per_frame_list[0:n_frames]\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Put all the information about a Cycle object into a dictionary.\n\n        Returns:\n            a dictionary with fields 'timing' and 'label_order' which store self.duration and self.label order.\n        \"\"\"\n        label_order = [label.to_dict() for label in self.label_order]\n        d = {'timing': self.duration, 'label_order': label_order}\n        return d\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Put all the information about a Cycle object into a json file.\n\n        Returns:\n            a json with fields 'timing' and 'label_order' which store self.duration and self.label order.\n        \"\"\"\n        return json.dumps(self.to_dict())\n\n    def to_df(self, timing_conversion: Optional[dict] = None) -&gt; pd.DataFrame:\n        \"\"\"\n        Put all the information about a Cycle object into a dataframe.\n\n        Args:\n            timing_conversion: a dictionary to convert the timing into a different unit.\n                For example, if you want to convert the timing from frames to seconds,\n                and you were recording at 30 frames per second, you can use\n                timing_conversion = {'frames': 1, 'seconds': 1/30}\n                You can list multiple units in the dictionary, and the timing will be converted to all of them,\n                for example if there are also 10 frames per volume, you can use:\n                timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n                You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n                but it must be consistent with the other units. the rest of the values.\n                for example this is valid for the example above:\n                timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n                if timing_conversion is None, then the timing is not converted.\n                if timing_conversion is not None, then the timing is converted and both the original and converted\n                timing are added to the dataframe.\n\n        Returns:\n            a dataframe with columns 'timing', 'group', 'name' and 'description'.\n            'timing' will be written in all the units in the timing_conversion dictionary,\n            or just in frames, if timing_conversion is None.\n        \"\"\"\n        # TODO: move to/from methids to a separte class and inherit both Cycle and Timeline from it\n        # prepare timing columns\n        if timing_conversion is None:\n            timing_conversion = {'frames': 1}\n        assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n\n        timing_columns = ['duration_' + unit for unit in timing_conversion.keys()]\n        df = pd.DataFrame(columns=timing_columns + ['name', 'group', 'description'])\n\n        # write timing columns\n        for unit in timing_conversion.keys():\n            frames_per_unit = timing_conversion['frames'] / timing_conversion[unit]\n            duration = np.array(self.duration) / frames_per_unit\n            # if all are integers, turn to integer\n            if all(d.is_integer() for d in duration):\n                duration = duration.astype(int)\n            df['duration_' + unit] = duration\n\n        # write labels\n        df['name'] = [label.name for label in self.label_order]\n        df['group'] = [label.group for label in self.label_order]\n        df['description'] = [label.description for label in self.label_order]\n        return df\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        \"\"\"\n        Create a Cycle object from a dictionary.\n\n        Args:\n            d: dictionary to initialize the cycle.\n\n        Returns:\n            (Cycle): a Cycle object with label_order and duration initialized from 'label_order' and\n                    'timing' fields of the dictionary.\n        \"\"\"\n        label_order = [TimeLabel.from_dict(ld) for ld in d['label_order']]\n        return cls(label_order, d['timing'])\n\n    @classmethod\n    def from_json(cls, j: str):\n        \"\"\"\n        Create a Cycle object from a json string.\n\n        Args:\n            j : json string to initialise the cycle\n\n        Returns:\n            (Cycle): a Cycle object with label_order and duration initialised from 'label_order' and\n                    'timing' fields of the json srting.\n        \"\"\"\n        d = json.loads(j)\n        return cls.from_dict(d)\n\n    @classmethod\n    def from_df(cls, df: pd.DataFrame, timing_conversion: Optional[dict] = None):\n        \"\"\"\n        Create a Cycle object from a dataframe.\n\n        Args:\n            df : dataframe to initialise the cycle.\n                Must have columns 'group', 'name', optional column 'description'.\n                Either column 'duration_frames' or duration column in any other unit\n                and a timing_conversion dictionary to transform it to frames.\n                For example if column 'duration_seconds' is present,\n                the timing_conversion dictionary should be\n                {'frames': 30, 'seconds': 1} if the recording was at 30 frames per second.\n            timing_conversion: a dictionary to convert the timing into a different unit.\n                For example, if you want to convert the timing from frames to seconds,\n                and you were recording at 30 frames per second, you can use\n                timing_conversion = {'frames': 1, 'seconds': 1/30}\n                You can list multiple units in the dictionary, and the timing will be converted to all of them,\n                for example if there are also 10 frames per volume, you can use:\n                timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n                You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n                but it must be consistent with the other units. the rest of the values.\n                for example this is valid for the example above:\n                timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n                If timing_conversion is None, then the timing is not converted\n                and 'duration_frames' must be provided in the dataframe.\n        Returns:\n            (Cycle): a Cycle object with labels and duration initialised from 'group', 'name', 'description' and\n                    duration fields of the dataframe. In the order in which they appear in the dataframe.\n        \"\"\"\n        # TODO: add a check that the dataframe is valid\n        # TODO: move to/from methids to a separte class and inherit both Cycle and Timeline from it\n        label_order = []\n        for _, row in df.iterrows():\n            label_order.append(TimeLabel(row['name'],\n                                         group=row['group'],\n                                         description=row.get('description')\n                                         )\n                               )\n        if 'duration_frames' in df.columns:\n            duration_frames = df['duration_frames'].values\n        else:\n            assert timing_conversion is not None, \"if duration_frames is not in the dataframe, \" \\\n                                                  \"timing_conversion must be provided\"\n            # check that timing_conversion is a dictionary\n            assert isinstance(timing_conversion, dict), \"timing_conversion must be a dictionary\"\n            # check that frames are present in the timing_conversion dictionary\n            assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n            # list units that are present in both dataframe and timing_conversion dictionary\n            unit_list = [unit for unit in timing_conversion.keys() if 'duration_' + unit in df.columns]\n            # check that at least one unit from the timing_conversion dictionary is present in the dataframe\n            assert len(unit_list) &gt; 0, \"timing_conversion dictionary must have at least one \" \\\n                                       \"of the following keys in addition to 'frames': \" + \\\n                                       \", \".join([col_name.split('_')[1] for col_name in\n                                                  set(df.columns) - {'name', 'group', 'description'}])\n            unit = unit_list[0]\n            duration_frames = df['duration_' + unit].values * timing_conversion['frames'] / timing_conversion[unit]\n            # if all values in duration are integer, convert to int, else raise an assertion\n            if all(d.is_integer() for d in duration_frames):\n                duration_frames = duration_frames.astype(int)\n            else:\n                assert False, \"duration in frames must be integer after conversion from \" + unit\n\n        return cls(label_order, duration_frames)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.fit_cycles_to_frames","title":"<code>fit_cycles_to_frames(n_frames)</code>","text":"<p>Create a list of cycle ids (what cycle iteration it is) corresponding to each frame in the range of n_frames</p> <p>Parameters:</p> Name Type Description Default <code>n_frames</code> <code>int</code> <p>number of frames to fit cycle iterations to, must be &gt;= 0.</p> required <p>Returns:     cycle id per frame for each frame in range of n_frames</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def fit_cycles_to_frames(self, n_frames: int) -&gt; List[int]:\n    \"\"\"\n    Create a list of cycle ids (what cycle iteration it is) corresponding to each frame in the range of n_frames\n\n    Args:\n        n_frames: number of frames to fit cycle iterations to, must be &gt;= 0.\n    Returns:\n        cycle id per frame for each frame in range of n_frames\n    \"\"\"\n    n_cycles = self.fit_frames(n_frames)\n    cycle_per_frame_list = []\n    for n in np.arange(n_cycles):\n        cycle_per_frame_list.extend([int(n)] * self.cycle_length)\n    # crop the tail\n    return cycle_per_frame_list[0:n_frames]\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.fit_frames","title":"<code>fit_frames(n_frames)</code>","text":"<p>Calculates how many cycles you need to fully cover n_frames. Assumes the cycle starts at the beginning of the recording.</p> <p>Parameters:</p> Name Type Description Default <code>n_frames</code> <code>int</code> <p>number of frames to cover, must be &gt;= 0.</p> required <p>Returns:</p> Type Description <code>int</code> <p>number of cycles (n_cycles) necessary to cover n_frames:</p> <code>int</code> <p>n_cycles*self.cycle_length &gt;= n_frames</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def fit_frames(self, n_frames: int) -&gt; int:\n    \"\"\"\n    Calculates how many cycles you need to fully cover n_frames.\n    Assumes the cycle starts at the beginning of the recording.\n\n    Args:\n        n_frames: number of frames to cover, must be &gt;= 0.\n\n    Returns:\n        number of cycles (n_cycles) necessary to cover n_frames:\n        n_cycles*self.cycle_length &gt;= n_frames\n    \"\"\"\n    assert n_frames &gt;= 0, \"n_frames must be positive\"\n    n_cycles = int(np.ceil(n_frames / self.cycle_length))\n    return n_cycles\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.fit_labels_to_frames","title":"<code>fit_labels_to_frames(n_frames)</code>","text":"<p>Create a list of labels corresponding to each frame in the range of n_frames</p> <p>Parameters:</p> Name Type Description Default <code>n_frames</code> <code>int</code> <p>number of frames to fit labels to, must be &gt;= 0.</p> required <p>Returns:</p> Type Description <code>List[TimeLabel]</code> <p>labels per frame for each frame in range of n_frames</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def fit_labels_to_frames(self, n_frames: int) -&gt; List[TimeLabel]:\n    \"\"\"\n    Create a list of labels corresponding to each frame in the range of n_frames\n\n    Args:\n        n_frames: number of frames to fit labels to, must be &gt;= 0.\n\n    Returns:\n        labels per frame for each frame in range of n_frames\n    \"\"\"\n    n_cycles = self.fit_frames(n_frames)\n    label_per_frame_list = np.tile(self.per_frame_list, n_cycles)\n    # crop the tail\n    return list(label_per_frame_list[0:n_frames])\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.from_df","title":"<code>from_df(df, timing_conversion=None)</code>  <code>classmethod</code>","text":"<p>Create a Cycle object from a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>dataframe to initialise the cycle. Must have columns 'group', 'name', optional column 'description'. Either column 'duration_frames' or duration column in any other unit and a timing_conversion dictionary to transform it to frames. For example if column 'duration_seconds' is present, the timing_conversion dictionary should be {'frames': 30, 'seconds': 1} if the recording was at 30 frames per second.</p> required <code>timing_conversion</code> <code>Optional[dict]</code> <p>a dictionary to convert the timing into a different unit. For example, if you want to convert the timing from frames to seconds, and you were recording at 30 frames per second, you can use timing_conversion = {'frames': 1, 'seconds': 1/30} You can list multiple units in the dictionary, and the timing will be converted to all of them, for example if there are also 10 frames per volume, you can use: timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10} You must include 'frames' in the dictionary! The value of frames does not have to be 1, but it must be consistent with the other units. the rest of the values. for example this is valid for the example above: timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}. If timing_conversion is None, then the timing is not converted and 'duration_frames' must be provided in the dataframe.</p> <code>None</code> <p>Returns:     (Cycle): a Cycle object with labels and duration initialised from 'group', 'name', 'description' and             duration fields of the dataframe. In the order in which they appear in the dataframe.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_df(cls, df: pd.DataFrame, timing_conversion: Optional[dict] = None):\n    \"\"\"\n    Create a Cycle object from a dataframe.\n\n    Args:\n        df : dataframe to initialise the cycle.\n            Must have columns 'group', 'name', optional column 'description'.\n            Either column 'duration_frames' or duration column in any other unit\n            and a timing_conversion dictionary to transform it to frames.\n            For example if column 'duration_seconds' is present,\n            the timing_conversion dictionary should be\n            {'frames': 30, 'seconds': 1} if the recording was at 30 frames per second.\n        timing_conversion: a dictionary to convert the timing into a different unit.\n            For example, if you want to convert the timing from frames to seconds,\n            and you were recording at 30 frames per second, you can use\n            timing_conversion = {'frames': 1, 'seconds': 1/30}\n            You can list multiple units in the dictionary, and the timing will be converted to all of them,\n            for example if there are also 10 frames per volume, you can use:\n            timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n            You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n            but it must be consistent with the other units. the rest of the values.\n            for example this is valid for the example above:\n            timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n            If timing_conversion is None, then the timing is not converted\n            and 'duration_frames' must be provided in the dataframe.\n    Returns:\n        (Cycle): a Cycle object with labels and duration initialised from 'group', 'name', 'description' and\n                duration fields of the dataframe. In the order in which they appear in the dataframe.\n    \"\"\"\n    # TODO: add a check that the dataframe is valid\n    # TODO: move to/from methids to a separte class and inherit both Cycle and Timeline from it\n    label_order = []\n    for _, row in df.iterrows():\n        label_order.append(TimeLabel(row['name'],\n                                     group=row['group'],\n                                     description=row.get('description')\n                                     )\n                           )\n    if 'duration_frames' in df.columns:\n        duration_frames = df['duration_frames'].values\n    else:\n        assert timing_conversion is not None, \"if duration_frames is not in the dataframe, \" \\\n                                              \"timing_conversion must be provided\"\n        # check that timing_conversion is a dictionary\n        assert isinstance(timing_conversion, dict), \"timing_conversion must be a dictionary\"\n        # check that frames are present in the timing_conversion dictionary\n        assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n        # list units that are present in both dataframe and timing_conversion dictionary\n        unit_list = [unit for unit in timing_conversion.keys() if 'duration_' + unit in df.columns]\n        # check that at least one unit from the timing_conversion dictionary is present in the dataframe\n        assert len(unit_list) &gt; 0, \"timing_conversion dictionary must have at least one \" \\\n                                   \"of the following keys in addition to 'frames': \" + \\\n                                   \", \".join([col_name.split('_')[1] for col_name in\n                                              set(df.columns) - {'name', 'group', 'description'}])\n        unit = unit_list[0]\n        duration_frames = df['duration_' + unit].values * timing_conversion['frames'] / timing_conversion[unit]\n        # if all values in duration are integer, convert to int, else raise an assertion\n        if all(d.is_integer() for d in duration_frames):\n            duration_frames = duration_frames.astype(int)\n        else:\n            assert False, \"duration in frames must be integer after conversion from \" + unit\n\n    return cls(label_order, duration_frames)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Cycle object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary to initialize the cycle.</p> required <p>Returns:</p> Type Description <code>Cycle</code> <p>a Cycle object with label_order and duration initialized from 'label_order' and     'timing' fields of the dictionary.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a Cycle object from a dictionary.\n\n    Args:\n        d: dictionary to initialize the cycle.\n\n    Returns:\n        (Cycle): a Cycle object with label_order and duration initialized from 'label_order' and\n                'timing' fields of the dictionary.\n    \"\"\"\n    label_order = [TimeLabel.from_dict(ld) for ld in d['label_order']]\n    return cls(label_order, d['timing'])\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.from_json","title":"<code>from_json(j)</code>  <code>classmethod</code>","text":"<p>Create a Cycle object from a json string.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <p>json string to initialise the cycle</p> required <p>Returns:</p> Type Description <code>Cycle</code> <p>a Cycle object with label_order and duration initialised from 'label_order' and     'timing' fields of the json srting.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_json(cls, j: str):\n    \"\"\"\n    Create a Cycle object from a json string.\n\n    Args:\n        j : json string to initialise the cycle\n\n    Returns:\n        (Cycle): a Cycle object with label_order and duration initialised from 'label_order' and\n                'timing' fields of the json srting.\n    \"\"\"\n    d = json.loads(j)\n    return cls.from_dict(d)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.to_df","title":"<code>to_df(timing_conversion=None)</code>","text":"<p>Put all the information about a Cycle object into a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>timing_conversion</code> <code>Optional[dict]</code> <p>a dictionary to convert the timing into a different unit. For example, if you want to convert the timing from frames to seconds, and you were recording at 30 frames per second, you can use timing_conversion = {'frames': 1, 'seconds': 1/30} You can list multiple units in the dictionary, and the timing will be converted to all of them, for example if there are also 10 frames per volume, you can use: timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10} You must include 'frames' in the dictionary! The value of frames does not have to be 1, but it must be consistent with the other units. the rest of the values. for example this is valid for the example above: timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}. if timing_conversion is None, then the timing is not converted. if timing_conversion is not None, then the timing is converted and both the original and converted timing are added to the dataframe.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a dataframe with columns 'timing', 'group', 'name' and 'description'.</p> <code>DataFrame</code> <p>'timing' will be written in all the units in the timing_conversion dictionary,</p> <code>DataFrame</code> <p>or just in frames, if timing_conversion is None.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_df(self, timing_conversion: Optional[dict] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Put all the information about a Cycle object into a dataframe.\n\n    Args:\n        timing_conversion: a dictionary to convert the timing into a different unit.\n            For example, if you want to convert the timing from frames to seconds,\n            and you were recording at 30 frames per second, you can use\n            timing_conversion = {'frames': 1, 'seconds': 1/30}\n            You can list multiple units in the dictionary, and the timing will be converted to all of them,\n            for example if there are also 10 frames per volume, you can use:\n            timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n            You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n            but it must be consistent with the other units. the rest of the values.\n            for example this is valid for the example above:\n            timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n            if timing_conversion is None, then the timing is not converted.\n            if timing_conversion is not None, then the timing is converted and both the original and converted\n            timing are added to the dataframe.\n\n    Returns:\n        a dataframe with columns 'timing', 'group', 'name' and 'description'.\n        'timing' will be written in all the units in the timing_conversion dictionary,\n        or just in frames, if timing_conversion is None.\n    \"\"\"\n    # TODO: move to/from methids to a separte class and inherit both Cycle and Timeline from it\n    # prepare timing columns\n    if timing_conversion is None:\n        timing_conversion = {'frames': 1}\n    assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n\n    timing_columns = ['duration_' + unit for unit in timing_conversion.keys()]\n    df = pd.DataFrame(columns=timing_columns + ['name', 'group', 'description'])\n\n    # write timing columns\n    for unit in timing_conversion.keys():\n        frames_per_unit = timing_conversion['frames'] / timing_conversion[unit]\n        duration = np.array(self.duration) / frames_per_unit\n        # if all are integers, turn to integer\n        if all(d.is_integer() for d in duration):\n            duration = duration.astype(int)\n        df['duration_' + unit] = duration\n\n    # write labels\n    df['name'] = [label.name for label in self.label_order]\n    df['group'] = [label.group for label in self.label_order]\n    df['description'] = [label.description for label in self.label_order]\n    return df\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.to_dict","title":"<code>to_dict()</code>","text":"<p>Put all the information about a Cycle object into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with fields 'timing' and 'label_order' which store self.duration and self.label order.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Put all the information about a Cycle object into a dictionary.\n\n    Returns:\n        a dictionary with fields 'timing' and 'label_order' which store self.duration and self.label order.\n    \"\"\"\n    label_order = [label.to_dict() for label in self.label_order]\n    d = {'timing': self.duration, 'label_order': label_order}\n    return d\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Cycle.to_json","title":"<code>to_json()</code>","text":"<p>Put all the information about a Cycle object into a json file.</p> <p>Returns:</p> Type Description <code>str</code> <p>a json with fields 'timing' and 'label_order' which store self.duration and self.label order.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Put all the information about a Cycle object into a json file.\n\n    Returns:\n        a json with fields 'timing' and 'label_order' which store self.duration and self.label order.\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Labels","title":"<code>Labels</code>","text":"<p>Stores information about a group of time labels. Any specific aspect of the experiment that you want to document.     For example: temperature|light|sound|image on the screen|drug|behaviour ... etc.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <p>the name of the group</p> required <code>group_info</code> <p>description of what this group is about. Just for storing the information.</p> <code>None</code> <code>state_names</code> <code>List[str]</code> <p>the state names</p> required <code>state_info</code> <code>Optional[dict]</code> <p>description of each individual state {state name : description}. Just for storing the information.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>group</code> <p>the name of the group</p> <code>group_info</code> <p>description of what this group is about. Just for storing the information.</p> <code>state_names</code> <p>the state names</p> <code>states</code> <p>list of states, each state as a TimeLabel object</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>class Labels:\n    \"\"\"\n    Stores information about a group of time labels. Any specific aspect of the experiment that you want to document.\n        For example: temperature|light|sound|image on the screen|drug|behaviour ... etc.\n\n    Args:\n        group : the name of the group\n        group_info : description of what this group is about. Just for storing the information.\n        state_names: the state names\n        state_info: description of each individual state {state name : description}. Just for storing the information.\n\n    Attributes:\n        group: the name of the group\n        group_info: description of what this group is about. Just for storing the information.\n        state_names: the state names\n        states: list of states, each state as a TimeLabel object\n\n    \"\"\"\n\n    def __init__(self, group: str, state_names: List[str],\n                 group_info: str = None, state_info: Optional[dict] = None):\n\n        if state_info is None:\n            state_info = {}\n        self.group = group\n        self.group_info = group_info\n        self.state_names = state_names\n        # create states\n        self.states = []\n        for state_name in self.state_names:\n            if state_name in state_info:\n                state = TimeLabel(state_name,\n                                  description=state_info[state_name],\n                                  group=self.group)\n                setattr(self, state_name, state)\n            else:\n                state = TimeLabel(state_name, group=self.group)\n                setattr(self, state_name, state)\n            self.states.append(state)\n\n    def __eq__(self, other):\n        if isinstance(other, Labels):\n            is_same = [\n                self.group == other.group,\n                self.group_info == other.group_info,\n                set(self.state_names) == set(other.state_names),\n                set(self.states) == set(other.states)\n            ]\n\n            return np.all(is_same)\n        else:\n            print(f\"__eq__ is Not Implemented for {Labels} and {type(other)}\")\n            return NotImplemented\n\n    def __str__(self):\n        description = f\"Label group : {self.group}\\n\"\n        description = description + f\"States:\\n\"\n        for state_name in self.state_names:\n            description = description + f\"{getattr(self, state_name)}\\n\"\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        \"\"\"\n        Create a Labels object from a dictionary.\n\n        Returns:\n            (Labels): a Labels object with attributes 'group', 'group_info', 'state_names', 'states'\n                    filled from the dictionary fields.\n        \"\"\"\n        group_info = None\n        state_info = None\n        if 'group_info' in d:\n            group_info = d['group_info']\n        if 'state_info' in d:\n            state_info = d['state_info']\n        return cls(d['group'], d['state_names'], group_info=group_info, state_info=state_info)\n\n    @classmethod\n    def from_df(cls, df: pd.DataFrame, group: str = None):\n        \"\"\"\n        Create a Labels object from a dataframe.\n                The dataframe must have columns 'group', 'name', optional column 'description'.\n                'group' column must be the same for all rows. 'name' columns contains the state names,\n                state names can repeat and only the unique state names will be used. The descriptions are optional,\n                if provided then the descriptions of the same state name must be the same or left empty.\n\n        Arg:\n            df: the dataframe\n            group: if not None, keep only the rows with this group name.\n                Must be provided if there are multiple groups in the dataframe.\n        Returns:\n            (Labels): a Labels object with attributes 'group', 'group_info', 'state_names', 'states'\n                    inferred and filled from the dataframe.\n        \"\"\"\n        # if group is not none, keep only the group rows\n        if group is not None:\n            if group not in df['group'].unique():\n                raise ValueError(f\"Group {group} not found in the dataframe.\")\n            df = df[df['group'] == group]\n\n        # check that group is the same for all rows\n        group = df['group'].unique()\n        if len(group) &gt; 1:\n            raise ValueError(\n                f\"More than one group found in the dataframe: {group}\")\n        group = group[0]\n\n        state_names = df['name'].unique()\n        state_info = {}\n        for state_name in state_names:\n            if 'description' in df.columns:\n                # check that all descriptions are either the same or empty\n                description = df[df['name'] == state_name]['description'].unique()\n                if len(description) &gt; 2:\n                    raise ValueError(\n                        f\"More than one description found for state {state_name}: {description}\")\n                elif len(description) == 2:\n                    # one must be an empty string or None\n                    if not ('' in description or None in description):\n                        raise ValueError(\n                            f\"More than one description found for state {state_name}: {description}\")\n                else:\n                    state_info[state_name] = description[0]\n            else:\n                state_info[state_name] = None\n\n        return cls(group, state_names.tolist(), group_info=None, state_info=state_info)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Labels.from_df","title":"<code>from_df(df, group=None)</code>  <code>classmethod</code>","text":"<p>Create a Labels object from a dataframe.         The dataframe must have columns 'group', 'name', optional column 'description'.         'group' column must be the same for all rows. 'name' columns contains the state names,         state names can repeat and only the unique state names will be used. The descriptions are optional,         if provided then the descriptions of the same state name must be the same or left empty.</p> Arg <p>df: the dataframe group: if not None, keep only the rows with this group name.     Must be provided if there are multiple groups in the dataframe.</p> <p>Returns:     (Labels): a Labels object with attributes 'group', 'group_info', 'state_names', 'states'             inferred and filled from the dataframe.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_df(cls, df: pd.DataFrame, group: str = None):\n    \"\"\"\n    Create a Labels object from a dataframe.\n            The dataframe must have columns 'group', 'name', optional column 'description'.\n            'group' column must be the same for all rows. 'name' columns contains the state names,\n            state names can repeat and only the unique state names will be used. The descriptions are optional,\n            if provided then the descriptions of the same state name must be the same or left empty.\n\n    Arg:\n        df: the dataframe\n        group: if not None, keep only the rows with this group name.\n            Must be provided if there are multiple groups in the dataframe.\n    Returns:\n        (Labels): a Labels object with attributes 'group', 'group_info', 'state_names', 'states'\n                inferred and filled from the dataframe.\n    \"\"\"\n    # if group is not none, keep only the group rows\n    if group is not None:\n        if group not in df['group'].unique():\n            raise ValueError(f\"Group {group} not found in the dataframe.\")\n        df = df[df['group'] == group]\n\n    # check that group is the same for all rows\n    group = df['group'].unique()\n    if len(group) &gt; 1:\n        raise ValueError(\n            f\"More than one group found in the dataframe: {group}\")\n    group = group[0]\n\n    state_names = df['name'].unique()\n    state_info = {}\n    for state_name in state_names:\n        if 'description' in df.columns:\n            # check that all descriptions are either the same or empty\n            description = df[df['name'] == state_name]['description'].unique()\n            if len(description) &gt; 2:\n                raise ValueError(\n                    f\"More than one description found for state {state_name}: {description}\")\n            elif len(description) == 2:\n                # one must be an empty string or None\n                if not ('' in description or None in description):\n                    raise ValueError(\n                        f\"More than one description found for state {state_name}: {description}\")\n            else:\n                state_info[state_name] = description[0]\n        else:\n            state_info[state_name] = None\n\n    return cls(group, state_names.tolist(), group_info=None, state_info=state_info)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Labels.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Labels object from a dictionary.</p> <p>Returns:</p> Type Description <code>Labels</code> <p>a Labels object with attributes 'group', 'group_info', 'state_names', 'states'     filled from the dictionary fields.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a Labels object from a dictionary.\n\n    Returns:\n        (Labels): a Labels object with attributes 'group', 'group_info', 'state_names', 'states'\n                filled from the dictionary fields.\n    \"\"\"\n    group_info = None\n    state_info = None\n    if 'group_info' in d:\n        group_info = d['group_info']\n    if 'state_info' in d:\n        state_info = d['state_info']\n    return cls(d['group'], d['state_names'], group_info=group_info, state_info=state_info)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.TimeLabel","title":"<code>TimeLabel</code>","text":"<p>Stores information about a particular time-located event during the experiment: any specific condition, described by a group and the label. For example: group 'light', label 'on': the light was on; group 'light', label 'off': the light was off.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name for the time label. This is a unique identifier of the label.         Different labels must have different names.         Different labels are compared based on their names, so the same name means it is the same event.</p> required <code>description</code> <code>str</code> <p>a detailed description of the label. This is to give you more info, but it is not used for anything else.</p> <code>None</code> <code>group</code> <code>str</code> <p>the group that the label belongs to.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>the name for the time label. This is a unique identifier of the label.         Different labels must have different names.         Different labels are compared based on their names, so the same name means it is the same event.</p> <code>description</code> <code>str</code> <p>a detailed description of the label. This is to give you more info, but it is not used for anything else.</p> <code>group</code> <code>str</code> <p>the group that the label belongs to.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>class TimeLabel:\n    \"\"\"\n    Stores information about a particular time-located event during the experiment: any specific condition,\n    described by a group and the label.\n    For example: group 'light', label 'on': the light was on; group 'light', label 'off': the light was off.\n\n    Args:\n        name: the name for the time label. This is a unique identifier of the label.\n                    Different labels must have different names.\n                    Different labels are compared based on their names, so the same name means it is the same event.\n        description: a detailed description of the label. This is to give you more info, but it is not used for\n            anything else.\n        group: the group that the label belongs to.\n\n    Attributes:\n        name: the name for the time label. This is a unique identifier of the label.\n                    Different labels must have different names.\n                    Different labels are compared based on their names, so the same name means it is the same event.\n        description: a detailed description of the label. This is to give you more info, but it is not used for\n            anything else.\n        group: the group that the label belongs to.\n    \"\"\"\n\n    def __init__(self, name: str, description: str = None, group: str = None):\n        self.name: str = name\n        self.group: str = group\n        self.description: str = description\n\n    def __str__(self):\n        description = self.name\n        if self.description is not None:\n            description = description + \" : \" + self.description\n        if self.group is not None:\n            description = description + \". Group: \" + self.group\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __hash__(self):\n        # necessary for instances to behave sanely in dicts and sets.\n        return hash((self.name, self.group))\n\n    def __eq__(self, other):\n        if isinstance(other, TimeLabel):\n            # comparing by name\n            same_name = self.name == other.name\n            if self.group is not None or other.group is not None:\n                same_group = self.group == other.group\n                return same_name and same_group\n            else:\n                return same_name\n        else:\n            print(\n                f\"__eq__ is Not Implemented for {TimeLabel} and {type(other)}\")\n            return NotImplemented\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Put all the information about a TimeLabel object into a dictionary.\n\n        Returns:\n            a dictionary with fields 'name', 'group', 'description' which store the corresponding attributes.\n        \"\"\"\n        d = {'name': self.name}\n        if self.group is not None:\n            d['group'] = self.group\n        if self.description is not None:\n            d['description'] = self.description\n        return d\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        \"\"\"\n        Create a TimeLabel object from a dictionary.\n\n        Returns:\n            (TimeLabel): a TimeLabel object with attributes 'name', 'group', 'description'\n                    filled from the dictionary fields.\n        \"\"\"\n        description = None\n        group = None\n        if 'description' in d:\n            description = d['description']\n        if 'group' in d:\n            group = d['group']\n        return cls(d['name'], description=description, group=group)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.TimeLabel.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a TimeLabel object from a dictionary.</p> <p>Returns:</p> Type Description <code>TimeLabel</code> <p>a TimeLabel object with attributes 'name', 'group', 'description'     filled from the dictionary fields.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a TimeLabel object from a dictionary.\n\n    Returns:\n        (TimeLabel): a TimeLabel object with attributes 'name', 'group', 'description'\n                filled from the dictionary fields.\n    \"\"\"\n    description = None\n    group = None\n    if 'description' in d:\n        description = d['description']\n    if 'group' in d:\n        group = d['group']\n    return cls(d['name'], description=description, group=group)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.TimeLabel.to_dict","title":"<code>to_dict()</code>","text":"<p>Put all the information about a TimeLabel object into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with fields 'name', 'group', 'description' which store the corresponding attributes.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Put all the information about a TimeLabel object into a dictionary.\n\n    Returns:\n        a dictionary with fields 'name', 'group', 'description' which store the corresponding attributes.\n    \"\"\"\n    d = {'name': self.name}\n    if self.group is not None:\n        d['group'] = self.group\n    if self.description is not None:\n        d['description'] = self.description\n    return d\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline","title":"<code>Timeline</code>","text":"<p>Information about the sequence of labels. Use it when you have non-periodic conditions.</p> <p>Parameters:</p> Name Type Description Default <code>label_order</code> <code>List[TimeLabel]</code> <p>a list of labels in the right order in which they follow</p> required <code>duration</code> <code>Union[NDArray, List[int]]</code> <p>duration of the corresponding labels, in frames (based on your imaging). Note that these are frames, not volumes !</p> required Source code in <code>src/vodex/annotation.py</code> <pre><code>class Timeline:\n    \"\"\"\n    Information about the sequence of labels. Use it when you have non-periodic conditions.\n\n    Args:\n        label_order: a list of labels in the right order in which they follow\n        duration: duration of the corresponding labels, in frames (based on your imaging). Note that these are\n            frames, not volumes !\n    \"\"\"\n\n    def __init__(self, label_order: List[TimeLabel],\n                 duration: Union[npt.NDArray, List[int]]):\n\n        # check that all labels are from the same group\n        label_group = label_order[0].group\n        for label in label_order:\n            assert label.group == label_group, \\\n                f\"All labels should be from the same group, but got {label.group} and {label_group}\"\n        assert label_group is not None, \\\n            f\"All labels should be from the same group, label group can not be None\"\n\n        # check that timing is int\n        assert all(isinstance(n, (int, np.integer)) for n in\n                   duration), \"timing should be a list of int\"\n\n        self.name = label_group\n        self.label_order = label_order\n        self.duration = list_of_int(duration)\n        self.full_length = sum(self.duration)\n        # list the length of the cycle, each element is the TimeLabel\n        # TODO : turn it into an index ?\n        self.per_frame_list = self.get_label_per_frame()\n\n    def __eq__(self, other):\n        if isinstance(other, Timeline):\n            is_same = [\n                self.name == other.name,\n                self.label_order == other.label_order,\n                self.duration == other.duration,\n                self.full_length == other.full_length,\n                self.per_frame_list == other.per_frame_list\n            ]\n\n            return np.all(is_same)\n        else:\n            print(\n                f\"__eq__ is Not Implemented for {Timeline} and {type(other)}\")\n            return NotImplemented\n\n    def get_label_per_frame(self) -&gt; List[TimeLabel]:\n        \"\"\"\n        A list of labels per frame for the duration of the experiment.\n\n        Returns:\n            labels per frame for the experiment.\n        \"\"\"\n        per_frame_label_list = []\n        for (label_time, label) in zip(self.duration, self.label_order):\n            per_frame_label_list.extend(label_time * [label])\n        return per_frame_label_list\n\n    def __str__(self):\n        description = f\"Timeline : {self.name}\\n\"\n        description = description + f\"Length: {self.full_length}\\n\"\n        for (label_time, label) in zip(self.duration, self.label_order):\n            description = description + f\"Label {label.name}: for {label_time} frames\\n\"\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Put all the information about a Timeline object into a dictionary.\n\n        Returns:\n            a dictionary with fields 'label_order' and 'timing' .\n        \"\"\"\n        return {'timing': self.duration,\n                'label_order': [label.to_dict() for label in self.label_order],\n                }\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Put all the information about a Timeline object into a json string.\n\n        Returns:\n            a json string with fields 'label_order' and 'timing' .\n        \"\"\"\n        return json.dumps(self.to_dict())\n\n    def to_df(self, timing_conversion: Optional[dict] = None) -&gt; pd.DataFrame:\n        \"\"\"\n        Put all the information about a Timeline object into a dataframe.\n\n        Args:\n            timing_conversion: a dictionary to convert the timing into a different unit.\n                For example, if you want to convert the timing from frames to seconds,\n                and you were recording at 30 frames per second, you can use\n                timing_conversion = {'frames': 1, 'seconds': 1/30}\n                You can list multiple units in the dictionary, and the timing will be converted to all of them,\n                for example if there are also 10 frames per volume, you can use:\n                timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n                You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n                but it must be consistent with the other units. the rest of the values.\n                for example this is valid for the example above:\n                timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n                if timing_conversion is None, then the timing is not converted.\n                if timing_conversion is not None, then the timing is converted and both the original and converted\n                timing are added to the dataframe.\n\n        Returns:\n            a dataframe with columns 'timing', 'group', 'name' and 'description'.\n            'timing' will be written in all the units in the timing_conversion dictionary,\n            or just in frames, if timing_conversion is None.\n        \"\"\"\n        # prepare timing columns\n        if timing_conversion is None:\n            timing_conversion = {'frames': 1}\n        assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n\n        timing_columns = ['duration_' + unit for unit in timing_conversion.keys()]\n        df = pd.DataFrame(columns=timing_columns + ['name', 'group', 'description'])\n\n        # write timing columns\n        for unit in timing_conversion.keys():\n            frames_per_unit = timing_conversion['frames'] / timing_conversion[unit]\n            duration = np.array(self.duration) / frames_per_unit\n            # if all are integers, turn to integer\n            if all(d.is_integer() for d in duration):\n                duration = duration.astype(int)\n            df['duration_' + unit] = duration\n\n        # write labels\n        df['name'] = [label.name for label in self.label_order]\n        df['group'] = [label.group for label in self.label_order]\n        df['description'] = [label.description for label in self.label_order]\n        return df\n\n    @classmethod\n    def from_dict(cls, d: dict):\n        \"\"\"\n        Create a Timeline object from a dictionary.\n\n        Args:\n            d: dictionary to initialize the timeline.\n\n        Returns:\n            (Timeline): a Timeline object with label_order and duration initialized from 'label_order' and\n                    'timing' fields of the dictionary.\n        \"\"\"\n        label_order = [TimeLabel.from_dict(ld) for ld in d['label_order']]\n        return cls(label_order, d['timing'])\n\n    @classmethod\n    def from_json(cls, j: str):\n        \"\"\"\n        Create a Timeline object from a json string.\n\n        Args:\n            j : json string to initialise the cycle\n\n        Returns:\n            (Timeline): a Timeline object with label_order and duration initialised from 'label_order' and\n                    'timing' fields of the json srting.\n        \"\"\"\n        d = json.loads(j)\n        return cls.from_dict(d)\n\n    @classmethod\n    def from_df(cls, df: pd.DataFrame, timing_conversion: Optional[dict] = None):\n        \"\"\"\n        Create a Timeline object from a dataframe.\n\n        Args:\n            df : dataframe to initialise the timeline.\n                Must have columns 'group', 'name', optional column 'description'.\n                Either column 'duration_frames' or duration column in any other unit\n                and a timing_conversion dictionary to transform it to frames.\n                For example if column 'duration_seconds' is present,\n                the timing_conversion dictionary should be\n                {'frames': 30, 'seconds': 1} if the recording was at 30 frames per second.\n            timing_conversion: a dictionary to convert the timing into a different unit.\n                For example, if you want to convert the timing from frames to seconds,\n                and you were recording at 30 frames per second, you can use\n                timing_conversion = {'frames': 1, 'seconds': 1/30}\n                You can list multiple units in the dictionary, and the timing will be converted to all of them,\n                for example if there are also 10 frames per volume, you can use:\n                timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n                You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n                but it must be consistent with the other units. the rest of the values.\n                for example this is valid for the example above:\n                timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n                If timing_conversion is None, then the timing is not converted\n                and 'duration_frames' must be provided in the dataframe.\n\n        Returns:\n            (Timeline): a Timeline object with labels and duration initialised from 'group', 'name', 'description' and\n                    duration fields of the dataframe. In the order in which they appear in the dataframe.\n        \"\"\"\n        label_order = []\n        for _, row in df.iterrows():\n            label_order.append(TimeLabel(row['name'],\n                                         group=row['group'],\n                                         description=row.get('description')\n                                         )\n                               )\n        if 'duration_frames' in df.columns:\n            duration_frames = df['duration_frames'].values\n        else:\n            assert timing_conversion is not None, \"if duration_frames is not in the dataframe, \" \\\n                                                  \"timing_conversion must be provided\"\n            # check that timing_conversion is a dictionary\n            assert isinstance(timing_conversion, dict), \"timing_conversion must be a dictionary\"\n            # check that frames are present in the timing_conversion dictionary\n            assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n            # list units that are present in both dataframe and timing_conversion dictionary\n            unit_list = [unit for unit in timing_conversion.keys() if 'duration_' + unit in df.columns]\n            # check that at least one unit from the timing_conversion dictionary is present in the dataframe\n            assert len(unit_list) &gt; 0, \"timing_conversion dictionary must have at least one \" \\\n                                       \"of the following keys in addition to 'frames': \" + \\\n                                       \", \".join([col_name.split('_')[1] for col_name in\n                                                  set(df.columns) - {'name', 'group', 'description'}])\n            unit = unit_list[0]\n            duration_frames = df['duration_' + unit].values * timing_conversion['frames'] / timing_conversion[unit]\n            # if all values in duration are integer, convert to int, else raise an assertion\n            if all(d.is_integer() for d in duration_frames):\n                duration_frames = duration_frames.astype(int)\n            else:\n                assert False, \"duration in frames must be integer after conversion from \" + unit\n\n        return cls(label_order, duration_frames)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.from_df","title":"<code>from_df(df, timing_conversion=None)</code>  <code>classmethod</code>","text":"<p>Create a Timeline object from a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>dataframe to initialise the timeline. Must have columns 'group', 'name', optional column 'description'. Either column 'duration_frames' or duration column in any other unit and a timing_conversion dictionary to transform it to frames. For example if column 'duration_seconds' is present, the timing_conversion dictionary should be {'frames': 30, 'seconds': 1} if the recording was at 30 frames per second.</p> required <code>timing_conversion</code> <code>Optional[dict]</code> <p>a dictionary to convert the timing into a different unit. For example, if you want to convert the timing from frames to seconds, and you were recording at 30 frames per second, you can use timing_conversion = {'frames': 1, 'seconds': 1/30} You can list multiple units in the dictionary, and the timing will be converted to all of them, for example if there are also 10 frames per volume, you can use: timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10} You must include 'frames' in the dictionary! The value of frames does not have to be 1, but it must be consistent with the other units. the rest of the values. for example this is valid for the example above: timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}. If timing_conversion is None, then the timing is not converted and 'duration_frames' must be provided in the dataframe.</p> <code>None</code> <p>Returns:</p> Type Description <code>Timeline</code> <p>a Timeline object with labels and duration initialised from 'group', 'name', 'description' and     duration fields of the dataframe. In the order in which they appear in the dataframe.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_df(cls, df: pd.DataFrame, timing_conversion: Optional[dict] = None):\n    \"\"\"\n    Create a Timeline object from a dataframe.\n\n    Args:\n        df : dataframe to initialise the timeline.\n            Must have columns 'group', 'name', optional column 'description'.\n            Either column 'duration_frames' or duration column in any other unit\n            and a timing_conversion dictionary to transform it to frames.\n            For example if column 'duration_seconds' is present,\n            the timing_conversion dictionary should be\n            {'frames': 30, 'seconds': 1} if the recording was at 30 frames per second.\n        timing_conversion: a dictionary to convert the timing into a different unit.\n            For example, if you want to convert the timing from frames to seconds,\n            and you were recording at 30 frames per second, you can use\n            timing_conversion = {'frames': 1, 'seconds': 1/30}\n            You can list multiple units in the dictionary, and the timing will be converted to all of them,\n            for example if there are also 10 frames per volume, you can use:\n            timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n            You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n            but it must be consistent with the other units. the rest of the values.\n            for example this is valid for the example above:\n            timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n            If timing_conversion is None, then the timing is not converted\n            and 'duration_frames' must be provided in the dataframe.\n\n    Returns:\n        (Timeline): a Timeline object with labels and duration initialised from 'group', 'name', 'description' and\n                duration fields of the dataframe. In the order in which they appear in the dataframe.\n    \"\"\"\n    label_order = []\n    for _, row in df.iterrows():\n        label_order.append(TimeLabel(row['name'],\n                                     group=row['group'],\n                                     description=row.get('description')\n                                     )\n                           )\n    if 'duration_frames' in df.columns:\n        duration_frames = df['duration_frames'].values\n    else:\n        assert timing_conversion is not None, \"if duration_frames is not in the dataframe, \" \\\n                                              \"timing_conversion must be provided\"\n        # check that timing_conversion is a dictionary\n        assert isinstance(timing_conversion, dict), \"timing_conversion must be a dictionary\"\n        # check that frames are present in the timing_conversion dictionary\n        assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n        # list units that are present in both dataframe and timing_conversion dictionary\n        unit_list = [unit for unit in timing_conversion.keys() if 'duration_' + unit in df.columns]\n        # check that at least one unit from the timing_conversion dictionary is present in the dataframe\n        assert len(unit_list) &gt; 0, \"timing_conversion dictionary must have at least one \" \\\n                                   \"of the following keys in addition to 'frames': \" + \\\n                                   \", \".join([col_name.split('_')[1] for col_name in\n                                              set(df.columns) - {'name', 'group', 'description'}])\n        unit = unit_list[0]\n        duration_frames = df['duration_' + unit].values * timing_conversion['frames'] / timing_conversion[unit]\n        # if all values in duration are integer, convert to int, else raise an assertion\n        if all(d.is_integer() for d in duration_frames):\n            duration_frames = duration_frames.astype(int)\n        else:\n            assert False, \"duration in frames must be integer after conversion from \" + unit\n\n    return cls(label_order, duration_frames)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Timeline object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary to initialize the timeline.</p> required <p>Returns:</p> Type Description <code>Timeline</code> <p>a Timeline object with label_order and duration initialized from 'label_order' and     'timing' fields of the dictionary.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a Timeline object from a dictionary.\n\n    Args:\n        d: dictionary to initialize the timeline.\n\n    Returns:\n        (Timeline): a Timeline object with label_order and duration initialized from 'label_order' and\n                'timing' fields of the dictionary.\n    \"\"\"\n    label_order = [TimeLabel.from_dict(ld) for ld in d['label_order']]\n    return cls(label_order, d['timing'])\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.from_json","title":"<code>from_json(j)</code>  <code>classmethod</code>","text":"<p>Create a Timeline object from a json string.</p> <p>Parameters:</p> Name Type Description Default <code>j</code> <p>json string to initialise the cycle</p> required <p>Returns:</p> Type Description <code>Timeline</code> <p>a Timeline object with label_order and duration initialised from 'label_order' and     'timing' fields of the json srting.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>@classmethod\ndef from_json(cls, j: str):\n    \"\"\"\n    Create a Timeline object from a json string.\n\n    Args:\n        j : json string to initialise the cycle\n\n    Returns:\n        (Timeline): a Timeline object with label_order and duration initialised from 'label_order' and\n                'timing' fields of the json srting.\n    \"\"\"\n    d = json.loads(j)\n    return cls.from_dict(d)\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.get_label_per_frame","title":"<code>get_label_per_frame()</code>","text":"<p>A list of labels per frame for the duration of the experiment.</p> <p>Returns:</p> Type Description <code>List[TimeLabel]</code> <p>labels per frame for the experiment.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def get_label_per_frame(self) -&gt; List[TimeLabel]:\n    \"\"\"\n    A list of labels per frame for the duration of the experiment.\n\n    Returns:\n        labels per frame for the experiment.\n    \"\"\"\n    per_frame_label_list = []\n    for (label_time, label) in zip(self.duration, self.label_order):\n        per_frame_label_list.extend(label_time * [label])\n    return per_frame_label_list\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.to_df","title":"<code>to_df(timing_conversion=None)</code>","text":"<p>Put all the information about a Timeline object into a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>timing_conversion</code> <code>Optional[dict]</code> <p>a dictionary to convert the timing into a different unit. For example, if you want to convert the timing from frames to seconds, and you were recording at 30 frames per second, you can use timing_conversion = {'frames': 1, 'seconds': 1/30} You can list multiple units in the dictionary, and the timing will be converted to all of them, for example if there are also 10 frames per volume, you can use: timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10} You must include 'frames' in the dictionary! The value of frames does not have to be 1, but it must be consistent with the other units. the rest of the values. for example this is valid for the example above: timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}. if timing_conversion is None, then the timing is not converted. if timing_conversion is not None, then the timing is converted and both the original and converted timing are added to the dataframe.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a dataframe with columns 'timing', 'group', 'name' and 'description'.</p> <code>DataFrame</code> <p>'timing' will be written in all the units in the timing_conversion dictionary,</p> <code>DataFrame</code> <p>or just in frames, if timing_conversion is None.</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_df(self, timing_conversion: Optional[dict] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Put all the information about a Timeline object into a dataframe.\n\n    Args:\n        timing_conversion: a dictionary to convert the timing into a different unit.\n            For example, if you want to convert the timing from frames to seconds,\n            and you were recording at 30 frames per second, you can use\n            timing_conversion = {'frames': 1, 'seconds': 1/30}\n            You can list multiple units in the dictionary, and the timing will be converted to all of them,\n            for example if there are also 10 frames per volume, you can use:\n            timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n            You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n            but it must be consistent with the other units. the rest of the values.\n            for example this is valid for the example above:\n            timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n            if timing_conversion is None, then the timing is not converted.\n            if timing_conversion is not None, then the timing is converted and both the original and converted\n            timing are added to the dataframe.\n\n    Returns:\n        a dataframe with columns 'timing', 'group', 'name' and 'description'.\n        'timing' will be written in all the units in the timing_conversion dictionary,\n        or just in frames, if timing_conversion is None.\n    \"\"\"\n    # prepare timing columns\n    if timing_conversion is None:\n        timing_conversion = {'frames': 1}\n    assert 'frames' in timing_conversion.keys(), \"frames must be in the timing_conversion dictionary\"\n\n    timing_columns = ['duration_' + unit for unit in timing_conversion.keys()]\n    df = pd.DataFrame(columns=timing_columns + ['name', 'group', 'description'])\n\n    # write timing columns\n    for unit in timing_conversion.keys():\n        frames_per_unit = timing_conversion['frames'] / timing_conversion[unit]\n        duration = np.array(self.duration) / frames_per_unit\n        # if all are integers, turn to integer\n        if all(d.is_integer() for d in duration):\n            duration = duration.astype(int)\n        df['duration_' + unit] = duration\n\n    # write labels\n    df['name'] = [label.name for label in self.label_order]\n    df['group'] = [label.group for label in self.label_order]\n    df['description'] = [label.description for label in self.label_order]\n    return df\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.to_dict","title":"<code>to_dict()</code>","text":"<p>Put all the information about a Timeline object into a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>a dictionary with fields 'label_order' and 'timing' .</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Put all the information about a Timeline object into a dictionary.\n\n    Returns:\n        a dictionary with fields 'label_order' and 'timing' .\n    \"\"\"\n    return {'timing': self.duration,\n            'label_order': [label.to_dict() for label in self.label_order],\n            }\n</code></pre>"},{"location":"api/annotation/#src.vodex.annotation.Timeline.to_json","title":"<code>to_json()</code>","text":"<p>Put all the information about a Timeline object into a json string.</p> <p>Returns:</p> Type Description <code>str</code> <p>a json string with fields 'label_order' and 'timing' .</p> Source code in <code>src/vodex/annotation.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Put all the information about a Timeline object into a json string.\n\n    Returns:\n        a json string with fields 'label_order' and 'timing' .\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/core/","title":"vodex.core","text":"<p>This module provides the core classes for loading and preprocessing imaging data.</p> <p>'ImageLoader' is the core class that loads the image data and selects the appropriate loader based on the file type. It also collects information about the data type and number of frames per file.</p> <p>'FileManager', 'FrameManager', and 'VolumeManager' are core classes that preprocess information about the experiment data. The 'FileManager' class contains information about the location and file type of the image files, while the 'FrameManager' class contains information about the number of frames in the experiment and the mapping of frames to files. The 'VolumeManager' class contains information about the image volumes in the experiment, including the number of frames per volume and the mapping of frames to volumes.</p>"},{"location":"api/core/#src.vodex.core.FileManager","title":"<code>FileManager</code>","text":"<p>The 'FileManager' class is used to collect and store information about image files, including their location, file type, and number of frames per file. It can either search for all files with a specific file extension in a provided data directory (order them alphabetically), or use a provided list of file names (in the provided order). The class initializes an 'ImageLoader' to calculate the number of frames per file if it is not provided.</p> <p>The class raises an error if the data directory does not exist, no files of the specified file type are found, or if the number of frames per file is not provided or is not a list of integers.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>Union[str, Path]</code> <p>path to the folder with the files, ends with \"/\" or \"\\\"</p> required <code>file_names</code> <code>List[str]</code> <p>names of files relative to the data_dir</p> <code>None</code> <code>frames_per_file</code> <code>List[int]</code> <p>number of frames in each file. Will be used ONLY if the file_names were provided.</p> <code>None</code> <code>file_type</code> <code>str</code> <p>file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.</p> <code>'TIFF'</code> <p>Attributes:</p> Name Type Description <code>data_dir</code> <code>Path</code> <p>the directory with all the imaging data</p> <code>file_names</code> <code>List[str]</code> <p>names of files relative to the data_dir</p> <code>num_frames</code> <p>a number of frames per file</p> <code>n_files</code> <code>int</code> <p>total number of image files</p> Source code in <code>src/vodex/core.py</code> <pre><code>class FileManager:\n    \"\"\"\n    The 'FileManager' class is used to collect and store information about image files, including their location,\n    file type, and number of frames per file. It can either search for all files with a specific file extension in a\n    provided data directory (order them alphabetically), or use a provided list of file names (in the provided order).\n    The class initializes an 'ImageLoader' to calculate the number of frames per file if it is not provided.\n\n    The class raises an error if the data directory does not exist, no files of the specified file type are found,\n    or if the number of frames per file is not provided or is not a list of integers.\n\n    Args:\n        data_dir: path to the folder with the files, ends with \"/\" or \"\\\\\"\n        file_names: names of files relative to the data_dir\n        frames_per_file: number of frames in each file. Will be used ONLY if the file_names were provided.\n        file_type: file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.\n\n    Attributes:\n        data_dir: the directory with all the imaging data\n        file_names: names of files relative to the data_dir\n        num_frames: a number of frames per file\n        n_files: total number of image files\n    \"\"\"\n\n    def __init__(self, data_dir: Union[str, Path], file_type: str = \"TIFF\",\n                 file_names: List[str] = None, frames_per_file: List[int] = None):\n\n        # 1. get data_dir and check it exists\n        self.data_dir: Path = Path(data_dir)\n        assert self.data_dir.is_dir(), f\"No directory {self.data_dir}\"\n\n        # 2. get files and file type\n        if file_names is not None:\n            tags = [name.split(\".\")[-1] for name in file_names]\n            # check that all the elements of the list are same\n            assert len(set(tags)) == 1, f\"File_names must be files with the same extension, \" \\\n                                        f\"but got {', '.join(sorted(set(tags)))}\"\n            assert tags[0] in VX_EXTENSION_TO_TYPE, f'Extension \"{tags[0]}\" is not supported.'\n            file_type = VX_EXTENSION_TO_TYPE[tags[0]]\n\n        self.file_type = file_type\n        assert self.file_type in VX_SUPPORTED_TYPES, f'File type \"{self.file_type}\" is not supported.'\n        file_extensions = VX_SUPPORTED_TYPES[self.file_type]\n\n        self.num_frames = None\n        # TODO : check in accordance with the file extension/ figure out file type from files when provided\n        if file_names is None:\n            # if files are not provided , search for tiffs in the data_dir\n            self.file_names: List[str] = self.find_files(file_extensions)\n        else:\n            # if a list of files is provided, check it's in the folder\n            self.file_names: List[str] = self.check_files(file_names)\n            if frames_per_file is not None:\n                # not recommended! this information is taken as is and is not verified...\n                self.num_frames: List[int] = frames_per_file\n\n        assert len(self.file_names) &gt; 0, f\"No files of type {file_type} [extensions {file_extensions}]\\n\" \\\n                                         f\" in {data_dir}\"\n\n        # 3. Get number of frames per file (if it wasn't entered manually)\n        if self.num_frames is None:\n            # if number of frames not provided , search for tiffs in the data_dir\n            self.num_frames: List[int] = self.get_frames_per_file()\n\n        self.n_files: int = len(self.file_names)\n\n    def __eq__(self, other):\n        \"\"\"\n        Compares two FileManager instances to see if they are equal.\n        \"\"\"\n        if isinstance(other, FileManager):\n            is_same = [\n                self.data_dir == other.data_dir,\n                self.file_names == other.file_names,\n                self.num_frames == other.num_frames,\n                self.n_files == other.n_files\n            ]\n\n            return np.all(is_same)\n        else:\n            print(f\"__eq__ is Not Implemented for {FileManager} and {type(other)}\")\n            return NotImplemented\n\n    def __str__(self):\n        description = f\"Image files information :\\n\\n\"\n        description = description + f\"files directory: {self.data_dir}\\n\"\n        description = description + f\"files [number of frames]: \\n\"\n        for (i_file, (file_name, num_frames)) in enumerate(zip(self.file_names, self.num_frames)):\n            description = description + f\"{i_file}) {file_name} [{num_frames}]\\n\"\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n\n    def find_files(self, file_extensions: Tuple[str]) -&gt; List[str]:\n        \"\"\"\n        Searches for files ending with the provided file extension in the data directory.\n        Sorts the names alphabetically in ascending order (from A to Z),\n        sorting is case-insensitive (upper case letters are NOT prioritized).\n\n        Args:\n            file_extensions: extensions of files to search for\n        Returns:\n            A sorted list of file names. File names are with the extension, relative to the data directory\n            (names only, not full paths to files)\n        \"\"\"\n        files = (p.resolve() for p in Path(self.data_dir).glob('*') if p.suffix in file_extensions)\n        file_names = [file.name for file in files]\n        file_names.sort(key=str.lower)\n        return file_names\n\n    def check_files(self, file_names: List[str]) -&gt; List[str]:\n        \"\"\"\n        Given a list of files checks that files are in the data directory.\n        Throws an error if any of the files are missing.\n\n        Args:\n            file_names: list of filenames to check.\n\n        Returns:\n            If the files are all present in the directory, returns the file_names.\n        \"\"\"\n        # TODO: List all the missing files, not just the first encountered.\n        files = [self.data_dir.joinpath(file) for file in file_names]\n        for file in files:\n            assert file.is_file(), f\"File {file} is not found\"\n        return file_names\n\n    def get_frames_per_file(self) -&gt; List[int]:\n        \"\"\"\n        Get the number of frames per file.\n\n        Returns:\n            a list with number of frames per file.\n        \"\"\"\n        frames_per_file = []\n        #    Initialise ImageLoader:\n        #    will pick the image loader that works with the provided file type\n        loader: ImageLoader = ImageLoader(self.data_dir.joinpath(self.file_names[0]))\n        for file in self.file_names:\n            n_frames = loader.get_frames_in_file(self.data_dir.joinpath(file))\n            frames_per_file.append(n_frames)\n        return frames_per_file\n\n    def change_files_order(self, order: List[int]) -&gt; None:\n        \"\"\"\n        Changes the order of the files. If you notice that files are in the wrong order, provide the new order.\n        If you wish to exclude any files, get rid of them ( don't include their IDs into the new order ).\n\n        Args:\n            order: The new order in which the files follow. Refer to file by it's position in the original list.\n                    Should be the same length as the number of files in the original list or smaller, no duplicates.\n        \"\"\"\n        assert len(order) &lt;= self.n_files, \\\n            \"Number of files is smaller than elements in the new order list! \"\n        assert len(order) == len(set(order)), \\\n            \"All elements in the new order list must be unique! \"\n        assert set(order).issubset(list(range(self.n_files))), \\\n            f\"All elements in the new order list must be present in the original order: {list(range(self.n_files))}! \"\n\n        self.file_names = [self.file_names[i] for i in order]\n        self.num_frames = [self.num_frames[i] for i in order]\n        self.n_files = len(self.file_names)\n</code></pre>"},{"location":"api/core/#src.vodex.core.FileManager.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two FileManager instances to see if they are equal.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compares two FileManager instances to see if they are equal.\n    \"\"\"\n    if isinstance(other, FileManager):\n        is_same = [\n            self.data_dir == other.data_dir,\n            self.file_names == other.file_names,\n            self.num_frames == other.num_frames,\n            self.n_files == other.n_files\n        ]\n\n        return np.all(is_same)\n    else:\n        print(f\"__eq__ is Not Implemented for {FileManager} and {type(other)}\")\n        return NotImplemented\n</code></pre>"},{"location":"api/core/#src.vodex.core.FileManager.change_files_order","title":"<code>change_files_order(order)</code>","text":"<p>Changes the order of the files. If you notice that files are in the wrong order, provide the new order. If you wish to exclude any files, get rid of them ( don't include their IDs into the new order ).</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>List[int]</code> <p>The new order in which the files follow. Refer to file by it's position in the original list.     Should be the same length as the number of files in the original list or smaller, no duplicates.</p> required Source code in <code>src/vodex/core.py</code> <pre><code>def change_files_order(self, order: List[int]) -&gt; None:\n    \"\"\"\n    Changes the order of the files. If you notice that files are in the wrong order, provide the new order.\n    If you wish to exclude any files, get rid of them ( don't include their IDs into the new order ).\n\n    Args:\n        order: The new order in which the files follow. Refer to file by it's position in the original list.\n                Should be the same length as the number of files in the original list or smaller, no duplicates.\n    \"\"\"\n    assert len(order) &lt;= self.n_files, \\\n        \"Number of files is smaller than elements in the new order list! \"\n    assert len(order) == len(set(order)), \\\n        \"All elements in the new order list must be unique! \"\n    assert set(order).issubset(list(range(self.n_files))), \\\n        f\"All elements in the new order list must be present in the original order: {list(range(self.n_files))}! \"\n\n    self.file_names = [self.file_names[i] for i in order]\n    self.num_frames = [self.num_frames[i] for i in order]\n    self.n_files = len(self.file_names)\n</code></pre>"},{"location":"api/core/#src.vodex.core.FileManager.check_files","title":"<code>check_files(file_names)</code>","text":"<p>Given a list of files checks that files are in the data directory. Throws an error if any of the files are missing.</p> <p>Parameters:</p> Name Type Description Default <code>file_names</code> <code>List[str]</code> <p>list of filenames to check.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>If the files are all present in the directory, returns the file_names.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def check_files(self, file_names: List[str]) -&gt; List[str]:\n    \"\"\"\n    Given a list of files checks that files are in the data directory.\n    Throws an error if any of the files are missing.\n\n    Args:\n        file_names: list of filenames to check.\n\n    Returns:\n        If the files are all present in the directory, returns the file_names.\n    \"\"\"\n    # TODO: List all the missing files, not just the first encountered.\n    files = [self.data_dir.joinpath(file) for file in file_names]\n    for file in files:\n        assert file.is_file(), f\"File {file} is not found\"\n    return file_names\n</code></pre>"},{"location":"api/core/#src.vodex.core.FileManager.find_files","title":"<code>find_files(file_extensions)</code>","text":"<p>Searches for files ending with the provided file extension in the data directory. Sorts the names alphabetically in ascending order (from A to Z), sorting is case-insensitive (upper case letters are NOT prioritized).</p> <p>Parameters:</p> Name Type Description Default <code>file_extensions</code> <code>Tuple[str]</code> <p>extensions of files to search for</p> required <p>Returns:     A sorted list of file names. File names are with the extension, relative to the data directory     (names only, not full paths to files)</p> Source code in <code>src/vodex/core.py</code> <pre><code>def find_files(self, file_extensions: Tuple[str]) -&gt; List[str]:\n    \"\"\"\n    Searches for files ending with the provided file extension in the data directory.\n    Sorts the names alphabetically in ascending order (from A to Z),\n    sorting is case-insensitive (upper case letters are NOT prioritized).\n\n    Args:\n        file_extensions: extensions of files to search for\n    Returns:\n        A sorted list of file names. File names are with the extension, relative to the data directory\n        (names only, not full paths to files)\n    \"\"\"\n    files = (p.resolve() for p in Path(self.data_dir).glob('*') if p.suffix in file_extensions)\n    file_names = [file.name for file in files]\n    file_names.sort(key=str.lower)\n    return file_names\n</code></pre>"},{"location":"api/core/#src.vodex.core.FileManager.get_frames_per_file","title":"<code>get_frames_per_file()</code>","text":"<p>Get the number of frames per file.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>a list with number of frames per file.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def get_frames_per_file(self) -&gt; List[int]:\n    \"\"\"\n    Get the number of frames per file.\n\n    Returns:\n        a list with number of frames per file.\n    \"\"\"\n    frames_per_file = []\n    #    Initialise ImageLoader:\n    #    will pick the image loader that works with the provided file type\n    loader: ImageLoader = ImageLoader(self.data_dir.joinpath(self.file_names[0]))\n    for file in self.file_names:\n        n_frames = loader.get_frames_in_file(self.data_dir.joinpath(file))\n        frames_per_file.append(n_frames)\n    return frames_per_file\n</code></pre>"},{"location":"api/core/#src.vodex.core.FrameManager","title":"<code>FrameManager</code>","text":"<p>A class containing information about the image frames in the experiment: total number of frames, and mapping of the frames to files.</p> <p>Parameters:</p> Name Type Description Default <code>file_manager</code> <code>FileManager</code> <p>FileManager with the information about the files.</p> required <p>Attributes:</p> Name Type Description <code>file_manager</code> <code>FileManager</code> <p>FileManager with the information about the files.</p> <code>n_frames</code> <code>int</code> <p>total number of frames in the experiment (global frames).</p> <code>frame_to_file</code> <code>List[int]</code> <p>a mapping for each global frame to a file where the frame is stored</p> <code>frame_in_file</code> <code>List[int]</code> <p>a mapping for each global frame to a frame number relative to the beginning of the             corresponding file</p> Source code in <code>src/vodex/core.py</code> <pre><code>class FrameManager:\n    \"\"\"\n    A class containing information about the image frames in the experiment:\n    total number of frames, and mapping of the frames to files.\n\n    Args:\n        file_manager: FileManager with the information about the files.\n\n    Attributes:\n        file_manager: FileManager with the information about the files.\n        n_frames: total number of frames in the experiment (global frames).\n        frame_to_file: a mapping for each global frame to a file where the frame is stored\n        frame_in_file: a mapping for each global frame to a frame number relative to the beginning of the\n                        corresponding file\n    \"\"\"\n\n    def __init__(self, file_manager: FileManager):\n        self.file_manager: FileManager = file_manager\n        self.n_frames: int = int(np.sum(self.file_manager.num_frames))\n        self.frame_to_file: List[int]\n        self.frame_in_file: List[int]\n        self.frame_to_file, self.frame_in_file = self._get_frame_mapping()\n\n    def __eq__(self, other):\n        if isinstance(other, FrameManager):\n            is_same = [\n                self.file_manager == other.file_manager,\n                self.frame_to_file == other.frame_to_file,\n                self.frame_in_file == other.frame_in_file\n            ]\n\n            return np.all(is_same)\n        else:\n            print(f\"__eq__ is Not Implemented for {FrameManager} and {type(other)}\")\n            return NotImplemented\n\n    @classmethod\n    def from_dir(cls, data_dir: Union[Path, str], file_type: str = \"TIFF\",\n                 file_names: List[str] = None, frames_per_file: List[int] = None):\n        \"\"\"\n        Create a FrameManager object from files in directory.\n\n        Args:\n            data_dir: path to the folder with the files, ends with \"/\" or \"\\\\\"\n            file_type: file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.\n            file_names: names of files relative to the data_dir\n            frames_per_file: number of frames in each file. Will be used ONLY if the file_names were provided.\n\n        Returns:\n            (FileManager): Initialised FileManager object.\n        \"\"\"\n        file_manager = FileManager(data_dir, file_type=file_type,\n                                   file_names=file_names, frames_per_file=frames_per_file)\n        return cls(file_manager)\n\n    def _get_frame_mapping(self) -&gt; (List[int], List[int]):\n        \"\"\"\n        Calculates frame range in each file and returns a file index for each frame and frame index in the file.\n        Used to figure out in which stack the requested frames is.\n        Frame number starts at 0.\n\n        Returns:\n            Two lists mapping frames to files. 'frame_to_file' is a list of length equal to the total number of\n            frames in all the files, where each element corresponds to a frame and contains the file index,\n            of the file where that frame can be found. 'in_file_frame' is a list of length equal to the total number of\n            frames in all the files, where each element corresponds to the index of the frame inside the file.\n        \"\"\"\n        frame_to_file = []\n        frame_in_file = []\n\n        for file_idx in range(self.file_manager.n_files):\n            n_frames = self.file_manager.num_frames[file_idx]\n            frame_to_file.extend(n_frames * [file_idx])\n            frame_in_file.extend(range(n_frames))\n\n        return frame_to_file, frame_in_file\n\n    def __str__(self):\n        return f\"Total {np.sum(self.file_manager.num_frames)} frames.\"\n\n    def __repr__(self):\n        return self.__str__()\n</code></pre>"},{"location":"api/core/#src.vodex.core.FrameManager.from_dir","title":"<code>from_dir(data_dir, file_type='TIFF', file_names=None, frames_per_file=None)</code>  <code>classmethod</code>","text":"<p>Create a FrameManager object from files in directory.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>Union[Path, str]</code> <p>path to the folder with the files, ends with \"/\" or \"\\\"</p> required <code>file_type</code> <code>str</code> <p>file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.</p> <code>'TIFF'</code> <code>file_names</code> <code>List[str]</code> <p>names of files relative to the data_dir</p> <code>None</code> <code>frames_per_file</code> <code>List[int]</code> <p>number of frames in each file. Will be used ONLY if the file_names were provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>FileManager</code> <p>Initialised FileManager object.</p> Source code in <code>src/vodex/core.py</code> <pre><code>@classmethod\ndef from_dir(cls, data_dir: Union[Path, str], file_type: str = \"TIFF\",\n             file_names: List[str] = None, frames_per_file: List[int] = None):\n    \"\"\"\n    Create a FrameManager object from files in directory.\n\n    Args:\n        data_dir: path to the folder with the files, ends with \"/\" or \"\\\\\"\n        file_type: file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.\n        file_names: names of files relative to the data_dir\n        frames_per_file: number of frames in each file. Will be used ONLY if the file_names were provided.\n\n    Returns:\n        (FileManager): Initialised FileManager object.\n    \"\"\"\n    file_manager = FileManager(data_dir, file_type=file_type,\n                               file_names=file_names, frames_per_file=frames_per_file)\n    return cls(file_manager)\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader","title":"<code>ImageLoader</code>","text":"<p>The 'ImageLoader' class is responsible for choosing the appropriate loader for a given imaging file, collecting information about the data type, number of frames per file, and loading data from files.</p> <p>Parameters:</p> Name Type Description Default <code>file_example</code> <p>The path to a file example (one file from the whole dataset).         This is used to determine the file type and initialize the corresponding data loader.</p> required <p>Attributes:</p> Name Type Description <code>supported_extensions</code> <code>List[str]</code> <p>A list of all the supported file extensions.</p> <code>file_extension</code> <code>str</code> <p>The file extension of the provided file example.</p> <code>loader</code> <code>Loader</code> <p>The loader class initialized using the file example.</p> Source code in <code>src/vodex/core.py</code> <pre><code>class ImageLoader:\n    \"\"\"\n    The 'ImageLoader' class is responsible for choosing the appropriate loader for a given imaging file, collecting\n    information about the data type, number of frames per file, and loading data from files.\n\n    Args:\n        file_example : The path to a file example (one file from the whole dataset).\n                    This is used to determine the file type and initialize the corresponding data loader.\n\n    Attributes:\n        supported_extensions: A list of all the supported file extensions.\n        file_extension: The file extension of the provided file example.\n        loader:  The loader class initialized using the file example.\n\n    \"\"\"\n\n    def __init__(self, file_example: Path):\n        \"\"\"\n        Initializes the ImageLoader class by determining the file extension, checking that it is a supported format,\n        and initializing the appropriate loader class.\n        \"\"\"\n\n        self.supported_extensions: List[str] = list(VX_EXTENSION_TO_LOADER.keys())\n        # suffix has the dot at the beginning, need to strip\n        self.file_extension: str = file_example.suffix.lstrip('.')\n        assert self.file_extension in self.supported_extensions, \\\n            f\"Only files with the following extensions are supported: {self.supported_extensions}, but\" \\\n            f\"{self.file_extension} was given\"\n\n        # Pick the loader and initialise it with the data directory:\n        # chooses the proper loader based on the file extension.\n        # Add your class to VX_EXTENSION_TO_LOADER when adding support to other file formats.\n        self.loader: Loader = VX_EXTENSION_TO_LOADER[self.file_extension](file_example)\n\n    def __eq__(self, other):\n        \"\"\"\n        Compares two ImageLoader instances to see if they are equal.\n        \"\"\"\n        if isinstance(other, ImageLoader):\n            is_same = [\n                self.supported_extensions == other.supported_extensions,\n                self.file_extension == other.file_extension,\n                self.loader == other.loader\n            ]\n            return np.all(is_same)\n        else:\n            print(f\"__eq__ is Not Implemented for {ImageLoader} and {type(other)}\")\n            return NotImplemented\n\n    def get_frames_in_file(self, file_name: Union[str, Path]) -&gt; int:\n        \"\"\"\n        Calculates and returns the number of frames in a given file.\n\n        Args:\n            file_name: the name of the file to get the number of frames for.\n\n        Returns:\n            the number of frames in the file.\n        \"\"\"\n        return self.loader.get_frames_in_file(file_name)\n\n    def get_frame_size(self, file_name: Union[str, Path]) -&gt; Tuple[int, int]:\n        \"\"\"\n        Returns the size of an individual frame in pixels (height and width).\n\n        Args:\n            file_name: the path to the file to get the size of the frame for.\n        Returns:\n            ( height , width ) height and width of an individual frame in pixels.\n        \"\"\"\n        return self.loader.get_frame_size(file_name)\n\n    def load_frames(self, frames: List[int], files: Union[List[str], List[Path]],\n                    show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n        \"\"\"\n         Loads specified frames from specified files, and returns as a 3D array of shape (n_frames, height, width).\n\n        Args:\n            frames: list of frames IN FILES to load.\n            files: a file for every frame\n            show_file_names: whether to print the names of the files from which the frames are loaded.\n                Setting it to True will turn off show_progress.\n            show_progress: whether to show the progress bar of how many frames have been loaded.\n                Won't have effect of show_file_names is True.\n        Returns:\n            3D array of shape (n_frames, height, width)\n        \"\"\"\n        return self.loader.load_frames(frames, files,\n                                       show_file_names=show_file_names,\n                                       show_progress=show_progress)\n\n    def load_volumes(self,\n                     frame_in_file: List[int],\n                     files: Union[List[str], List[Path]],\n                     volumes: List[int],\n                     show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n        \"\"\"\n         Loads specific volumes of data, where a volume is defined as a set of frames.\n         This method returns a 4D array of shape (n_volumes, n_frames_per_volume, height, width).\n\n        Args:\n            frame_in_file: list of frames IN FILES to load\n                (relative to the beginning of the file from which you are loading).\n            files: a file for every frame\n            volumes: a volume for every frame where that frame belongs\n            show_file_names: whether to print the names of the files from which the frames are loaded.\n                                Setting it to True will turn off show_progress.\n            show_progress: whether to show the progress bar of how many frames have been loaded.\n                Won't have effect of show_file_names is True.\n        Returns:\n            4D array of shape (number of volumes, zslices, height, width)\n        \"\"\"\n        # get frames and info\n        frames = self.loader.load_frames(frame_in_file, files,\n                                         show_file_names=show_file_names,\n                                         show_progress=show_progress)\n        n_frames, w, h = frames.shape\n\n        # get volume information\n        i_volume, count = np.unique(volumes, return_counts=True)\n        # you can use this method to load portions of the volumes (slices), so fpv will be smaller than a full volume\n        n_volumes, fpv = len(i_volume), count[0]\n        assert np.all(count == fpv), \"Can't have different number of frames per volume!\"\n\n        frames = frames.reshape((n_volumes, fpv, w, h))\n        return frames\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two ImageLoader instances to see if they are equal.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compares two ImageLoader instances to see if they are equal.\n    \"\"\"\n    if isinstance(other, ImageLoader):\n        is_same = [\n            self.supported_extensions == other.supported_extensions,\n            self.file_extension == other.file_extension,\n            self.loader == other.loader\n        ]\n        return np.all(is_same)\n    else:\n        print(f\"__eq__ is Not Implemented for {ImageLoader} and {type(other)}\")\n        return NotImplemented\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader.__init__","title":"<code>__init__(file_example)</code>","text":"<p>Initializes the ImageLoader class by determining the file extension, checking that it is a supported format, and initializing the appropriate loader class.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def __init__(self, file_example: Path):\n    \"\"\"\n    Initializes the ImageLoader class by determining the file extension, checking that it is a supported format,\n    and initializing the appropriate loader class.\n    \"\"\"\n\n    self.supported_extensions: List[str] = list(VX_EXTENSION_TO_LOADER.keys())\n    # suffix has the dot at the beginning, need to strip\n    self.file_extension: str = file_example.suffix.lstrip('.')\n    assert self.file_extension in self.supported_extensions, \\\n        f\"Only files with the following extensions are supported: {self.supported_extensions}, but\" \\\n        f\"{self.file_extension} was given\"\n\n    # Pick the loader and initialise it with the data directory:\n    # chooses the proper loader based on the file extension.\n    # Add your class to VX_EXTENSION_TO_LOADER when adding support to other file formats.\n    self.loader: Loader = VX_EXTENSION_TO_LOADER[self.file_extension](file_example)\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader.get_frame_size","title":"<code>get_frame_size(file_name)</code>","text":"<p>Returns the size of an individual frame in pixels (height and width).</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>the path to the file to get the size of the frame for.</p> required <p>Returns:     ( height , width ) height and width of an individual frame in pixels.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def get_frame_size(self, file_name: Union[str, Path]) -&gt; Tuple[int, int]:\n    \"\"\"\n    Returns the size of an individual frame in pixels (height and width).\n\n    Args:\n        file_name: the path to the file to get the size of the frame for.\n    Returns:\n        ( height , width ) height and width of an individual frame in pixels.\n    \"\"\"\n    return self.loader.get_frame_size(file_name)\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader.get_frames_in_file","title":"<code>get_frames_in_file(file_name)</code>","text":"<p>Calculates and returns the number of frames in a given file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, Path]</code> <p>the name of the file to get the number of frames for.</p> required <p>Returns:</p> Type Description <code>int</code> <p>the number of frames in the file.</p> Source code in <code>src/vodex/core.py</code> <pre><code>def get_frames_in_file(self, file_name: Union[str, Path]) -&gt; int:\n    \"\"\"\n    Calculates and returns the number of frames in a given file.\n\n    Args:\n        file_name: the name of the file to get the number of frames for.\n\n    Returns:\n        the number of frames in the file.\n    \"\"\"\n    return self.loader.get_frames_in_file(file_name)\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader.load_frames","title":"<code>load_frames(frames, files, show_file_names=False, show_progress=True)</code>","text":"<p>Loads specified frames from specified files, and returns as a 3D array of shape (n_frames, height, width).</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>List[int]</code> <p>list of frames IN FILES to load.</p> required <code>files</code> <code>Union[List[str], List[Path]]</code> <p>a file for every frame</p> required <code>show_file_names</code> <code>bool</code> <p>whether to print the names of the files from which the frames are loaded. Setting it to True will turn off show_progress.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>whether to show the progress bar of how many frames have been loaded. Won't have effect of show_file_names is True.</p> <code>True</code> <p>Returns:     3D array of shape (n_frames, height, width)</p> Source code in <code>src/vodex/core.py</code> <pre><code>def load_frames(self, frames: List[int], files: Union[List[str], List[Path]],\n                show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n    \"\"\"\n     Loads specified frames from specified files, and returns as a 3D array of shape (n_frames, height, width).\n\n    Args:\n        frames: list of frames IN FILES to load.\n        files: a file for every frame\n        show_file_names: whether to print the names of the files from which the frames are loaded.\n            Setting it to True will turn off show_progress.\n        show_progress: whether to show the progress bar of how many frames have been loaded.\n            Won't have effect of show_file_names is True.\n    Returns:\n        3D array of shape (n_frames, height, width)\n    \"\"\"\n    return self.loader.load_frames(frames, files,\n                                   show_file_names=show_file_names,\n                                   show_progress=show_progress)\n</code></pre>"},{"location":"api/core/#src.vodex.core.ImageLoader.load_volumes","title":"<code>load_volumes(frame_in_file, files, volumes, show_file_names=False, show_progress=True)</code>","text":"<p>Loads specific volumes of data, where a volume is defined as a set of frames.  This method returns a 4D array of shape (n_volumes, n_frames_per_volume, height, width).</p> <p>Parameters:</p> Name Type Description Default <code>frame_in_file</code> <code>List[int]</code> <p>list of frames IN FILES to load (relative to the beginning of the file from which you are loading).</p> required <code>files</code> <code>Union[List[str], List[Path]]</code> <p>a file for every frame</p> required <code>volumes</code> <code>List[int]</code> <p>a volume for every frame where that frame belongs</p> required <code>show_file_names</code> <code>bool</code> <p>whether to print the names of the files from which the frames are loaded.                 Setting it to True will turn off show_progress.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>whether to show the progress bar of how many frames have been loaded. Won't have effect of show_file_names is True.</p> <code>True</code> <p>Returns:     4D array of shape (number of volumes, zslices, height, width)</p> Source code in <code>src/vodex/core.py</code> <pre><code>def load_volumes(self,\n                 frame_in_file: List[int],\n                 files: Union[List[str], List[Path]],\n                 volumes: List[int],\n                 show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n    \"\"\"\n     Loads specific volumes of data, where a volume is defined as a set of frames.\n     This method returns a 4D array of shape (n_volumes, n_frames_per_volume, height, width).\n\n    Args:\n        frame_in_file: list of frames IN FILES to load\n            (relative to the beginning of the file from which you are loading).\n        files: a file for every frame\n        volumes: a volume for every frame where that frame belongs\n        show_file_names: whether to print the names of the files from which the frames are loaded.\n                            Setting it to True will turn off show_progress.\n        show_progress: whether to show the progress bar of how many frames have been loaded.\n            Won't have effect of show_file_names is True.\n    Returns:\n        4D array of shape (number of volumes, zslices, height, width)\n    \"\"\"\n    # get frames and info\n    frames = self.loader.load_frames(frame_in_file, files,\n                                     show_file_names=show_file_names,\n                                     show_progress=show_progress)\n    n_frames, w, h = frames.shape\n\n    # get volume information\n    i_volume, count = np.unique(volumes, return_counts=True)\n    # you can use this method to load portions of the volumes (slices), so fpv will be smaller than a full volume\n    n_volumes, fpv = len(i_volume), count[0]\n    assert np.all(count == fpv), \"Can't have different number of frames per volume!\"\n\n    frames = frames.reshape((n_volumes, fpv, w, h))\n    return frames\n</code></pre>"},{"location":"api/core/#src.vodex.core.VolumeManager","title":"<code>VolumeManager</code>","text":"<p>A class containing information about the image volumes in the experiment: frames per volume, number of full volumes, and mapping of the frames to volumes.</p> <p>Parameters:</p> Name Type Description Default <code>fpv</code> <code>int</code> <p>frames per volume, number of frames in one volume</p> required <code>fgf</code> <code>int</code> <p>first good frame, the first frame in the imaging session that is at the top of a volume. For example if you started imaging at the top of the volume, fgf = 0, but if you started somewhere in the middle, the first good frame is , for example, 23 ...</p> <code>0</code> <code>frame_manager</code> <code>FrameManager</code> <p>FrameManager object with the information about the frames in the experiment.</p> required <p>Attributes:</p> Name Type Description <code>fpv</code> <code>int</code> <p>frames per volume, number of frames in one volume</p> <code>frame_manager</code> <code>FrameManager</code> <p>FrameManager object with the information about the frames in the experiment.</p> <code>file_manager</code> <code>FileManager</code> <p>FileManager object with the information about the files.</p> <code>n_frames</code> <code>int</code> <p>total number of frames in the experiment</p> <code>n_head</code> <code>int</code> <p>(same as fgf) number of frames at the beginning of the recording, that do not correspond to a full volume. If the recording starts at the top of a volume, it will be 0.</p> <code>n_tail</code> <code>int</code> <p>number of frames at the end of the recording, that do not correspond to a full volume.</p> <code>full_volumes</code> <code>int</code> <p>number of full volumes in the recording.</p> <code>frame_to_z</code> <code>List[int]</code> <p>mapping of global frames to a z-slice (a slice relative to the top of the volume)</p> <code>frame_to_vol</code> <code>List[int]</code> <p>mapping of a global frame to a full volume: -1 for head ( not full volume at the beginning )     volume number for full volumes : 0, 1, ,2 3, ..., -2 for tail (not full volume at the end )</p> Source code in <code>src/vodex/core.py</code> <pre><code>class VolumeManager:\n    \"\"\"\n    A class containing information about the image volumes in the experiment: frames per volume,\n    number of full volumes, and mapping of the frames to volumes.\n\n    Args:\n        fpv: frames per volume, number of frames in one volume\n        fgf: first good frame, the first frame in the imaging session that is at the top of a volume.\n            For example if you started imaging at the top of the volume, fgf = 0,\n            but if you started somewhere in the middle, the first good frame is , for example, 23 ...\n        frame_manager: FrameManager object with the information about the frames in the experiment.\n\n    Attributes:\n        fpv: frames per volume, number of frames in one volume\n        frame_manager: FrameManager object with the information about the frames in the experiment.\n        file_manager: FileManager object with the information about the files.\n        n_frames: total number of frames in the experiment\n        n_head: (same as fgf) number of frames at the beginning of the recording,\n            that do not correspond to a full volume. If the recording starts at the top of a volume, it will be 0.\n        n_tail: number of frames at the end of the recording, that do not correspond to a full volume.\n        full_volumes: number of full volumes in the recording.\n        frame_to_z: mapping of global frames to a z-slice (a slice relative to the top of the volume)\n        frame_to_vol: mapping of a global frame to a full volume: -1 for head ( not full volume at the beginning )\n                volume number for full volumes : 0, 1, ,2 3, ..., -2 for tail (not full volume at the end )\n    \"\"\"\n\n    def __init__(self, fpv: int, frame_manager: FrameManager, fgf: int = 0):\n\n        assert isinstance(fpv, int), \"fpv must be an integer\"\n        assert isinstance(fgf, int), \"fgf must be an integer\"\n\n        # frames per volume\n        self.fpv: int = int(fpv)\n\n        # get total number of frames\n        self.frame_manager: FrameManager = frame_manager\n        self.file_manager: FileManager = frame_manager.file_manager\n        self.n_frames: int = int(np.sum(self.file_manager.num_frames))\n\n        # prepare info about frames at the beginning, full volumes and frames at the end\n        # first good frame, start counting from 0 : 0, 1, 2, 3, ...\n        # n_head is the number of frames before the first frame of the first full volume\n        # n_tail is the number of frames after the last frame of the last full volume\n        self.n_head: int = int(fgf)\n        full_volumes, n_tail = divmod((self.n_frames - self.n_head), self.fpv)\n        self.full_volumes: int = int(full_volumes)\n        self.n_tail: int = int(n_tail)\n\n        # map frames to slices an full volumes:\n        self.frame_to_z: List[int] = self._get_frames_to_z_mapping()\n        self.frame_to_vol: List[int] = self._get_frames_to_volumes_mapping()\n\n    def __eq__(self, other):\n        if isinstance(other, VolumeManager):\n            is_same = [\n                self.fpv == other.fpv,\n                self.frame_manager == other.frame_manager,\n                self.file_manager == other.file_manager,\n                self.n_frames == other.n_frames,\n                self.n_head == other.n_head,\n                self.full_volumes == other.full_volumes,\n                self.n_tail == other.n_tail,\n                self.frame_to_z == other.frame_to_z,\n                self.frame_to_vol == other.frame_to_vol\n            ]\n\n            return np.all(is_same)\n        else:\n            print(f\"__eq__ is Not Implemented for {VolumeManager} and {type(other)}\")\n            return NotImplemented\n\n    def _get_frames_to_z_mapping(self) -&gt; List[int]:\n        \"\"\"\n        maps frames to z-slices\n        \"\"\"\n        z_per_frame_list = np.arange(self.fpv).astype(int)\n        # set at what z the imaging starts and ends\n        i_from = self.fpv - self.n_head\n        i_to = self.n_tail - self.fpv\n        # map frames to z\n        frame_to_z = np.tile(z_per_frame_list, self.full_volumes + 2)[i_from:i_to]\n        return frame_to_z.tolist()\n\n    def _get_frames_to_volumes_mapping(self) -&gt; List[int]:\n        \"\"\"\n        maps frames to volumes\n        -1 for head ( not full volume at the beginning )\n        volume number for full volumes : 0, 1, ,2 3, ...\n        -2 for tail (not full volume at the end )\n        \"\"\"\n        # TODO : make sure n_head is not larger than full volume?\n        frame_to_vol = [-1] * self.n_head\n        for vol in np.arange(self.full_volumes):\n            frame_to_vol.extend([int(vol)] * self.fpv)\n        frame_to_vol.extend([-2] * self.n_tail)\n        return frame_to_vol\n\n    def __str__(self):\n        description = \"\"\n        description = description + f\"Total frames : {self.n_frames}\\n\"\n        description = description + f\"Volumes start on frame : {self.n_head}\\n\"\n        description = description + f\"Total good volumes : {self.full_volumes}\\n\"\n        description = description + f\"Frames per volume : {self.fpv}\\n\"\n        description = description + f\"Tailing frames (not a full volume , at the end) : {self.n_tail}\\n\"\n        return description\n\n    def __repr__(self):\n        return self.__str__()\n\n    @classmethod\n    def from_dir(cls, data_dir: Union[str, Path], fpv: int, fgf: int = 0, file_type: str = 'TIFF',\n                 file_names: List[str] = None, frames_per_file: List[int] = None):\n        \"\"\"\n        Creates a VolumeManager object from directory.\n\n        Args:\n            data_dir: path to the folder with the files, ends with \"/\" or \"\\\\\"\n            file_type: file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.\n            fpv: frames per volume, number of frames in one volume\n            fgf: first good frame, the first frame in the imaging session that is at the top of a volume.\n                For example if you started imaging at the top of the volume, fgf = 0,\n                but if you started somewhere in the middle, the first good frame is , for example, 23 ...\n            file_names: names of files relative to the data_dir\n            frames_per_file: number of frames in each file. Will be used ONLY if the file_names were provided.\n\n        Returns:\n            (VolumeManager): Initialised VolumeManager object.\n        \"\"\"\n        file_manager = FileManager(data_dir, file_type=file_type, file_names=file_names,\n                                   frames_per_file=frames_per_file)\n        frame_manager = FrameManager(file_manager)\n        return cls(fpv, frame_manager, fgf=fgf)\n</code></pre>"},{"location":"api/core/#src.vodex.core.VolumeManager.from_dir","title":"<code>from_dir(data_dir, fpv, fgf=0, file_type='TIFF', file_names=None, frames_per_file=None)</code>  <code>classmethod</code>","text":"<p>Creates a VolumeManager object from directory.</p> <p>Parameters:</p> Name Type Description Default <code>data_dir</code> <code>Union[str, Path]</code> <p>path to the folder with the files, ends with \"/\" or \"\\\"</p> required <code>file_type</code> <code>str</code> <p>file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.</p> <code>'TIFF'</code> <code>fpv</code> <code>int</code> <p>frames per volume, number of frames in one volume</p> required <code>fgf</code> <code>int</code> <p>first good frame, the first frame in the imaging session that is at the top of a volume. For example if you started imaging at the top of the volume, fgf = 0, but if you started somewhere in the middle, the first good frame is , for example, 23 ...</p> <code>0</code> <code>file_names</code> <code>List[str]</code> <p>names of files relative to the data_dir</p> <code>None</code> <code>frames_per_file</code> <code>List[int]</code> <p>number of frames in each file. Will be used ONLY if the file_names were provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>VolumeManager</code> <p>Initialised VolumeManager object.</p> Source code in <code>src/vodex/core.py</code> <pre><code>@classmethod\ndef from_dir(cls, data_dir: Union[str, Path], fpv: int, fgf: int = 0, file_type: str = 'TIFF',\n             file_names: List[str] = None, frames_per_file: List[int] = None):\n    \"\"\"\n    Creates a VolumeManager object from directory.\n\n    Args:\n        data_dir: path to the folder with the files, ends with \"/\" or \"\\\\\"\n        file_type: file type to search for (if files are not provided). Must be a key in the VX_SUPPORTED_TYPES dict.\n        fpv: frames per volume, number of frames in one volume\n        fgf: first good frame, the first frame in the imaging session that is at the top of a volume.\n            For example if you started imaging at the top of the volume, fgf = 0,\n            but if you started somewhere in the middle, the first good frame is , for example, 23 ...\n        file_names: names of files relative to the data_dir\n        frames_per_file: number of frames in each file. Will be used ONLY if the file_names were provided.\n\n    Returns:\n        (VolumeManager): Initialised VolumeManager object.\n    \"\"\"\n    file_manager = FileManager(data_dir, file_type=file_type, file_names=file_names,\n                               frames_per_file=frames_per_file)\n    frame_manager = FrameManager(file_manager)\n    return cls(fpv, frame_manager, fgf=fgf)\n</code></pre>"},{"location":"api/dbmethods/","title":"vodex.dbmethods module","text":"<p>This module contains classes that provide a consistent and easy-to-use interface for interacting with the SQLite database.</p> <p>DbWriter - A class that writes information to the database. It abstracts the SQLite calls and allows for easy creation, population, and saving of the database.</p> <p>DbReader - A class that reads information from the database. It abstracts the SQLite calls and allows for easy querying and retrieval of data from the database.</p> <p>DbExporter - A class that transforms the information from the database into the core classes, such as 'FileManager', 'VolumeManager', 'Labels', 'Timeline', 'Cycle' and 'Annotation', making it easier to view and edit with the data.</p>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter","title":"<code>DbExporter</code>","text":"<p>Transforms the information from the database into the core classes.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>class DbExporter:\n    \"\"\"\n    Transforms the information from the database into the core classes.\n    \"\"\"\n\n    # TODO : make it work for annotations\n\n    def __init__(self, db_reader: DbReader):\n        self.db = db_reader\n\n    @classmethod\n    def load(cls, file_name: Union[Path, str]):\n        \"\"\"\n        Loads a database from a file and initialises a DbExporter.\n\n        Args:\n            file_name: full path to a file to database.\n        \"\"\"\n        db_reader = DbReader.load(file_name)\n        return cls(db_reader)\n\n    def reconstruct_file_manager(self):\n        \"\"\"\n        Creates file manager from the database records.\n        \"\"\"\n        data_dir = self.db.get_data_dir()\n        file_names = self.db.get_file_names()\n        frames_per_file = self.db.get_frames_per_file()\n\n        fm = FileManager(data_dir, file_names=file_names, frames_per_file=frames_per_file)\n        return fm\n\n    def reconstruct_volume_manager(self):\n        \"\"\"\n        Creates volume manager from the database records.\n        \"\"\"\n        fm = self.reconstruct_file_manager()\n        fpv = self.db.get_fpv()\n        fgf = self.db.get_fgf()\n        vm = VolumeManager(fpv, FrameManager(fm), fgf=fgf)\n        return vm\n\n    def reconstruct_labels(self, group):\n        \"\"\"\n        Creates labels corresponding to the specified annotation from the database records.\n        \"\"\"\n        state_names, state_info = self.db.get_Name_and_Description_from_AnnotationTypeLabels(group)\n        labels = Labels(group, state_names, state_info=state_info)\n        return labels\n\n    def reconstruct_timeline(self, group):\n        labels = self.reconstruct_labels(group)\n        import itertools\n        \"\"\"\n        Creates timeline corresponding to the specified annotation from the database records.\n        \"\"\"\n        # get the mapping between the names and the Ids\n        label_names = self.db.get_Id_map_to_Names_from_AnnotationTypeLabels()\n        # get all the labels that were used in the annotation ( does not reconstruct unused Labels )\n        labels_per_frame = self.db.get_AnnotationTypeLabelId_from_Annotations(group)\n\n        label_order = []\n        duration = []\n        for label_id, frames in itertools.groupby(labels_per_frame):\n            label_name = label_names[label_id]\n            label_order.append(labels.__getattribute__(label_name))\n            duration.append(sum(1 for _ in frames))\n\n        timeline = Timeline(label_order, duration)\n        return timeline\n\n    def reconstruct_cycle(self, group):\n        \"\"\"\n        Creates cycle corresponding to the specified annotation from the database records.\n        \"\"\"\n        cycle_json = self.db.get_Structure_from_Cycle(group)\n        if cycle_json is not None:\n            cycle = Cycle.from_json(cycle_json)\n        else:\n            cycle = None\n        return cycle\n\n    def reconstruct_annotations(self):\n        \"\"\"\n        Creates annotations from the database records.\n        \"\"\"\n        # get the names of all the available annotations from the db\n        annotation_names = self.db.get_Names_from_AnnotationTypes()\n        # get the total number of frames in the recording\n        n_frames = FrameManager(self.reconstruct_file_manager()).n_frames\n\n        annotations = []\n        for group in annotation_names:\n            # reconstruct Labels for the group\n            labels = self.reconstruct_labels(group)\n            # try to get a cycle\n            cycle = self.reconstruct_cycle(group)\n            # define the annotation type ( Cycle / Timeline)\n            if cycle is not None:\n                annotation = Annotation.from_cycle(n_frames, labels, cycle)\n            else:\n                timeline = self.reconstruct_timeline(group)\n                annotation = Annotation.from_timeline(n_frames, labels, timeline)\n\n            annotations.append(annotation)\n\n        return annotations\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter.load","title":"<code>load(file_name)</code>  <code>classmethod</code>","text":"<p>Loads a database from a file and initialises a DbExporter.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[Path, str]</code> <p>full path to a file to database.</p> required Source code in <code>src/vodex/dbmethods.py</code> <pre><code>@classmethod\ndef load(cls, file_name: Union[Path, str]):\n    \"\"\"\n    Loads a database from a file and initialises a DbExporter.\n\n    Args:\n        file_name: full path to a file to database.\n    \"\"\"\n    db_reader = DbReader.load(file_name)\n    return cls(db_reader)\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter.reconstruct_annotations","title":"<code>reconstruct_annotations()</code>","text":"<p>Creates annotations from the database records.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def reconstruct_annotations(self):\n    \"\"\"\n    Creates annotations from the database records.\n    \"\"\"\n    # get the names of all the available annotations from the db\n    annotation_names = self.db.get_Names_from_AnnotationTypes()\n    # get the total number of frames in the recording\n    n_frames = FrameManager(self.reconstruct_file_manager()).n_frames\n\n    annotations = []\n    for group in annotation_names:\n        # reconstruct Labels for the group\n        labels = self.reconstruct_labels(group)\n        # try to get a cycle\n        cycle = self.reconstruct_cycle(group)\n        # define the annotation type ( Cycle / Timeline)\n        if cycle is not None:\n            annotation = Annotation.from_cycle(n_frames, labels, cycle)\n        else:\n            timeline = self.reconstruct_timeline(group)\n            annotation = Annotation.from_timeline(n_frames, labels, timeline)\n\n        annotations.append(annotation)\n\n    return annotations\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter.reconstruct_cycle","title":"<code>reconstruct_cycle(group)</code>","text":"<p>Creates cycle corresponding to the specified annotation from the database records.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def reconstruct_cycle(self, group):\n    \"\"\"\n    Creates cycle corresponding to the specified annotation from the database records.\n    \"\"\"\n    cycle_json = self.db.get_Structure_from_Cycle(group)\n    if cycle_json is not None:\n        cycle = Cycle.from_json(cycle_json)\n    else:\n        cycle = None\n    return cycle\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter.reconstruct_file_manager","title":"<code>reconstruct_file_manager()</code>","text":"<p>Creates file manager from the database records.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def reconstruct_file_manager(self):\n    \"\"\"\n    Creates file manager from the database records.\n    \"\"\"\n    data_dir = self.db.get_data_dir()\n    file_names = self.db.get_file_names()\n    frames_per_file = self.db.get_frames_per_file()\n\n    fm = FileManager(data_dir, file_names=file_names, frames_per_file=frames_per_file)\n    return fm\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter.reconstruct_labels","title":"<code>reconstruct_labels(group)</code>","text":"<p>Creates labels corresponding to the specified annotation from the database records.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def reconstruct_labels(self, group):\n    \"\"\"\n    Creates labels corresponding to the specified annotation from the database records.\n    \"\"\"\n    state_names, state_info = self.db.get_Name_and_Description_from_AnnotationTypeLabels(group)\n    labels = Labels(group, state_names, state_info=state_info)\n    return labels\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbExporter.reconstruct_volume_manager","title":"<code>reconstruct_volume_manager()</code>","text":"<p>Creates volume manager from the database records.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def reconstruct_volume_manager(self):\n    \"\"\"\n    Creates volume manager from the database records.\n    \"\"\"\n    fm = self.reconstruct_file_manager()\n    fpv = self.db.get_fpv()\n    fgf = self.db.get_fgf()\n    vm = VolumeManager(fpv, FrameManager(fm), fgf=fgf)\n    return vm\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader","title":"<code>DbReader</code>","text":"<p>Reads information from the database. Database interface that abstracts the SQLite calls.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>class DbReader:\n    \"\"\"\n    Reads information from the database.\n    Database interface that abstracts the SQLite calls.\n    \"\"\"\n\n    # TODO : get rid of list of tuples?\n    #  can do using `con.row_factory = sqlite3.Row`;\n    #  will get Row objects instead of tuples, and you can use row[0] like always or\n    #  row['column_name'] (case insensitive)\n    #  https://docs.python.org/2/library/sqlite3.html#sqlite3.Connection.row_factory\n    #  https://docs.python.org/2/library/sqlite3.html#accessing-columns-by-name-instead-of-by-index\n\n    def __init__(self, connection):\n        self.connection = connection\n        self.connection.execute(\"PRAGMA foreign_keys = 1\")\n\n    def get_n_frames(self):\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(f\"SELECT COUNT(*) FROM Frames\")\n            n_frames = cursor.fetchone()[0]\n        except Exception as e:\n            print(f\"Could not get total number of frames from Frames because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return n_frames\n\n        # get the volumes\n\n    def get_data_dir(self):\n        \"\"\"\n        Get data directory\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT Value FROM Options \n                     WHERE Key = \"data_dir\" \"\"\"\n            )\n            data_dir = cursor.fetchone()[0]\n        except Exception as e:\n            print(f\"Could not get_data_dir because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return data_dir\n\n    def get_fpv(self):\n        \"\"\"\n        Get frames per volume\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT Value FROM Options \n                     WHERE Key = \"frames_per_volume\" \"\"\"\n            )\n            fpv = int(cursor.fetchone()[0])\n        except Exception as e:\n            print(f\"Could not get_fpv because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return fpv\n\n    def get_fgf(self):\n        \"\"\"\n        Get frames per volume\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT Value FROM Options \n                     WHERE Key = \"num_head_frames\" \"\"\"\n            )\n            fdf = int(cursor.fetchone()[0])\n        except Exception as e:\n            print(f\"Could not get_fgf because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return fdf\n\n    def get_options(self):\n        \"\"\"\n        Gets the information from the OPTIONS table.\n        Returns a dictionary with the Key: Value from the table.\n        ( Keys: 'data_dir', 'frames_per_volume', 'num_head_frames', 'num_tail_frames', 'num_full_volumes' )\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT * FROM Options\"\"\"\n            )\n            options = {}\n            for row in cursor.fetchall():\n                options[row[0]] = row[1]\n\n        except Exception as e:\n            print(f\"Could not get_options because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return options\n\n    def get_file_names(self):\n        \"\"\"\n        Get the file names from the Files table.\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT FileName FROM Files ORDER BY Id ASC\"\"\"\n            )\n            file_names = [row[0] for row in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not get_file_names because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return file_names\n\n    def get_frames_per_file(self):\n        \"\"\"\n        Get the file names from the Files table.\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT NumFrames FROM Files ORDER BY Id ASC\"\"\"\n            )\n            frames_per_file = [row[0] for row in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not get_frames_per_file because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return frames_per_file\n\n    def get_volume_list(self):\n        \"\"\"\n        Returns a list of all the volumes.\n        :return: list of all the volumes\n        :rtype: [int]\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(f\"SELECT DISTINCT VolumeId FROM Volumes\")\n            volume_ids = [volume[0] for volume in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not get total number of frames from Frames because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return volume_ids\n\n    @classmethod\n    def load(cls, file_name):\n        \"\"\"\n        Load the contents of a database file on disk to a\n        transient copy in memory without modifying the file\n        \"\"\"\n        disk_db = connect(file_name)\n        memory_db = connect(':memory:')\n        disk_db.backup(memory_db)\n        disk_db.close()\n        # Now use `memory_db` without modifying disk db\n        return cls(memory_db)\n\n    def choose_full_volumes(self, frames):\n        \"\"\"\n        Chooses the frames from specified frames, that also correspond to full volumes.\n\n        The order of the frames is not preserved!\n        The result will correspond to frames sorted in increasing order !\n\n        :param frames: a list of frame IDs\n        :type frames: [int]\n        :param fpv: frames per volume\n        :type fpv: int\n        :return: frames IDs from frames. corresponding to slices\n        :rtype: [int]\n        \"\"\"\n        # create list of frame Ids\n        frame_ids = tuple(frames)\n        n_frames = len(frame_ids)\n\n        # get the volumes\n        cursor = self.connection.cursor()\n        try:\n            # get n_volumes (frames per volume)\n            cursor.execute(\n                f\"\"\"SELECT Value FROM Options \n                    WHERE Key = \"frames_per_volume\" \"\"\"\n            )\n            fpv = int(cursor.fetchone()[0])\n\n            # get ids of full volumes in the provided frames\n            cursor.execute(\n                f\"\"\"SELECT VolumeId FROM\n                    (\n                    SELECT VolumeId, count(VolumeId) as N\n                    FROM Volumes\n                    WHERE FrameId IN ({', '.join(['?'] * n_frames)})\n                    GROUP BY VolumeId\n                    )\n                    WHERE N = ?\"\"\", frame_ids + (fpv,)\n            )\n            volume_ids = [volume[0] for volume in cursor.fetchall()]\n            n_volumes = len(volume_ids)\n\n            # get all frames from frames that correspond to full volumes\n            cursor.execute(\n                f\"\"\"SELECT FrameId FROM Volumes\n                    WHERE FrameId IN ({', '.join(['?'] * n_frames)})\n                    AND VolumeId IN ({', '.join(['?'] * n_volumes)})\"\"\", frame_ids + tuple(volume_ids)\n            )\n            frame_ids = [frame[0] for frame in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not choose_full_volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return volume_ids, frame_ids\n\n    def choose_frames_per_slices(self, frames: List[int], slices: List[int]) -&gt; List[int]:\n        \"\"\"\n        Chooses the frames from specified frames, that also correspond to the same slices (continuously)\n        in different volumes.\n        For example, if slices = [2,3,4] it will choose such frames from \"given frames\" that also correspond\n        to a chunk from slice 2 to slice 4 in all the volumes.\n        If there is a frame that corresponds to a slice \"2\" in a volume,\n        but no frames corresponding to the slices \"3\" and \"4\" in the SAME volume, such frame will not be picked.\n\n        The order of the frames is not preserved!\n        The result will correspond to frames sorted in increasing order !\n\n        Args:\n            frames: a list of frame IDs\n            slices: a list of slice IDs, order will not be preserved: will be sorted in increasing order\n\n        Returns:\n            frames IDs from frames. corresponding to slices\n        \"\"\"\n        # create list of frame Ids\n        frame_ids = tuple(frames)\n        slice_ids = tuple(slices)\n        n_frames = len(frame_ids)\n        n_slices = len(slices)\n\n        # get the volumes\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                f\"\"\"SELECT FrameId FROM Volumes\n                    WHERE FrameId in ({', '.join(['?'] * n_frames)})\n                    AND SliceInVolume IN ({', '.join(['?'] * n_slices)})\n                    AND VolumeId IN\n                        (\n                        SELECT VolumeId FROM\n                            (\n                            SELECT VolumeId, count(VolumeId) as N \n                            FROM Volumes \n                            WHERE FrameId IN ({', '.join(['?'] * n_frames)})\n                            AND SliceInVolume IN ({', '.join(['?'] * n_slices)})\n                            GROUP BY VolumeId\n                            )\n                        WHERE N = ?\n                        )\"\"\", frame_ids + slice_ids + frame_ids + slice_ids + (n_slices,)\n            )\n\n            frame_ids = cursor.fetchall()\n        except Exception as e:\n            print(f\"Could not choose_frames_per_slices because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        frame_ids = [frame[0] for frame in frame_ids]\n        return frame_ids\n\n    def prepare_frames_for_loading(self, frames: List[int]) -&gt; \\\n            Tuple[str, List[str], List[str], List[int], List[int]]:\n        \"\"\"\n        Finds all the information needed\n        1) to load the frames\n        2) and shape them back into volumes/slices.\n        For each frame returns the image file,\n        frame location on the image and corresponding volume.\n\n        The order is not preserved!\n        the volume correspond to sorted volumes in increasing order !\n\n        Args:\n            frames: a list of frame IDs\n\n        Returns:\n             three lists, the length of the frames : data directory, file names,\n             image files, frame location on the image, volumes.\n        \"\"\"\n        # TODO : break into functions that get the file locations and the stuff relevant to the frames\n        # TODO : make one \" prepare volumes \" for loading?\n\n        n_frames = len(frames)\n\n        # get the frames\n        cursor = self.connection.cursor()\n        try:\n            # get data directory\n            cursor.execute(\n                f\"\"\"SELECT Value\n                    FROM Options\n                    WHERE Key = \"data_dir\" \"\"\")\n            data_dir = cursor.fetchone()[0]\n\n            # get file_names\n            cursor.execute(\n                f\"\"\"SELECT FileName\n                    FROM Files \"\"\")\n            file_names = cursor.fetchall()\n\n            # get info for every frame\n            cursor.execute(\n                f\"\"\"SELECT \n                        FileId,\n                        FrameInFile,\n                        VolumeId\n                    FROM \n                        Frames\n                        INNER JOIN Volumes \n                        ON Frames.Id = Volumes.FrameId\n                    WHERE FrameId IN ({', '.join(['?'] * n_frames)})\"\"\", tuple(frames))\n            frame_info = cursor.fetchall()\n\n        except Exception as e:\n            print(f\"Could not prepare_frames_for_loading because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        file_names = [row[0] for row in file_names]\n\n        file_ids = [row[0] for row in frame_info]\n        frame_in_file = [row[1] for row in frame_info]\n        volumes = [row[2] for row in frame_info]\n\n        return data_dir, file_names, file_ids, frame_in_file, volumes\n\n    def get_frames_per_volumes(self, volume_ids: List[int], slices: List[int] = None):\n        \"\"\"\n        Finds all the frames that correspond to the specified volumes.\n        The order is not preserved!\n        the volume correspond to sorted volumes in increasing order !\n\n        Args:\n            volume_ids: a list of volume IDs\n            slices: a list of slice IDs, order will not be preserved: will be sorted in increasing order\n\n        Returns:\n            a list of frame IDs that correspond to the specified volumes and\n            slices (if specified).\n            order will not be preserved: frames will be sorted in increasing order\n        \"\"\"\n        ids = list_of_int(volume_ids)\n\n        if slices is not None:\n            slices = list_of_int(slices)\n            ids.extend(slices)\n\n            # get the frames\n            cursor = self.connection.cursor()\n            try:\n                # create a parameterised query with variable number of parameters\n                cursor.execute(\n                    f\"\"\"SELECT FrameId FROM Volumes \n                                    WHERE VolumeId IN ({', '.join(['?'] * len(volume_ids))}) \n                                    AND SliceInVolume IN  ({', '.join(['?'] * len(slices))})\"\"\",\n                    tuple(ids))\n                frame_ids = cursor.fetchall()\n            except Exception as e:\n                print(f\"Could not get_frames_per_volumes because {e}\")\n                raise e\n            finally:\n                cursor.close()\n        else:\n            # get the frames\n            cursor = self.connection.cursor()\n            try:\n                # create a parameterised query with variable number of parameters\n                cursor.execute(\n                    f\"\"\"SELECT FrameId FROM Volumes \n                        WHERE VolumeId IN ({', '.join(['?'] * len(ids))})\"\"\", tuple(ids))\n                frame_ids = cursor.fetchall()\n            except Exception as e:\n                print(f\"Could not get_frames_per_volumes because {e}\")\n                raise e\n            finally:\n                cursor.close()\n        frame_ids = [frame[0] for frame in frame_ids]\n        # sort the frames: this is important when having -2 and -1 as volume ids. Otherwise -2 will be first.\n        frame_ids.sort()\n\n        return frame_ids\n\n    def get_and_frames_per_annotations(self, conditions):\n        \"\"\"\n        Chooses the frames that correspond to the specified conditions on annotation. Using \"and\" logic. Example : if\n        you ask for frames corresponding to condition 1 and condition 2 , it will return such frames that both\n        condition 1 and condition 2 are True AT THE SAME TIME\n\n        :param conditions: a list of conditions on the annotation labels\n        in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n        and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]\n        :type conditions: [tuple]\n        :return: list of frame Ids that satisfy all the conditions, if there are no such frames, an empty list\n        :rtype: list\n        \"\"\"\n\n        # get the frames\n        cursor = self.connection.cursor()\n        try:\n            # create list of label Ids\n            labels_ids = []\n            for label_info in conditions:\n                labels_ids.append(self._get_Id_from_AnnotationTypeLabels(label_info))\n            labels_ids = tuple(labels_ids)\n            n_labels = len(labels_ids)\n\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT FrameId FROM \n                    (SELECT FrameId, count(FrameId) as N \n                    FROM Annotations \n                    WHERE AnnotationTypeLabelId IN ({', '.join(['?'] * n_labels)})\n                    GROUP BY FrameId)\n                    WHERE N = {n_labels}\"\"\", labels_ids)\n            frame_ids = cursor.fetchall()\n        except Exception as e:\n            print(f\"Could not _get_and_FrameId_from_Annotations because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        frame_ids = [frame[0] for frame in frame_ids]\n        return frame_ids\n\n    def get_or_frames_per_annotations(self, conditions):\n        \"\"\"\n        Chooses the frames that correspond to the specified conditions on annotation. Using \"or\" logic. Example : if\n        you ask for frames corresponding to condition 1 and condition 2 , it will return such frames that either\n        condition 1 is true OR condition 2 is True OR both are true.\n\n        :param conditions: a list of conditions on the annotation labels\n        in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n        and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]\n        :type conditions: [tuple]\n        :return:\n        :rtype:\n        \"\"\"\n\n        # get the frames\n        cursor = self.connection.cursor()\n        try:\n            # create list of label Ids\n            labels_ids = []\n            for label_info in conditions:\n                labels_ids.append(self._get_Id_from_AnnotationTypeLabels(label_info))\n            labels_ids = tuple(labels_ids)\n            n_labels = len(labels_ids)\n\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT FrameId FROM Annotations \n                    WHERE AnnotationTypeLabelId IN ({', '.join(['?'] * n_labels)})\n                    GROUP BY FrameId\"\"\", labels_ids)\n            frame_ids = cursor.fetchall()\n        except Exception as e:\n            print(f\"Could not _get_or_FrameId_from_Annotations because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        frame_ids = [frame[0] for frame in frame_ids]\n        return frame_ids\n\n    def get_volume_annotations(self, volumes: List[int],\n                               annotation_names: Optional[List[str]] = None) -&gt; Dict[str, Dict[str, List[str]]]:\n        \"\"\"\n        Returns a dictionary with annotations for the specified volumes. If annotation_name is specified, it will return only\n        the annotations for that annotation type. Otherwise, it will return all annotations for all annotation types.\n\n        Args:\n            volumes: list of volume ids\n            annotation_names: list of names of the annotation type to return annotations for. If None, it will return\n                annotations for all annotation types\n\n        Returns:\n            dictionary with volumes ids and annotation labels for each volume and for each annotation type requested\n        \"\"\"\n        # make sure volumes is a list of integers\n        volume_ids = list_of_int(volumes)\n\n        # get the annotations\n        cursor = self.connection.cursor()\n        try:\n            # check that the annotation type exists\n            cursor.execute(\n                f\"\"\"SELECT Name FROM AnnotationTypes\"\"\")\n            annotations = cursor.fetchall()\n            annotations = [annotation[0] for annotation in annotations]\n\n            if annotation_names is not None:\n                for name in annotation_names:\n                    assert name in annotations, f\"Annotation type {name} does not exist\"\n                annotations = annotation_names\n\n            annotation_dict = {}\n            for annotation_name in annotations:\n                cursor.execute(\n                    f\"\"\"SELECT Volumes.VolumeId, AnnotationTypeLabels.Name FROM\n                        AnnotationTypeLabels \n                        INNER JOIN Annotations ON AnnotationTypeLabels.Id = Annotations.AnnotationTypeLabelId \n                        INNER JOIN Volumes ON Annotations.FrameId = Volumes.FrameId\n                        INNER JOIN AnnotationTypes ON AnnotationTypes.Id = AnnotationTypeLabels.AnnotationTypeId\n                        WHERE AnnotationTypes.Name = ?\n                        AND Volumes.VolumeId in ({', '.join(['?'] * len(volume_ids))})\n                        ORDER BY Volumes.VolumeId\"\"\",\n                    [annotation_name] + volume_ids)\n\n                info = cursor.fetchall()\n                volume_ids = [row[0] for row in info]\n                labels = [row[1] for row in info]\n                annotation_dict[annotation_name] = {'volume_ids': volume_ids, 'labels': labels}\n\n        except Exception as e:\n            print(f\"Could not get_volume_annotations because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return annotation_dict\n\n    def get_conditionIds_per_cycle_per_volumes(self, annotation_name):\n        \"\"\"\n        For the first cycle of a given annotation, returns a list of condition IDs that correspond to each volume:\n        volume Index, condition that happens during that volume, how many frames that condition lasts in that volume.\n        Warning: does not maintain the order of conditions within the volume!\n\n        Args:\n            annotation_name: str\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            # check that the annotation is a cycle\n            cursor.execute(\n                f\"\"\"SELECT Id FROM Cycles \n                WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\", (annotation_name,))\n            assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT VolumeId, AnnotationTypeLabelId, count(VolumeId) FROM\n                    CycleIterations \n                    INNER JOIN Volumes ON CycleIterations.FrameId = Volumes.FrameId \n                    INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                    WHERE AnnotationTypeLabelId in \n                        (\n                        SELECT Id from AnnotationTypeLabels \n                        WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                        )\n                    AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    AND CycleIteration = 0\n                    GROUP BY VolumeId, AnnotationTypeLabelId\n                    ORDER BY VolumeId\"\"\", (annotation_name, annotation_name))\n            info = cursor.fetchall()\n            volume_ids = [row[0] for row in info]\n            condition_ids = [row[1] for row in info]\n            count = [row[2] for row in info]\n\n        except Exception as e:\n            print(f\"Could not get_conditionIds_per_cycle_per_volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return volume_ids, condition_ids, count\n\n    def get_conditionIds_per_cycle_per_frame(self, annotation_name):\n        \"\"\"\n        Returns a list of condition IDs that correspond to each frame, list of corresponding frames.\n        annotation_name: str\n        \"\"\"\n        # TODO : check if empty\n        cursor = self.connection.cursor()\n        try:\n            # check that the annotation is a cycle\n            cursor.execute(\n                f\"\"\"SELECT Id FROM Cycles \n                            WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\",\n                (annotation_name,))\n            assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT CycleIterations.FrameId, AnnotationTypeLabelId FROM\n                    CycleIterations \n                    INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                    WHERE AnnotationTypeLabelId in \n                        (\n                        SELECT Id from AnnotationTypeLabels \n                        WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                        )\n                    AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    AND CycleIteration = 0\n                    ORDER BY CycleIterations.FrameId\"\"\", (annotation_name, annotation_name))\n            info = cursor.fetchall()\n            # TODO : check if empty\n            frame_ids = [row[0] for row in info]\n            condition_ids = [row[1] for row in info]\n\n        except Exception as e:\n            print(f\"Could not get_conditionIds_per_cycle_per_frame because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return frame_ids, condition_ids\n\n    def get_cycleIterations_per_volumes(self, annotation_name):\n        \"\"\"\n        Returns a list of cycleIterations that correspond to each volume, list of corresponding volumes\n        and a count of the volume-iteration pairs\n        annotation_name: str\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            # check that the annotation is a cycle\n            cursor.execute(\n                f\"\"\"SELECT Id FROM Cycles \n                                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\",\n                (annotation_name,))\n            assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT VolumeId, CycleIteration, count(VolumeId) FROM\n                    CycleIterations \n                    INNER JOIN Volumes ON CycleIterations.FrameId = Volumes.FrameId \n                    INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                    WHERE AnnotationTypeLabelId in \n                        (\n                        SELECT Id from AnnotationTypeLabels \n                        WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                        )\n                    AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    GROUP BY VolumeId\n                    ORDER BY VolumeId\"\"\", (annotation_name, annotation_name))\n            info = cursor.fetchall()\n            volume_ids = [row[0] for row in info]\n            cycle_its = [row[1] for row in info]\n            count = [row[2] for row in info]\n\n        except Exception as e:\n            print(f\"Could not get_cycleIterations_per_volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return volume_ids, cycle_its, count\n\n    def get_cycleIterations_per_frame(self, annotation_name):\n        \"\"\"\n        Returns a list of cycle iterations that correspond to each frame, list of corresponding frames.\n        annotation_name: str\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            # check that the annotation is a cycle\n            cursor.execute(\n                f\"\"\"SELECT Id FROM Cycles \n                                                WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\",\n                (annotation_name,))\n            assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT CycleIterations.FrameId, CycleIteration FROM\n                    CycleIterations \n                    INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                    WHERE AnnotationTypeLabelId in \n                        (\n                        SELECT Id from AnnotationTypeLabels \n                        WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                        )\n                    AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    ORDER BY CycleIterations.FrameId\"\"\", (annotation_name, annotation_name))\n            info = cursor.fetchall()\n            frame_ids = [row[0] for row in info]\n            cycle_its = [row[1] for row in info]\n\n        except Exception as e:\n            print(f\"Could not get_conditionIds_per_cycle_per_frame because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n        return frame_ids, cycle_its\n\n    def get_Names_from_AnnotationTypes(self):\n        \"\"\"\n        Returns the names of all the available annotations.\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\"\"\"SELECT Name FROM AnnotationTypes ORDER BY Id\"\"\")\n            names = [name[0] for name in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not _get_Name_from_AnnotationTypes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return names\n\n    def get_cycle_names(self):\n        \"\"\"\n        Returns the names of all the available cycles.\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\"\"\"SELECT AnnotationTypes.Name \n                            FROM Cycles INNER JOIN AnnotationTypes \n                            ON Cycles.AnnotationTypeId = AnnotationTypes.Id\"\"\")\n            names = [name[0] for name in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not get_cycle_names because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return names\n\n    def get_Structure_from_Cycle(self, annotation_name):\n        \"\"\"\n        Returns cycle Structure if the annotation has a cycle entry or None otherwise.\n        \"\"\"\n        annotation_name = (annotation_name,)\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\"\"\"SELECT Structure FROM Cycles WHERE AnnotationTypeId = \n                             (SELECT Id FROM AnnotationTypes WHERE Name = ?)\"\"\", annotation_name)\n            info = cursor.fetchone()\n            if info:\n                cycle = info[0]\n            else:\n                cycle = None\n        except Exception as e:\n            print(f\"Could not get_Structure_from_Cycle because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return cycle\n\n    def get_Name_and_Description_from_AnnotationTypeLabels(self, annotation_name):\n        \"\"\"\n        Returns the Name and description for the labels that correspond to the annotation\n        with the provided group name.\n        \"\"\"\n        annotation_name = (annotation_name,)\n        names = []\n        descriptions = {}\n\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\"\"\"SELECT Name, Description FROM AnnotationTypeLabels WHERE AnnotationTypeId = \n                             (SELECT Id FROM AnnotationTypes WHERE Name = ?)\"\"\", annotation_name)\n            info = cursor.fetchall()\n            for row in info:\n                name = row[0]\n                names.append(name)\n                descriptions[name] = row[1]\n        except Exception as e:\n            print(f\"Could not get_Name_and_Description_from_AnnotationTypeLabels because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return names, descriptions\n\n    def _get_Names_from_AnnotationTypeLabels(self):\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\"\"\"SELECT Name FROM AnnotationTypeLabels ORDER BY Id ASC\"\"\")\n            names = [name[0] for name in cursor.fetchall()]\n        except Exception as e:\n            print(f\"Could not _get_Name_from_AnnotationTypeLabels because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return names\n\n    def get_Id_map_to_Names_from_AnnotationTypeLabels(self):\n        \"\"\"\n        Returns a dictionary with Ids as keys and names as values.\n        \"\"\"\n        cursor = self.connection.cursor()\n        mapping = {}\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\"\"\"SELECT Id, Name FROM AnnotationTypeLabels ORDER BY Id ASC\"\"\")\n            info = cursor.fetchall()\n            for row in info:\n                mapping[row[0]] = row[1]\n        except Exception as e:\n            print(f\"Could not get_Id_map_to_Names_from_AnnotationTypeLabels because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return mapping\n\n    def _get_Id_from_AnnotationTypeLabels(self, label_info):\n        \"\"\"\n        Returns the AnnotationTypeLabels.Id for a label , searching by its name and group name.\n        :param label_info: (annotation_name, label_name), where group is the AnnotationType.Name\n                            and name is AnnotationTypeLabels.Name\n        :type label_info: tuple\n        :return: AnnotationLabels.Id\n        :rtype: int\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT Id FROM AnnotationTypeLabels \n                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    and Name = ?\"\"\", label_info)\n            label_id = cursor.fetchone()\n            assert label_id is not None, f\"Could not find a label from group {label_info[0]} \" \\\n                                         f\"with name {label_info[1]}. \" \\\n                                         f\"Are you sure it's been added into the database? \"\n        except Exception as e:\n            print(f\"Could not _get_AnnotationLabelId because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return label_id[0]\n\n    def _get_Ids_from_AnnotationTypeLabels(self, annotation_name: str) -&gt; List[int]:\n        \"\"\"\n        Returns the AnnotationTypeLabels.Id for all labels , searching by their group name.\n\n        Args:\n        annotation_name: AnnotationType.Name\n        Returns:\n            list of AnnotationLabels.Id\n        \"\"\"\n        annotation_name = (annotation_name,)\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT Id FROM AnnotationTypeLabels \n                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\", annotation_name)\n            label_ids = cursor.fetchall()\n            assert len(label_ids) &gt; 0, f\"Could not find labels from group {annotation_name} \" \\\n                                       \"Are you sure it's been added into the database?\"\n        except Exception as e:\n            print(f\"Could not _get_AnnotationLabelIds because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return label_ids\n\n    def get_AnnotationTypeLabelId_from_Annotations(self, annotation_name):\n        \"\"\"\n        Returns the AnnotationTypeLabelIds for all labels in the order according to the FrameId,\n         searching by their group name.\n        :param annotation_name: AnnotationType.Name\n        :type annotation_name: str\n        :return: AnnotationLabels.Id\n        :rtype: [int]\n        \"\"\"\n        annotation_name = (annotation_name,)\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\" SELECT AnnotationTypeLabelId FROM Annotations WHERE AnnotationTypeLabelId IN\n                            (SELECT Id FROM AnnotationTypeLabels \n                            WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?))\n                            ORDER BY FrameId ASC\"\"\", annotation_name)\n            label_ids = [label[0] for label in cursor.fetchall()]\n            assert len(label_ids) &gt; 0, f\"Could not find labels from group {annotation_name} \" \\\n                                       \"Are you sure it's been added into the database?\"\n        except Exception as e:\n            print(f\"Could not _get_AnnotationTypeLabelId_from_Annotations because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return label_ids\n\n    def _get_SliceInVolume_from_Volumes(self, frames: List[int]) -&gt; List[int]:\n        \"\"\"\n        Chooses the slices that correspond to the specified frames.\n        Warning!: The order of the frames is not preserved!\n        the volume correspond to frames sorted in increasing order !\n        Frames are numbered from 1, slices are numbered from 0.\n\n        Args:\n            frames: a list of frame IDs\n        Returns:\n            volume IDs\n\n        \"\"\"\n        # create list of frame Ids\n        frame_ids = tuple(frames)\n        n_frames = len(frame_ids)\n\n        # get the volumes\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT SliceInVolume FROM Volumes \n                    WHERE FrameId IN ({', '.join(['?'] * n_frames)})\"\"\", frame_ids)\n            slice_ids = cursor.fetchall()\n            assert len(slice_ids) == len(frame_ids), \\\n                f\"Only {len(slice_ids)} of {len(frame_ids)} frames are in the database\"\n        except Exception as e:\n            print(f\"Could not _get_SliceInVolume_from_Volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        slice_ids = [slice_id[0] for slice_id in slice_ids]\n        return slice_ids\n\n    def _get_VolumeId_from_Volumes(self, frames):\n        \"\"\"\n        Chooses the volumes that correspond to the specified frames.\n        Warning: The order is not preserved!\n        the volume correspond to sorted frames in increasing order !\n\n        :param frames: a list of frame IDs\n        :type frames: [int]\n        :return: volume IDs\n        :rtype: [int]\n        \"\"\"\n        # create list of frame Ids\n        frame_ids = tuple(frames)\n        n_frames = len(frame_ids)\n\n        # get the volumes\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT VolumeId FROM Volumes \n                    WHERE FrameId IN ({', '.join(['?'] * n_frames)})\"\"\", frame_ids)\n            volume_ids = cursor.fetchall()\n        except Exception as e:\n            print(f\"Could not _get_VolumeId_from_Volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        volume_ids = [volume[0] for volume in volume_ids]\n        return volume_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.choose_frames_per_slices","title":"<code>choose_frames_per_slices(frames, slices)</code>","text":"<p>Chooses the frames from specified frames, that also correspond to the same slices (continuously) in different volumes. For example, if slices = [2,3,4] it will choose such frames from \"given frames\" that also correspond to a chunk from slice 2 to slice 4 in all the volumes. If there is a frame that corresponds to a slice \"2\" in a volume, but no frames corresponding to the slices \"3\" and \"4\" in the SAME volume, such frame will not be picked.</p> <p>The order of the frames is not preserved! The result will correspond to frames sorted in increasing order !</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>List[int]</code> <p>a list of frame IDs</p> required <code>slices</code> <code>List[int]</code> <p>a list of slice IDs, order will not be preserved: will be sorted in increasing order</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>frames IDs from frames. corresponding to slices</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def choose_frames_per_slices(self, frames: List[int], slices: List[int]) -&gt; List[int]:\n    \"\"\"\n    Chooses the frames from specified frames, that also correspond to the same slices (continuously)\n    in different volumes.\n    For example, if slices = [2,3,4] it will choose such frames from \"given frames\" that also correspond\n    to a chunk from slice 2 to slice 4 in all the volumes.\n    If there is a frame that corresponds to a slice \"2\" in a volume,\n    but no frames corresponding to the slices \"3\" and \"4\" in the SAME volume, such frame will not be picked.\n\n    The order of the frames is not preserved!\n    The result will correspond to frames sorted in increasing order !\n\n    Args:\n        frames: a list of frame IDs\n        slices: a list of slice IDs, order will not be preserved: will be sorted in increasing order\n\n    Returns:\n        frames IDs from frames. corresponding to slices\n    \"\"\"\n    # create list of frame Ids\n    frame_ids = tuple(frames)\n    slice_ids = tuple(slices)\n    n_frames = len(frame_ids)\n    n_slices = len(slices)\n\n    # get the volumes\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT FrameId FROM Volumes\n                WHERE FrameId in ({', '.join(['?'] * n_frames)})\n                AND SliceInVolume IN ({', '.join(['?'] * n_slices)})\n                AND VolumeId IN\n                    (\n                    SELECT VolumeId FROM\n                        (\n                        SELECT VolumeId, count(VolumeId) as N \n                        FROM Volumes \n                        WHERE FrameId IN ({', '.join(['?'] * n_frames)})\n                        AND SliceInVolume IN ({', '.join(['?'] * n_slices)})\n                        GROUP BY VolumeId\n                        )\n                    WHERE N = ?\n                    )\"\"\", frame_ids + slice_ids + frame_ids + slice_ids + (n_slices,)\n        )\n\n        frame_ids = cursor.fetchall()\n    except Exception as e:\n        print(f\"Could not choose_frames_per_slices because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    frame_ids = [frame[0] for frame in frame_ids]\n    return frame_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.choose_full_volumes","title":"<code>choose_full_volumes(frames)</code>","text":"<p>Chooses the frames from specified frames, that also correspond to full volumes.</p> <p>The order of the frames is not preserved! The result will correspond to frames sorted in increasing order !</p> <p>:param frames: a list of frame IDs :type frames: [int] :param fpv: frames per volume :type fpv: int :return: frames IDs from frames. corresponding to slices :rtype: [int]</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def choose_full_volumes(self, frames):\n    \"\"\"\n    Chooses the frames from specified frames, that also correspond to full volumes.\n\n    The order of the frames is not preserved!\n    The result will correspond to frames sorted in increasing order !\n\n    :param frames: a list of frame IDs\n    :type frames: [int]\n    :param fpv: frames per volume\n    :type fpv: int\n    :return: frames IDs from frames. corresponding to slices\n    :rtype: [int]\n    \"\"\"\n    # create list of frame Ids\n    frame_ids = tuple(frames)\n    n_frames = len(frame_ids)\n\n    # get the volumes\n    cursor = self.connection.cursor()\n    try:\n        # get n_volumes (frames per volume)\n        cursor.execute(\n            f\"\"\"SELECT Value FROM Options \n                WHERE Key = \"frames_per_volume\" \"\"\"\n        )\n        fpv = int(cursor.fetchone()[0])\n\n        # get ids of full volumes in the provided frames\n        cursor.execute(\n            f\"\"\"SELECT VolumeId FROM\n                (\n                SELECT VolumeId, count(VolumeId) as N\n                FROM Volumes\n                WHERE FrameId IN ({', '.join(['?'] * n_frames)})\n                GROUP BY VolumeId\n                )\n                WHERE N = ?\"\"\", frame_ids + (fpv,)\n        )\n        volume_ids = [volume[0] for volume in cursor.fetchall()]\n        n_volumes = len(volume_ids)\n\n        # get all frames from frames that correspond to full volumes\n        cursor.execute(\n            f\"\"\"SELECT FrameId FROM Volumes\n                WHERE FrameId IN ({', '.join(['?'] * n_frames)})\n                AND VolumeId IN ({', '.join(['?'] * n_volumes)})\"\"\", frame_ids + tuple(volume_ids)\n        )\n        frame_ids = [frame[0] for frame in cursor.fetchall()]\n    except Exception as e:\n        print(f\"Could not choose_full_volumes because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return volume_ids, frame_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_AnnotationTypeLabelId_from_Annotations","title":"<code>get_AnnotationTypeLabelId_from_Annotations(annotation_name)</code>","text":"<p>Returns the AnnotationTypeLabelIds for all labels in the order according to the FrameId,  searching by their group name. :param annotation_name: AnnotationType.Name :type annotation_name: str :return: AnnotationLabels.Id :rtype: [int]</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_AnnotationTypeLabelId_from_Annotations(self, annotation_name):\n    \"\"\"\n    Returns the AnnotationTypeLabelIds for all labels in the order according to the FrameId,\n     searching by their group name.\n    :param annotation_name: AnnotationType.Name\n    :type annotation_name: str\n    :return: AnnotationLabels.Id\n    :rtype: [int]\n    \"\"\"\n    annotation_name = (annotation_name,)\n    cursor = self.connection.cursor()\n    try:\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\" SELECT AnnotationTypeLabelId FROM Annotations WHERE AnnotationTypeLabelId IN\n                        (SELECT Id FROM AnnotationTypeLabels \n                        WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?))\n                        ORDER BY FrameId ASC\"\"\", annotation_name)\n        label_ids = [label[0] for label in cursor.fetchall()]\n        assert len(label_ids) &gt; 0, f\"Could not find labels from group {annotation_name} \" \\\n                                   \"Are you sure it's been added into the database?\"\n    except Exception as e:\n        print(f\"Could not _get_AnnotationTypeLabelId_from_Annotations because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return label_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_Id_map_to_Names_from_AnnotationTypeLabels","title":"<code>get_Id_map_to_Names_from_AnnotationTypeLabels()</code>","text":"<p>Returns a dictionary with Ids as keys and names as values.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_Id_map_to_Names_from_AnnotationTypeLabels(self):\n    \"\"\"\n    Returns a dictionary with Ids as keys and names as values.\n    \"\"\"\n    cursor = self.connection.cursor()\n    mapping = {}\n    try:\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\"\"\"SELECT Id, Name FROM AnnotationTypeLabels ORDER BY Id ASC\"\"\")\n        info = cursor.fetchall()\n        for row in info:\n            mapping[row[0]] = row[1]\n    except Exception as e:\n        print(f\"Could not get_Id_map_to_Names_from_AnnotationTypeLabels because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return mapping\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_Name_and_Description_from_AnnotationTypeLabels","title":"<code>get_Name_and_Description_from_AnnotationTypeLabels(annotation_name)</code>","text":"<p>Returns the Name and description for the labels that correspond to the annotation with the provided group name.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_Name_and_Description_from_AnnotationTypeLabels(self, annotation_name):\n    \"\"\"\n    Returns the Name and description for the labels that correspond to the annotation\n    with the provided group name.\n    \"\"\"\n    annotation_name = (annotation_name,)\n    names = []\n    descriptions = {}\n\n    cursor = self.connection.cursor()\n    try:\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\"\"\"SELECT Name, Description FROM AnnotationTypeLabels WHERE AnnotationTypeId = \n                         (SELECT Id FROM AnnotationTypes WHERE Name = ?)\"\"\", annotation_name)\n        info = cursor.fetchall()\n        for row in info:\n            name = row[0]\n            names.append(name)\n            descriptions[name] = row[1]\n    except Exception as e:\n        print(f\"Could not get_Name_and_Description_from_AnnotationTypeLabels because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return names, descriptions\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_Names_from_AnnotationTypes","title":"<code>get_Names_from_AnnotationTypes()</code>","text":"<p>Returns the names of all the available annotations.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_Names_from_AnnotationTypes(self):\n    \"\"\"\n    Returns the names of all the available annotations.\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\"\"\"SELECT Name FROM AnnotationTypes ORDER BY Id\"\"\")\n        names = [name[0] for name in cursor.fetchall()]\n    except Exception as e:\n        print(f\"Could not _get_Name_from_AnnotationTypes because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return names\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_Structure_from_Cycle","title":"<code>get_Structure_from_Cycle(annotation_name)</code>","text":"<p>Returns cycle Structure if the annotation has a cycle entry or None otherwise.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_Structure_from_Cycle(self, annotation_name):\n    \"\"\"\n    Returns cycle Structure if the annotation has a cycle entry or None otherwise.\n    \"\"\"\n    annotation_name = (annotation_name,)\n    cursor = self.connection.cursor()\n    try:\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\"\"\"SELECT Structure FROM Cycles WHERE AnnotationTypeId = \n                         (SELECT Id FROM AnnotationTypes WHERE Name = ?)\"\"\", annotation_name)\n        info = cursor.fetchone()\n        if info:\n            cycle = info[0]\n        else:\n            cycle = None\n    except Exception as e:\n        print(f\"Could not get_Structure_from_Cycle because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return cycle\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_and_frames_per_annotations","title":"<code>get_and_frames_per_annotations(conditions)</code>","text":"<p>Chooses the frames that correspond to the specified conditions on annotation. Using \"and\" logic. Example : if you ask for frames corresponding to condition 1 and condition 2 , it will return such frames that both condition 1 and condition 2 are True AT THE SAME TIME</p> <p>:param conditions: a list of conditions on the annotation labels in a form [(group, name),(group, name), ...] where group is a string for the annotation type and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')] :type conditions: [tuple] :return: list of frame Ids that satisfy all the conditions, if there are no such frames, an empty list :rtype: list</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_and_frames_per_annotations(self, conditions):\n    \"\"\"\n    Chooses the frames that correspond to the specified conditions on annotation. Using \"and\" logic. Example : if\n    you ask for frames corresponding to condition 1 and condition 2 , it will return such frames that both\n    condition 1 and condition 2 are True AT THE SAME TIME\n\n    :param conditions: a list of conditions on the annotation labels\n    in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n    and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]\n    :type conditions: [tuple]\n    :return: list of frame Ids that satisfy all the conditions, if there are no such frames, an empty list\n    :rtype: list\n    \"\"\"\n\n    # get the frames\n    cursor = self.connection.cursor()\n    try:\n        # create list of label Ids\n        labels_ids = []\n        for label_info in conditions:\n            labels_ids.append(self._get_Id_from_AnnotationTypeLabels(label_info))\n        labels_ids = tuple(labels_ids)\n        n_labels = len(labels_ids)\n\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\"SELECT FrameId FROM \n                (SELECT FrameId, count(FrameId) as N \n                FROM Annotations \n                WHERE AnnotationTypeLabelId IN ({', '.join(['?'] * n_labels)})\n                GROUP BY FrameId)\n                WHERE N = {n_labels}\"\"\", labels_ids)\n        frame_ids = cursor.fetchall()\n    except Exception as e:\n        print(f\"Could not _get_and_FrameId_from_Annotations because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    frame_ids = [frame[0] for frame in frame_ids]\n    return frame_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_conditionIds_per_cycle_per_frame","title":"<code>get_conditionIds_per_cycle_per_frame(annotation_name)</code>","text":"<p>Returns a list of condition IDs that correspond to each frame, list of corresponding frames. annotation_name: str</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_conditionIds_per_cycle_per_frame(self, annotation_name):\n    \"\"\"\n    Returns a list of condition IDs that correspond to each frame, list of corresponding frames.\n    annotation_name: str\n    \"\"\"\n    # TODO : check if empty\n    cursor = self.connection.cursor()\n    try:\n        # check that the annotation is a cycle\n        cursor.execute(\n            f\"\"\"SELECT Id FROM Cycles \n                        WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\",\n            (annotation_name,))\n        assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\"SELECT CycleIterations.FrameId, AnnotationTypeLabelId FROM\n                CycleIterations \n                INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                WHERE AnnotationTypeLabelId in \n                    (\n                    SELECT Id from AnnotationTypeLabels \n                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    )\n                AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                AND CycleIteration = 0\n                ORDER BY CycleIterations.FrameId\"\"\", (annotation_name, annotation_name))\n        info = cursor.fetchall()\n        # TODO : check if empty\n        frame_ids = [row[0] for row in info]\n        condition_ids = [row[1] for row in info]\n\n    except Exception as e:\n        print(f\"Could not get_conditionIds_per_cycle_per_frame because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return frame_ids, condition_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_conditionIds_per_cycle_per_volumes","title":"<code>get_conditionIds_per_cycle_per_volumes(annotation_name)</code>","text":"<p>For the first cycle of a given annotation, returns a list of condition IDs that correspond to each volume: volume Index, condition that happens during that volume, how many frames that condition lasts in that volume. Warning: does not maintain the order of conditions within the volume!</p> <p>Parameters:</p> Name Type Description Default <code>annotation_name</code> <p>str</p> required Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_conditionIds_per_cycle_per_volumes(self, annotation_name):\n    \"\"\"\n    For the first cycle of a given annotation, returns a list of condition IDs that correspond to each volume:\n    volume Index, condition that happens during that volume, how many frames that condition lasts in that volume.\n    Warning: does not maintain the order of conditions within the volume!\n\n    Args:\n        annotation_name: str\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        # check that the annotation is a cycle\n        cursor.execute(\n            f\"\"\"SELECT Id FROM Cycles \n            WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\", (annotation_name,))\n        assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\"SELECT VolumeId, AnnotationTypeLabelId, count(VolumeId) FROM\n                CycleIterations \n                INNER JOIN Volumes ON CycleIterations.FrameId = Volumes.FrameId \n                INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                WHERE AnnotationTypeLabelId in \n                    (\n                    SELECT Id from AnnotationTypeLabels \n                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    )\n                AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                AND CycleIteration = 0\n                GROUP BY VolumeId, AnnotationTypeLabelId\n                ORDER BY VolumeId\"\"\", (annotation_name, annotation_name))\n        info = cursor.fetchall()\n        volume_ids = [row[0] for row in info]\n        condition_ids = [row[1] for row in info]\n        count = [row[2] for row in info]\n\n    except Exception as e:\n        print(f\"Could not get_conditionIds_per_cycle_per_volumes because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return volume_ids, condition_ids, count\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_cycleIterations_per_frame","title":"<code>get_cycleIterations_per_frame(annotation_name)</code>","text":"<p>Returns a list of cycle iterations that correspond to each frame, list of corresponding frames. annotation_name: str</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_cycleIterations_per_frame(self, annotation_name):\n    \"\"\"\n    Returns a list of cycle iterations that correspond to each frame, list of corresponding frames.\n    annotation_name: str\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        # check that the annotation is a cycle\n        cursor.execute(\n            f\"\"\"SELECT Id FROM Cycles \n                                            WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\",\n            (annotation_name,))\n        assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\"SELECT CycleIterations.FrameId, CycleIteration FROM\n                CycleIterations \n                INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                WHERE AnnotationTypeLabelId in \n                    (\n                    SELECT Id from AnnotationTypeLabels \n                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    )\n                AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                ORDER BY CycleIterations.FrameId\"\"\", (annotation_name, annotation_name))\n        info = cursor.fetchall()\n        frame_ids = [row[0] for row in info]\n        cycle_its = [row[1] for row in info]\n\n    except Exception as e:\n        print(f\"Could not get_conditionIds_per_cycle_per_frame because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return frame_ids, cycle_its\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_cycleIterations_per_volumes","title":"<code>get_cycleIterations_per_volumes(annotation_name)</code>","text":"<p>Returns a list of cycleIterations that correspond to each volume, list of corresponding volumes and a count of the volume-iteration pairs annotation_name: str</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_cycleIterations_per_volumes(self, annotation_name):\n    \"\"\"\n    Returns a list of cycleIterations that correspond to each volume, list of corresponding volumes\n    and a count of the volume-iteration pairs\n    annotation_name: str\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        # check that the annotation is a cycle\n        cursor.execute(\n            f\"\"\"SELECT Id FROM Cycles \n                                WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\"\"\",\n            (annotation_name,))\n        assert len(cursor.fetchall()) == 1, f\"No Cycle for {annotation_name}\"\n\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\"SELECT VolumeId, CycleIteration, count(VolumeId) FROM\n                CycleIterations \n                INNER JOIN Volumes ON CycleIterations.FrameId = Volumes.FrameId \n                INNER JOIN Annotations ON CycleIterations.FrameId = Annotations.FrameId \n                WHERE AnnotationTypeLabelId in \n                    (\n                    SELECT Id from AnnotationTypeLabels \n                    WHERE AnnotationTypeId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                    )\n                AND CycleId = (SELECT Id from AnnotationTypes WHERE Name = ?)\n                GROUP BY VolumeId\n                ORDER BY VolumeId\"\"\", (annotation_name, annotation_name))\n        info = cursor.fetchall()\n        volume_ids = [row[0] for row in info]\n        cycle_its = [row[1] for row in info]\n        count = [row[2] for row in info]\n\n    except Exception as e:\n        print(f\"Could not get_cycleIterations_per_volumes because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return volume_ids, cycle_its, count\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_cycle_names","title":"<code>get_cycle_names()</code>","text":"<p>Returns the names of all the available cycles.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_cycle_names(self):\n    \"\"\"\n    Returns the names of all the available cycles.\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\"\"\"SELECT AnnotationTypes.Name \n                        FROM Cycles INNER JOIN AnnotationTypes \n                        ON Cycles.AnnotationTypeId = AnnotationTypes.Id\"\"\")\n        names = [name[0] for name in cursor.fetchall()]\n    except Exception as e:\n        print(f\"Could not get_cycle_names because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return names\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_data_dir","title":"<code>get_data_dir()</code>","text":"<p>Get data directory</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_data_dir(self):\n    \"\"\"\n    Get data directory\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT Value FROM Options \n                 WHERE Key = \"data_dir\" \"\"\"\n        )\n        data_dir = cursor.fetchone()[0]\n    except Exception as e:\n        print(f\"Could not get_data_dir because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return data_dir\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_fgf","title":"<code>get_fgf()</code>","text":"<p>Get frames per volume</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_fgf(self):\n    \"\"\"\n    Get frames per volume\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT Value FROM Options \n                 WHERE Key = \"num_head_frames\" \"\"\"\n        )\n        fdf = int(cursor.fetchone()[0])\n    except Exception as e:\n        print(f\"Could not get_fgf because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return fdf\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_file_names","title":"<code>get_file_names()</code>","text":"<p>Get the file names from the Files table.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_file_names(self):\n    \"\"\"\n    Get the file names from the Files table.\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT FileName FROM Files ORDER BY Id ASC\"\"\"\n        )\n        file_names = [row[0] for row in cursor.fetchall()]\n    except Exception as e:\n        print(f\"Could not get_file_names because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return file_names\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_fpv","title":"<code>get_fpv()</code>","text":"<p>Get frames per volume</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_fpv(self):\n    \"\"\"\n    Get frames per volume\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT Value FROM Options \n                 WHERE Key = \"frames_per_volume\" \"\"\"\n        )\n        fpv = int(cursor.fetchone()[0])\n    except Exception as e:\n        print(f\"Could not get_fpv because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return fpv\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_frames_per_file","title":"<code>get_frames_per_file()</code>","text":"<p>Get the file names from the Files table.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_frames_per_file(self):\n    \"\"\"\n    Get the file names from the Files table.\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT NumFrames FROM Files ORDER BY Id ASC\"\"\"\n        )\n        frames_per_file = [row[0] for row in cursor.fetchall()]\n    except Exception as e:\n        print(f\"Could not get_frames_per_file because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return frames_per_file\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_frames_per_volumes","title":"<code>get_frames_per_volumes(volume_ids, slices=None)</code>","text":"<p>Finds all the frames that correspond to the specified volumes. The order is not preserved! the volume correspond to sorted volumes in increasing order !</p> <p>Parameters:</p> Name Type Description Default <code>volume_ids</code> <code>List[int]</code> <p>a list of volume IDs</p> required <code>slices</code> <code>List[int]</code> <p>a list of slice IDs, order will not be preserved: will be sorted in increasing order</p> <code>None</code> <p>Returns:</p> Type Description <p>a list of frame IDs that correspond to the specified volumes and</p> <p>slices (if specified).</p> <p>order will not be preserved: frames will be sorted in increasing order</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_frames_per_volumes(self, volume_ids: List[int], slices: List[int] = None):\n    \"\"\"\n    Finds all the frames that correspond to the specified volumes.\n    The order is not preserved!\n    the volume correspond to sorted volumes in increasing order !\n\n    Args:\n        volume_ids: a list of volume IDs\n        slices: a list of slice IDs, order will not be preserved: will be sorted in increasing order\n\n    Returns:\n        a list of frame IDs that correspond to the specified volumes and\n        slices (if specified).\n        order will not be preserved: frames will be sorted in increasing order\n    \"\"\"\n    ids = list_of_int(volume_ids)\n\n    if slices is not None:\n        slices = list_of_int(slices)\n        ids.extend(slices)\n\n        # get the frames\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT FrameId FROM Volumes \n                                WHERE VolumeId IN ({', '.join(['?'] * len(volume_ids))}) \n                                AND SliceInVolume IN  ({', '.join(['?'] * len(slices))})\"\"\",\n                tuple(ids))\n            frame_ids = cursor.fetchall()\n        except Exception as e:\n            print(f\"Could not get_frames_per_volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n    else:\n        # get the frames\n        cursor = self.connection.cursor()\n        try:\n            # create a parameterised query with variable number of parameters\n            cursor.execute(\n                f\"\"\"SELECT FrameId FROM Volumes \n                    WHERE VolumeId IN ({', '.join(['?'] * len(ids))})\"\"\", tuple(ids))\n            frame_ids = cursor.fetchall()\n        except Exception as e:\n            print(f\"Could not get_frames_per_volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n    frame_ids = [frame[0] for frame in frame_ids]\n    # sort the frames: this is important when having -2 and -1 as volume ids. Otherwise -2 will be first.\n    frame_ids.sort()\n\n    return frame_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_options","title":"<code>get_options()</code>","text":"<p>Gets the information from the OPTIONS table. Returns a dictionary with the Key: Value from the table. ( Keys: 'data_dir', 'frames_per_volume', 'num_head_frames', 'num_tail_frames', 'num_full_volumes' )</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_options(self):\n    \"\"\"\n    Gets the information from the OPTIONS table.\n    Returns a dictionary with the Key: Value from the table.\n    ( Keys: 'data_dir', 'frames_per_volume', 'num_head_frames', 'num_tail_frames', 'num_full_volumes' )\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\n            f\"\"\"SELECT * FROM Options\"\"\"\n        )\n        options = {}\n        for row in cursor.fetchall():\n            options[row[0]] = row[1]\n\n    except Exception as e:\n        print(f\"Could not get_options because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return options\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_or_frames_per_annotations","title":"<code>get_or_frames_per_annotations(conditions)</code>","text":"<p>Chooses the frames that correspond to the specified conditions on annotation. Using \"or\" logic. Example : if you ask for frames corresponding to condition 1 and condition 2 , it will return such frames that either condition 1 is true OR condition 2 is True OR both are true.</p> <p>:param conditions: a list of conditions on the annotation labels in a form [(group, name),(group, name), ...] where group is a string for the annotation type and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')] :type conditions: [tuple] :return: :rtype:</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_or_frames_per_annotations(self, conditions):\n    \"\"\"\n    Chooses the frames that correspond to the specified conditions on annotation. Using \"or\" logic. Example : if\n    you ask for frames corresponding to condition 1 and condition 2 , it will return such frames that either\n    condition 1 is true OR condition 2 is True OR both are true.\n\n    :param conditions: a list of conditions on the annotation labels\n    in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n    and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]\n    :type conditions: [tuple]\n    :return:\n    :rtype:\n    \"\"\"\n\n    # get the frames\n    cursor = self.connection.cursor()\n    try:\n        # create list of label Ids\n        labels_ids = []\n        for label_info in conditions:\n            labels_ids.append(self._get_Id_from_AnnotationTypeLabels(label_info))\n        labels_ids = tuple(labels_ids)\n        n_labels = len(labels_ids)\n\n        # create a parameterised query with variable number of parameters\n        cursor.execute(\n            f\"\"\"SELECT FrameId FROM Annotations \n                WHERE AnnotationTypeLabelId IN ({', '.join(['?'] * n_labels)})\n                GROUP BY FrameId\"\"\", labels_ids)\n        frame_ids = cursor.fetchall()\n    except Exception as e:\n        print(f\"Could not _get_or_FrameId_from_Annotations because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    frame_ids = [frame[0] for frame in frame_ids]\n    return frame_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_volume_annotations","title":"<code>get_volume_annotations(volumes, annotation_names=None)</code>","text":"<p>Returns a dictionary with annotations for the specified volumes. If annotation_name is specified, it will return only the annotations for that annotation type. Otherwise, it will return all annotations for all annotation types.</p> <p>Parameters:</p> Name Type Description Default <code>volumes</code> <code>List[int]</code> <p>list of volume ids</p> required <code>annotation_names</code> <code>Optional[List[str]]</code> <p>list of names of the annotation type to return annotations for. If None, it will return annotations for all annotation types</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, List[str]]]</code> <p>dictionary with volumes ids and annotation labels for each volume and for each annotation type requested</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_volume_annotations(self, volumes: List[int],\n                           annotation_names: Optional[List[str]] = None) -&gt; Dict[str, Dict[str, List[str]]]:\n    \"\"\"\n    Returns a dictionary with annotations for the specified volumes. If annotation_name is specified, it will return only\n    the annotations for that annotation type. Otherwise, it will return all annotations for all annotation types.\n\n    Args:\n        volumes: list of volume ids\n        annotation_names: list of names of the annotation type to return annotations for. If None, it will return\n            annotations for all annotation types\n\n    Returns:\n        dictionary with volumes ids and annotation labels for each volume and for each annotation type requested\n    \"\"\"\n    # make sure volumes is a list of integers\n    volume_ids = list_of_int(volumes)\n\n    # get the annotations\n    cursor = self.connection.cursor()\n    try:\n        # check that the annotation type exists\n        cursor.execute(\n            f\"\"\"SELECT Name FROM AnnotationTypes\"\"\")\n        annotations = cursor.fetchall()\n        annotations = [annotation[0] for annotation in annotations]\n\n        if annotation_names is not None:\n            for name in annotation_names:\n                assert name in annotations, f\"Annotation type {name} does not exist\"\n            annotations = annotation_names\n\n        annotation_dict = {}\n        for annotation_name in annotations:\n            cursor.execute(\n                f\"\"\"SELECT Volumes.VolumeId, AnnotationTypeLabels.Name FROM\n                    AnnotationTypeLabels \n                    INNER JOIN Annotations ON AnnotationTypeLabels.Id = Annotations.AnnotationTypeLabelId \n                    INNER JOIN Volumes ON Annotations.FrameId = Volumes.FrameId\n                    INNER JOIN AnnotationTypes ON AnnotationTypes.Id = AnnotationTypeLabels.AnnotationTypeId\n                    WHERE AnnotationTypes.Name = ?\n                    AND Volumes.VolumeId in ({', '.join(['?'] * len(volume_ids))})\n                    ORDER BY Volumes.VolumeId\"\"\",\n                [annotation_name] + volume_ids)\n\n            info = cursor.fetchall()\n            volume_ids = [row[0] for row in info]\n            labels = [row[1] for row in info]\n            annotation_dict[annotation_name] = {'volume_ids': volume_ids, 'labels': labels}\n\n    except Exception as e:\n        print(f\"Could not get_volume_annotations because {e}\")\n        raise e\n    finally:\n        cursor.close()\n    return annotation_dict\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.get_volume_list","title":"<code>get_volume_list()</code>","text":"<p>Returns a list of all the volumes. :return: list of all the volumes :rtype: [int]</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def get_volume_list(self):\n    \"\"\"\n    Returns a list of all the volumes.\n    :return: list of all the volumes\n    :rtype: [int]\n    \"\"\"\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(f\"SELECT DISTINCT VolumeId FROM Volumes\")\n        volume_ids = [volume[0] for volume in cursor.fetchall()]\n    except Exception as e:\n        print(f\"Could not get total number of frames from Frames because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    return volume_ids\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.load","title":"<code>load(file_name)</code>  <code>classmethod</code>","text":"<p>Load the contents of a database file on disk to a transient copy in memory without modifying the file</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>@classmethod\ndef load(cls, file_name):\n    \"\"\"\n    Load the contents of a database file on disk to a\n    transient copy in memory without modifying the file\n    \"\"\"\n    disk_db = connect(file_name)\n    memory_db = connect(':memory:')\n    disk_db.backup(memory_db)\n    disk_db.close()\n    # Now use `memory_db` without modifying disk db\n    return cls(memory_db)\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbReader.prepare_frames_for_loading","title":"<code>prepare_frames_for_loading(frames)</code>","text":"<p>Finds all the information needed 1) to load the frames 2) and shape them back into volumes/slices. For each frame returns the image file, frame location on the image and corresponding volume.</p> <p>The order is not preserved! the volume correspond to sorted volumes in increasing order !</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>List[int]</code> <p>a list of frame IDs</p> required <p>Returns:</p> Type Description <code>str</code> <p>three lists, the length of the frames : data directory, file names,</p> <code>List[str]</code> <p>image files, frame location on the image, volumes.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def prepare_frames_for_loading(self, frames: List[int]) -&gt; \\\n        Tuple[str, List[str], List[str], List[int], List[int]]:\n    \"\"\"\n    Finds all the information needed\n    1) to load the frames\n    2) and shape them back into volumes/slices.\n    For each frame returns the image file,\n    frame location on the image and corresponding volume.\n\n    The order is not preserved!\n    the volume correspond to sorted volumes in increasing order !\n\n    Args:\n        frames: a list of frame IDs\n\n    Returns:\n         three lists, the length of the frames : data directory, file names,\n         image files, frame location on the image, volumes.\n    \"\"\"\n    # TODO : break into functions that get the file locations and the stuff relevant to the frames\n    # TODO : make one \" prepare volumes \" for loading?\n\n    n_frames = len(frames)\n\n    # get the frames\n    cursor = self.connection.cursor()\n    try:\n        # get data directory\n        cursor.execute(\n            f\"\"\"SELECT Value\n                FROM Options\n                WHERE Key = \"data_dir\" \"\"\")\n        data_dir = cursor.fetchone()[0]\n\n        # get file_names\n        cursor.execute(\n            f\"\"\"SELECT FileName\n                FROM Files \"\"\")\n        file_names = cursor.fetchall()\n\n        # get info for every frame\n        cursor.execute(\n            f\"\"\"SELECT \n                    FileId,\n                    FrameInFile,\n                    VolumeId\n                FROM \n                    Frames\n                    INNER JOIN Volumes \n                    ON Frames.Id = Volumes.FrameId\n                WHERE FrameId IN ({', '.join(['?'] * n_frames)})\"\"\", tuple(frames))\n        frame_info = cursor.fetchall()\n\n    except Exception as e:\n        print(f\"Could not prepare_frames_for_loading because {e}\")\n        raise e\n    finally:\n        cursor.close()\n\n    file_names = [row[0] for row in file_names]\n\n    file_ids = [row[0] for row in frame_info]\n    frame_in_file = [row[1] for row in frame_info]\n    volumes = [row[2] for row in frame_info]\n\n    return data_dir, file_names, file_ids, frame_in_file, volumes\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter","title":"<code>DbWriter</code>","text":"<p>Writes information to the database. Database interface that abstracts the SQLite calls.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>connection to the SQL database</p> required Source code in <code>src/vodex/dbmethods.py</code> <pre><code>class DbWriter:\n    \"\"\"\n    Writes information to the database.\n    Database interface that abstracts the SQLite calls.\n\n    Args:\n        connection: connection to the SQL database\n    \"\"\"\n\n    def __init__(self, connection: Connection):\n        self.connection = connection\n        self.connection.execute(\"PRAGMA foreign_keys = 1\")\n\n    def save(self, file_name: str):\n        \"\"\"\n        Backup a database to a file.\n        Will CLOSE connection to the database in memory!\n        Args:\n            file_name : the name of the file to save database to, EX.: 'databasename.db'\n        \"\"\"\n\n        def progress(status, remaining, total):\n            print(f'Copied {total - remaining} of {total} pages...')\n\n        backup_db = connect(file_name)\n        with backup_db:\n            self.connection.backup(backup_db, progress=progress)\n        # self.connection.close()\n        backup_db.close()\n\n    @classmethod\n    def create(cls):\n        \"\"\"\n        Creates an empty DB for the experiment in memory.\n        \"\"\"\n        # For an in-memory only database:\n        memory_db = connect(':memory:')\n        return cls(memory_db)\n\n    @classmethod\n    def load(cls, file_name: str):\n        \"\"\"\n        Load the contents of a database file on disk to a\n        transient copy in memory without modifying the file.\n        \"\"\"\n        disk_db = connect(file_name)\n        memory_db = connect(':memory:')\n        disk_db.backup(memory_db)\n        disk_db.close()\n        # Now use `memory_db` without modifying disk db\n        return cls(memory_db)\n\n    def populate(self, volumes: VolumeManager = None, annotations: List[Annotation] = None):\n        \"\"\"\n        Creates the tables if they don't exist and fills with the provided data.\n        Args:\n            volumes: mapping of frames to volumes, and to slices in volumes, frames per volume\n            annotations: mapping of frames to labels, list of annotations\n        \"\"\"\n        # will only create if they don't exist\n        self._create_tables()\n        # TODO : write cases for files and frames not None\n\n        if volumes is not None:\n            self._populate_Options(volumes.file_manager, volumes)\n            self._populate_Files(volumes.file_manager)\n            self._populate_Frames(volumes.frame_manager)\n            self._populate_Volumes(volumes)\n\n        if annotations is not None:\n            self.add_annotations(annotations)\n\n    def add_annotations(self, annotations: List[Annotation]):\n        \"\"\"\n        Adds a list of annotations to the database.\n        Does NOT save the database after adding.\n        To keep this change in the future, you need to save the database after adding.\n        Args:\n            annotations: mapping of frames to labels, list of annotations\n        \"\"\"\n        # TODO : add list checking\n        for annotation in annotations:\n            self._populate_AnnotationTypes(annotation)\n            self._populate_AnnotationTypeLabels(annotation)\n            self._populate_Annotations(annotation)\n            if annotation.cycle is not None:\n                self._populate_Cycles(annotation)\n                self._populate_CycleIterations(annotation)\n\n    def delete_annotation(self, name: str):\n        \"\"\"\n        Deletes annotation from all the tables.\n        Deletion by \"ON DELETE CASCADE\" from AnnotationTypes, AnnotationTypeLabels, Annotations,\n        Cycles, CycleIterations.\n        \"\"\"\n        name = (name,)\n        # get the volumes\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\"\"\"SELECT * FROM AnnotationTypes WHERE Name = ?\"\"\", name)\n            result = cursor.fetchall()\n            assert len(result) == 1, f\"No annotation {name} in the database.\"\n\n            cursor.execute(\n                f\"\"\"DELETE FROM AnnotationTypes \n                            WHERE Name = ?\"\"\", name)\n        except Exception as e:\n            print(f\"Could not delete_annotation because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _get_n_frames(self) -&gt; int:\n        \"\"\"\n        Queries and returns the total number of frames in the experiment.\n        Used when creating Annotations and Cycles.\n        \"\"\"\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(f\"SELECT COUNT(*) FROM Frames\")\n            n_frames = cursor.fetchone()[0]\n        except Exception as e:\n            print(f\"Could not get total number of frames from Frames because {e}\")\n            raise e\n        finally:\n            cursor.close()\n        return n_frames\n\n    def _create_tables(self):\n\n        # TODO : change UNIQUE(a, b)\n        # into primary key over both columns a and b where appropriate\n\n        db_cursor = self.connection.cursor()\n\n        sql_create_Options_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"Options\" (\n            \"Key\"\tTEXT NOT NULL UNIQUE,\n            \"Value\"\tTEXT NOT NULL,\n            \"Description\"\tTEXT,\n            PRIMARY KEY(\"Key\")\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_Options_table)\n\n        sql_create_Files_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"Files\" (\n            \"Id\"\tINTEGER NOT NULL UNIQUE,\n            \"FileName\"\tTEXT NOT NULL UNIQUE,\n            \"NumFrames\"\tINTEGER NOT NULL,\n            PRIMARY KEY(\"Id\" AUTOINCREMENT)\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_Files_table)\n\n        sql_create_AnnotationTypes_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"AnnotationTypes\" (\n            \"Id\"\tINTEGER NOT NULL UNIQUE,\n            \"Name\"\tTEXT NOT NULL UNIQUE,\n            \"Description\"\tTEXT,\n            PRIMARY KEY(\"Id\" AUTOINCREMENT)\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_AnnotationTypes_table)\n\n        sql_create_Frames_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"Frames\" (\n            \"Id\"\tINTEGER NOT NULL UNIQUE,\n            \"FrameInFile\"\tINTEGER NOT NULL,\n            \"FileId\"\tINTEGER NOT NULL,\n            PRIMARY KEY(\"Id\" AUTOINCREMENT),\n            FOREIGN KEY(\"FileId\") REFERENCES \"Files\"(\"Id\")\n            UNIQUE(\"FrameInFile\", \"FileId\")\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_Frames_table)\n\n        sql_create_Cycles_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"Cycles\" (\n            \"Id\"\tINTEGER NOT NULL UNIQUE,\n            \"AnnotationTypeId\"\tINTEGER NOT NULL UNIQUE,\n            \"Structure\"\tTEXT NOT NULL,\n            FOREIGN KEY(\"AnnotationTypeId\") REFERENCES \"AnnotationTypes\"(\"Id\") ON DELETE CASCADE,\n            PRIMARY KEY(\"Id\" AUTOINCREMENT)\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_Cycles_table)\n\n        sql_create_AnnotationTypeLabels_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"AnnotationTypeLabels\" (\n            \"Id\"\tINTEGER NOT NULL UNIQUE,\n            \"AnnotationTypeId\"\tINTEGER NOT NULL,\n            \"Name\"\tTEXT NOT NULL,\n            \"Description\"\tTEXT,\n            PRIMARY KEY(\"Id\" AUTOINCREMENT),\n            FOREIGN KEY(\"AnnotationTypeId\") REFERENCES \"AnnotationTypes\"(\"Id\") ON DELETE CASCADE,\n            UNIQUE(\"AnnotationTypeId\",\"Name\")\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_AnnotationTypeLabels_table)\n\n        sql_create_Annotations_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"Annotations\" (\n            \"FrameId\"\tINTEGER NOT NULL,\n            \"AnnotationTypeLabelId\"\tINTEGER NOT NULL,\n            FOREIGN KEY(\"FrameId\") REFERENCES \"Frames\"(\"Id\"),\n            FOREIGN KEY(\"AnnotationTypeLabelId\") REFERENCES \"AnnotationTypeLabels\"(\"Id\") ON DELETE CASCADE,\n            UNIQUE(\"FrameId\",\"AnnotationTypeLabelId\")\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_Annotations_table)\n\n        sql_create_CycleIterations_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"CycleIterations\" (\n            \"FrameId\"\tINTEGER NOT NULL,\n            \"CycleId\"\tINTEGER NOT NULL,\n            \"CycleIteration\"\tINTEGER NOT NULL,\n            FOREIGN KEY(\"CycleId\") REFERENCES \"Cycles\"(\"Id\") ON DELETE CASCADE,\n            FOREIGN KEY(\"FrameId\") REFERENCES \"Frames\"(\"Id\")\n            UNIQUE(\"FrameId\",\"CycleId\")\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_CycleIterations_table)\n\n        sql_create_Volumes_table = \"\"\"\n            CREATE TABLE IF NOT EXISTS \"Volumes\" (\n            \"FrameId\"\tINTEGER NOT NULL UNIQUE,\n            \"VolumeId\"\tINTEGER NOT NULL,\n            \"SliceInVolume\"\tINTEGER NOT NULL,\n            PRIMARY KEY(\"FrameId\" AUTOINCREMENT),\n            FOREIGN KEY(\"FrameId\") REFERENCES \"Frames\"(\"Id\")\n            UNIQUE(\"VolumeId\",\"SliceInVolume\")\n            )\n            \"\"\"\n        db_cursor.execute(sql_create_Volumes_table)\n\n        db_cursor.close()\n\n    def _populate_Options(self, file_manager: FileManager, volume_manager: VolumeManager):\n        \"\"\"\n        Populates the Options table (a dictionary with key - value pairs).\n        Learning resources:\n            another way of dealing with Errors :\n            https://www.w3resource.com/python-exercises/sqlite/python-sqlite-exercise-6.php\n        Args:\n            file_manager: FileManager object that provides the data to populate the tables.\n            volume_manager: VolumeManager object that provides the data to populate the tables.\n        \"\"\"\n        row_data = [(\"data_dir\", file_manager.data_dir.as_posix()),\n                    (\"frames_per_volume\", volume_manager.fpv),\n                    (\"num_head_frames\", volume_manager.n_head),\n                    (\"num_tail_frames\", volume_manager.n_tail),\n                    (\"num_full_volumes\", volume_manager.full_volumes)]\n\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO Options (Key, Value) VALUES (?, ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to Options because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_Files(self, file_manager: FileManager):\n        \"\"\"\n        Populates the Files table with\n        file_name : list with filenames per file (str), and\n        num_frames : list with number of frames per file (int)\n        Args:\n            file_manager: FileManager object that provides the data to populate the tables.\n        \"\"\"\n        row_data = [(filename, frames) for\n                    filename, frames in zip(file_manager.file_names, file_manager.num_frames)]\n\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO Files (FileName, NumFrames) VALUES (?, ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to Files because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_Frames(self, frame_manager: FrameManager):\n        \"\"\"\n        Populates the Frames table with\n        frame_in_file and frame_to_file mapping.\n\n        Learning Resourses:\n            Something like\n            insert into tab2 (id_customers, value)\n            values ((select id from tab1 where customers='john'), 'alfa');\n            but in SQLite\n            https://www.tutorialspoint.com/sqlite/sqlite_insert_query.htm\n\n        Args:\n            frame_manager: FrameManager object that provides the data to populate the tables.\n        \"\"\"\n        # adding +1 since the frame_to_file is indexing files from 0 and sqlite gave files IDs from 1\n        row_data = [(frame_in_file, frame_to_file + 1) for\n                    frame_in_file, frame_to_file in zip(frame_manager.frame_in_file, frame_manager.frame_to_file)]\n\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO Frames (FrameInFile, FileId) VALUES (?, ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to Frames because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_Volumes(self, volume_manager: VolumeManager):\n        \"\"\"\n        Populates the Volumes table with\n        volume_id and slice_in_volume mapping.\n\n        Args:\n            volume_manager: VolumeManager object that provides the data to populate the tables.\n        \"\"\"\n        row_data = [(volume_id, slice_in_volume) for\n                    volume_id, slice_in_volume in zip(volume_manager.frame_to_vol, volume_manager.frame_to_z)]\n\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO Volumes (VolumeId, SliceInVolume) VALUES (?, ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to Volumes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_AnnotationTypes(self, annotation: Annotation):\n        \"\"\"\n        Populates the AnnotationTypes table with\n        annotation.name, annotation.info mapping.\n\n        Args:\n            volume_manager: VolumeManager object that provides the data to populate the tables.\n        \"\"\"\n        row_data = (annotation.name, annotation.info)\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                \"INSERT INTO AnnotationTypes (Name, Description) VALUES (?, ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to AnnotationTypes because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_AnnotationTypeLabels(self, annotation):\n\n        row_data = [(label.group, label.name, label.description)\n                    for label in annotation.labels.states]\n\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO AnnotationTypeLabels (AnnotationTypeId, Name, Description) \" +\n                \"VALUES((SELECT Id FROM AnnotationTypes WHERE Name = ?), ?, ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to AnnotationTypeLabels because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_Annotations(self, annotation):\n        n_frames = self._get_n_frames()\n        assert n_frames == annotation.n_frames, f\"Number of frames in the annotation, {annotation.n_frames},\" \\\n                                                f\"doesn't match\" \\\n                                                f\" the expected number of frames {n_frames}\"\n        frames = range(n_frames)\n        row_data = [(frame + 1, label.name, label.group)\n                    for frame, label in zip(frames, annotation.frame_to_label)]\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO Annotations (FrameId, AnnotationTypeLabelId) \" +\n                \"VALUES(?, (SELECT Id FROM AnnotationTypeLabels \"\n                \"WHERE Name = ? \" +\n                \"AND AnnotationTypeId = (SELECT Id FROM AnnotationTypes \" +\n                \"WHERE Name = ?)))\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write group {annotation.name} to Annotations because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_Cycles(self, annotation):\n        \"\"\"\n        \"\"\"\n        assert annotation.cycle is not None, \"Annotation is not a Cycle\"\n        row_data = (annotation.name, annotation.cycle.to_json())\n        cursor = self.connection.cursor()\n        try:\n            cursor.execute(\n                \"INSERT INTO Cycles (AnnotationTypeId, Structure) \" +\n                \"VALUES((SELECT Id FROM AnnotationTypes WHERE Name = ?), ?)\",\n                row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write to Cycles because {e}\")\n            raise e\n        finally:\n            cursor.close()\n\n    def _populate_CycleIterations(self, annotation):\n        n_frames = self._get_n_frames()\n        assert n_frames == annotation.n_frames, f\"Number of frames in the annotation, {annotation.n_frames},\" \\\n                                                f\"doesn't match\" \\\n                                                f\" the expected number of frames {n_frames}\"\n        # get cycle id by annotation type\n        cursor = self.connection.cursor()\n        cursor.execute(\n            \"SELECT Id FROM Cycles \" +\n            \"WHERE AnnotationTypeId = (SELECT Id FROM AnnotationTypes \" +\n            \"WHERE Name = ?)\", (annotation.name,))\n        cycle_id = cursor.fetchone()\n        assert cycle_id is not None, \"Fill out AnnotationTypes and Cycles first.\"\n        cursor.close()\n\n        # prepare rows\n        frames = range(n_frames)\n        row_data = [(frame + 1, cycle_id[0], iteration)\n                    for frame, iteration in zip(frames, annotation.frame_to_cycle)]\n\n        # insert into CycleIterations\n        cursor = self.connection.cursor()\n        try:\n            cursor.executemany(\n                \"INSERT INTO CycleIterations (FrameId, CycleId, CycleIteration) \" +\n                \"VALUES(?, ?,?)\", row_data)\n            self.connection.commit()\n        except Exception as e:\n            print(f\"Could not write group {annotation.name} to CycleIterations because {e}\")\n            raise e\n        finally:\n            cursor.close()\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter.add_annotations","title":"<code>add_annotations(annotations)</code>","text":"<p>Adds a list of annotations to the database. Does NOT save the database after adding. To keep this change in the future, you need to save the database after adding. Args:     annotations: mapping of frames to labels, list of annotations</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def add_annotations(self, annotations: List[Annotation]):\n    \"\"\"\n    Adds a list of annotations to the database.\n    Does NOT save the database after adding.\n    To keep this change in the future, you need to save the database after adding.\n    Args:\n        annotations: mapping of frames to labels, list of annotations\n    \"\"\"\n    # TODO : add list checking\n    for annotation in annotations:\n        self._populate_AnnotationTypes(annotation)\n        self._populate_AnnotationTypeLabels(annotation)\n        self._populate_Annotations(annotation)\n        if annotation.cycle is not None:\n            self._populate_Cycles(annotation)\n            self._populate_CycleIterations(annotation)\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter.create","title":"<code>create()</code>  <code>classmethod</code>","text":"<p>Creates an empty DB for the experiment in memory.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>@classmethod\ndef create(cls):\n    \"\"\"\n    Creates an empty DB for the experiment in memory.\n    \"\"\"\n    # For an in-memory only database:\n    memory_db = connect(':memory:')\n    return cls(memory_db)\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter.delete_annotation","title":"<code>delete_annotation(name)</code>","text":"<p>Deletes annotation from all the tables. Deletion by \"ON DELETE CASCADE\" from AnnotationTypes, AnnotationTypeLabels, Annotations, Cycles, CycleIterations.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def delete_annotation(self, name: str):\n    \"\"\"\n    Deletes annotation from all the tables.\n    Deletion by \"ON DELETE CASCADE\" from AnnotationTypes, AnnotationTypeLabels, Annotations,\n    Cycles, CycleIterations.\n    \"\"\"\n    name = (name,)\n    # get the volumes\n    cursor = self.connection.cursor()\n    try:\n        cursor.execute(\"\"\"SELECT * FROM AnnotationTypes WHERE Name = ?\"\"\", name)\n        result = cursor.fetchall()\n        assert len(result) == 1, f\"No annotation {name} in the database.\"\n\n        cursor.execute(\n            f\"\"\"DELETE FROM AnnotationTypes \n                        WHERE Name = ?\"\"\", name)\n    except Exception as e:\n        print(f\"Could not delete_annotation because {e}\")\n        raise e\n    finally:\n        cursor.close()\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter.load","title":"<code>load(file_name)</code>  <code>classmethod</code>","text":"<p>Load the contents of a database file on disk to a transient copy in memory without modifying the file.</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>@classmethod\ndef load(cls, file_name: str):\n    \"\"\"\n    Load the contents of a database file on disk to a\n    transient copy in memory without modifying the file.\n    \"\"\"\n    disk_db = connect(file_name)\n    memory_db = connect(':memory:')\n    disk_db.backup(memory_db)\n    disk_db.close()\n    # Now use `memory_db` without modifying disk db\n    return cls(memory_db)\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter.populate","title":"<code>populate(volumes=None, annotations=None)</code>","text":"<p>Creates the tables if they don't exist and fills with the provided data. Args:     volumes: mapping of frames to volumes, and to slices in volumes, frames per volume     annotations: mapping of frames to labels, list of annotations</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def populate(self, volumes: VolumeManager = None, annotations: List[Annotation] = None):\n    \"\"\"\n    Creates the tables if they don't exist and fills with the provided data.\n    Args:\n        volumes: mapping of frames to volumes, and to slices in volumes, frames per volume\n        annotations: mapping of frames to labels, list of annotations\n    \"\"\"\n    # will only create if they don't exist\n    self._create_tables()\n    # TODO : write cases for files and frames not None\n\n    if volumes is not None:\n        self._populate_Options(volumes.file_manager, volumes)\n        self._populate_Files(volumes.file_manager)\n        self._populate_Frames(volumes.frame_manager)\n        self._populate_Volumes(volumes)\n\n    if annotations is not None:\n        self.add_annotations(annotations)\n</code></pre>"},{"location":"api/dbmethods/#src.vodex.dbmethods.DbWriter.save","title":"<code>save(file_name)</code>","text":"<p>Backup a database to a file. Will CLOSE connection to the database in memory! Args:     file_name : the name of the file to save database to, EX.: 'databasename.db'</p> Source code in <code>src/vodex/dbmethods.py</code> <pre><code>def save(self, file_name: str):\n    \"\"\"\n    Backup a database to a file.\n    Will CLOSE connection to the database in memory!\n    Args:\n        file_name : the name of the file to save database to, EX.: 'databasename.db'\n    \"\"\"\n\n    def progress(status, remaining, total):\n        print(f'Copied {total - remaining} of {total} pages...')\n\n    backup_db = connect(file_name)\n    with backup_db:\n        self.connection.backup(backup_db, progress=progress)\n    # self.connection.close()\n    backup_db.close()\n</code></pre>"},{"location":"api/experiment/","title":"vodex.experiment","text":"<p>This module contains the 'Experiment' class, which provides a summary of the information about an experiment. The class can initialise, save, and load the database, search for frames based on volumes or annotations, and load image data using the appropriate loader. To initialise the database, it integrates the information from the FileManager, FrameManager, VolumeManager, as well as Annotations, to create a database.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>The class can initialise, save, and load the database, search for frames based on volumes or annotations, and load image data using the appropriate loader. To initialise the database, it integrates the information from the File, Frame, and Volume managers, as well as Annotations, to create a database.</p> <p>Parameters:</p> Name Type Description Default <code>db_reader</code> <code>DbReader</code> <p>a DbReader object connected to the database with the experiment description.</p> required <p>Attributes:</p> Name Type Description <code>db</code> <p>a DbReader object connected to the database with the experiment description.</p> <code>loader</code> <code>ImageLoader</code> <p>an ImageLoader object to load metadata and image data from files.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>class Experiment:\n    \"\"\"\n    The class can initialise, save, and load the database, search for frames based on volumes or annotations, and load image\n    data using the appropriate loader. To initialise the database, it integrates the information from the File, Frame,\n    and Volume managers, as well as Annotations, to create a database.\n\n    Args:\n        db_reader: a DbReader object connected to the database with the experiment description.\n\n    Attributes:\n        db: a DbReader object connected to the database with the experiment description.\n        loader: an ImageLoader object to load metadata and image data from files.\n    \"\"\"\n\n    def __init__(self, db_reader: DbReader):\n        \"\"\"\n        Initialize the experiment with the given DbReader object.\n        \"\"\"\n\n        assert isinstance(db_reader, DbReader), \"Need DbReader to initialise the Experiment\"\n\n        self.db = db_reader\n        # will add the loader the first time you are loading anything\n        # in load_frames() or load_volumes()\n        self.loader: ImageLoader\n\n    @property\n    def n_frames(self) -&gt; int:\n        \"\"\"\n        Returns the total number of frames in the experiment.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return self.db.get_n_frames()\n\n    @property\n    def n_volumes(self) -&gt; int:\n        \"\"\"\n        Returns the total number of volumes in the experiment.\n        This might include partial volumes at the beginning of the experiment (ID: -1)\n        and at the end of the experiment (ID : -2).\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return len(self.db.get_volume_list())\n\n    @property\n    def n_full_volumes(self) -&gt; int:\n        \"\"\"\n        Returns the total number of full volumes in the experiment.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        options = self.db.get_options()\n        return int(options['num_full_volumes'])\n\n    @property\n    def n_head_frames(self) -&gt; int:\n        \"\"\"\n        Returns the number of frames in the first partial volume,\n        or 0 if there is no partial volume at the beginning.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        options = self.db.get_options()\n        return int(options['num_head_frames'])\n\n    @property\n    def n_tail_frames(self) -&gt; int:\n        \"\"\"\n        Returns the number of frames in the last partial volume,\n        or 0 if there is no partial volume at the end.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        options = self.db.get_options()\n        return int(options['num_tail_frames'])\n\n    @property\n    def volumes(self) -&gt; npt.NDArray:\n        \"\"\"\n        Returns the list of volume IDs in the experiment.\n        This might include partial volumes at the beginning of the experiment (ID: -1)\n        and at the end of the experiment (ID : -2).\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        volume_list = np.array(self.db.get_volume_list())\n        if np.sum(volume_list == -1) &gt; 0:\n            warnings.warn(f\"The are some frames at the beginning of the recording \"\n                          f\"that don't correspond to a full volume.\")\n        if np.sum(volume_list == -2) &gt; 0:\n            warnings.warn(f\"The are some frames at the end of the recording \"\n                          f\"that don't correspond to a full volume.\")\n        return volume_list\n\n    @property\n    def full_volumes(self) -&gt; npt.NDArray:\n        \"\"\"\n        Returns the list of full volume IDs in the experiment.\n        \"\"\"\n        volume_list = self.volumes\n        return volume_list[volume_list &gt;= 0]\n\n    def batch_volumes(self, batch_size: int, overlap: int = 0,\n                      volumes: Optional[Union[npt.NDArray, List[int]]] = None,\n                      full_only: bool = True) -&gt; List[List[int]]:\n        \"\"\"\n        Returns a list of volume IDs that can be used to load batches of volumes.\n        The batch size is given in number of volumes, and the overlap is given in number of volumes.\n        If full_only is True, only full volumes are returned.\n\n        Args:\n            batch_size: the number of volumes in each batch.\n            overlap: the number of volumes that overlap between batches.\n            volumes: the list of volumes to be batched.\n            full_only: if True, only full volumes are returned. If volumes is not None, this argument is ignored.\n\n        Returns:\n            A list of lists (n_batches x batch_size) of volume IDs that can be used to load batches of volumes.\n        \"\"\"\n        if overlap &gt;= batch_size:\n            raise ValueError(\"Overlap must be smaller than batch size.\")\n\n        if volumes is not None:\n            volume_list = volumes\n        else:\n            if full_only:\n                volume_list = self.full_volumes\n            else:\n                volume_list = self.volumes\n\n        # turn into a list if numpy array\n        if isinstance(volume_list, np.ndarray):\n            volume_list = volume_list.tolist()\n\n        batch_list = []\n        for i in range(0, len(volume_list), batch_size - overlap):\n            batch_list.append(volume_list[i:i + batch_size])\n        return batch_list\n\n    @property\n    def annotations(self) -&gt; List[str]:\n        \"\"\"\n        Returns the list of annotation names that have been added to the experiment.\n        \"\"\"\n        return self.db.get_Names_from_AnnotationTypes()\n\n    @property\n    def labels(self) -&gt; dict:\n        \"\"\"\n        Returns a dict with annotation names, labels and label descriptions\n        that have been added to the experiment.\n        \"\"\"\n        annotation_names = self.annotations\n        label_dict = {}\n        for annotation_name in annotation_names:\n            label_names, descriptions = self.db.get_Name_and_Description_from_AnnotationTypeLabels(annotation_name)\n            label_dict[annotation_name] = {\n                'labels': label_names,\n                'descriptions': descriptions}\n        return label_dict\n\n    @property\n    def labels_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns a dataframe with annotation names, labels and label descriptions\n        that have been added to the experiment.\n        \"\"\"\n        annotation_names = self.annotations\n        label_dict = {'annotation': [], 'label': [], 'description': []}\n        for annotation_name in annotation_names:\n            label_names, descriptions = self.db.get_Name_and_Description_from_AnnotationTypeLabels(annotation_name)\n            label_dict['annotation'].extend([annotation_name] * len(label_names))\n            label_dict['label'].extend(label_names)\n            label_dict['description'].extend([descriptions[key] for key in label_names])\n        return pd.DataFrame(label_dict)\n\n    @property\n    def cycles(self) -&gt; List[str]:\n        \"\"\"\n        Returns the list of cycle names that have been added to the experiment.\n        \"\"\"\n        return self.db.get_cycle_names()\n\n    @property\n    def file_names(self) -&gt; List[str]:\n        \"\"\"\n        Returns the list of file names that have been added to the experiment.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return self.db.get_file_names()\n\n    @property\n    def frames_per_file(self) -&gt; List[int]:\n        \"\"\"\n        Returns the list of frames per file that have been added to the experiment.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return self.db.get_frames_per_file()\n\n    @property\n    def data_dir(self) -&gt; str:\n        \"\"\"\n        Returns the path to the data directory.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return self.db.get_data_dir()\n\n    @property\n    def frames_per_volume(self) -&gt; int:\n        \"\"\"\n        Returns the number of frames per volume.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return self.db.get_fpv()\n\n    @property\n    def starting_slice(self) -&gt; int:\n        \"\"\"\n        Returns the number of the first slice in the experiment.\n        \"\"\"\n        # TODO: cash this value when property is called for the first time\n        return self.db.get_fgf()  # fgf stands for first good frame\n\n    @classmethod\n    def create(cls, volume_manager: VolumeManager, annotations: List[Annotation], verbose: bool = False):\n        \"\"\"\n        Creates a database instance from the core classes and initialises the experiment.\n\n        Args:\n            volume_manager: VolumeManager object that summarises the information about the image data.\n            annotations: list of annotations to add to the experiment descriptions.\n            verbose: whether to print the information about Filemanager, VolumeManager and Annotations on the screen.\n\n        Returns:\n            (Experiment): initialised experiment.\n        \"\"\"\n        if verbose:\n            print(volume_manager.file_manager)\n            print(volume_manager)\n            for annotation in annotations:\n                print(annotation)\n                if annotation.cycle is not None:\n                    print(annotation.cycle_info())\n\n        db = DbWriter.create()\n        db.populate(volumes=volume_manager, annotations=annotations)\n        db_reader = DbReader(db.connection)\n        return cls(db_reader)\n\n    @classmethod\n    def from_dir(cls, dir_name: Union[Path, str], frames_per_volume: int,\n                 starting_slice: int = 0, verbose: bool = False):\n        \"\"\"\n        Creates a database instance from a directory and initialises the experiment.\n        The directory should contain the image files.\n        Annotations are not initialised, but can be added later.\n        \"\"\"\n        # initialise volume manager\n        volume_manager = VolumeManager.from_dir(dir_name, frames_per_volume, fgf=starting_slice)\n        return cls.create(volume_manager, [], verbose)\n\n    def save(self, file_name: Union[Path, str]):\n        \"\"\"\n        Saves a database into a file.\n\n        Args:\n            file_name: full path to a file to save database.\n                (Usually the filename would end with .db)\n        \"\"\"\n        DbWriter(self.db.connection).save(file_name)\n\n    def add_annotations(self, annotations: List[Annotation]):\n        \"\"\"\n        Adds annotations to existing experiment.\n        Does NOT save the changes to disc! run self.save() to save.\n\n        Args:\n            annotations: a list of annotations to add to the database.\n        \"\"\"\n        DbWriter(self.db.connection).add_annotations(annotations)\n\n    def add_annotations_from_df(self, annotation_df: pd.DataFrame,\n                                cycles: Union[List[str], bool] = False,\n                                timing_conversion: Optional[dict] = None,\n                                groups: Optional[str] = None,\n                                info: Optional[dict] = None):\n        \"\"\"\n        Adds annotations to existing experiment from a data frame.\n        Does NOT save the changes to disc! run self.save() to save.\n\n        Args:\n            annotation_df: a dataframe with the annotation information\n            cycles: a list of the annotation names that are cycles or a boolean.\n                If False, all annotations are assumed to be timelines.\n                If True, all annotations are assumed to be cycles.\n                Specified as {'cycles': }\n            timing_conversion: a dictionary to convert the timing of the annotation.\n                For example, if you want to convert the timing from frames to seconds,\n                and you were recording at 30 frames per second, you can use\n                timing_conversion = {'frames': 1, 'seconds': 1/30}\n                You can list multiple units in the dictionary, and the timing will be converted to all of them,\n                for example if there are also 10 frames per volume, you can use:\n                timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n                You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n                but it must be consistent with the other units. the rest of the values.\n                for example this is valid for the example above:\n                timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n                If timing_conversion is None, then the timing is not converted\n                and 'duration_frames' must be provided in the dataframe.\n            groups: the group of the annotation if there are multiple groups in the dataframe.\n                If None, all groups are added.\n            info: additional information about the annotation, dictionary with keys:\n                'annotation name': information\n        \"\"\"\n        n_frames = self.db.get_n_frames()\n\n        if groups is None:\n            groups = annotation_df['group'].unique()\n\n        annotations = []\n        for group in groups:\n            group_df = annotation_df[annotation_df['group'] == group]\n\n            if cycles is True or (isinstance(cycles, list) and group in cycles):\n                is_cycle = True\n            else:\n                is_cycle = False\n\n            if info is not None and group in info:\n                group_info = info[group]\n            else:\n                group_info = None\n\n            annotations.append(Annotation.from_df(n_frames, group_df,\n                                                  timing_conversion, is_cycle, group_info))\n\n        self.add_annotations(annotations)\n\n    def delete_annotations(self, annotation_names: List[str]):\n        \"\"\"\n        Deletes annotations from existing experiment.\n        Does NOT save the changes to disc! run self.save() to save.\n\n        Args:\n            annotation_names: a list of annotation names to delete from the database.\n        \"\"\"\n        for name in annotation_names:\n            DbWriter(self.db.connection).delete_annotation(name)\n\n    def close(self):\n        \"\"\"\n        Close database connection.\n        \"\"\"\n        self.db.connection.close()\n\n    @classmethod\n    def load(cls, file_name: Union[Path, str]):\n        \"\"\"\n        Loads a database from a file and initialises an Experiment.\n\n        Args:\n            file_name: full path to a file to database.\n        Return:\n            (Experiment): initialised experiment.\n        \"\"\"\n        db_reader = DbReader.load(file_name)\n        return cls(db_reader)\n\n    def choose_frames(self, conditions: Union[tuple, List[Tuple[str, str]]], logic: str = \"and\") -&gt; List[int]:\n        \"\"\"\n        Selects the frames that correspond to specified conditions;\n        Uses \"or\" or \"and\" between the conditions depending on logic.\n        To load the selected frames, use load_frames().\n\n        Args:\n            conditions: a list of conditions on the annotation labels\n                in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n                and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]\n            logic: \"and\" or \"or\" , default is \"and\".\n        Returns:\n            list of frame ids that were chosen. Remember that frame numbers start at 1.\n        \"\"\"\n        assert logic == \"and\" or logic == \"or\", \\\n            'between_group_logic should be equal to \"and\" or \"or\"'\n        frames = []\n        if logic == \"and\":\n            frames = self.db.get_and_frames_per_annotations(conditions)\n        elif logic == \"or\":\n            frames = self.db.get_or_frames_per_annotations(conditions)\n\n        return frames\n\n    def choose_volumes(self, conditions: Union[tuple, List[Tuple[str, str]]], logic: str = \"and\",\n                       verbose: bool = False) -&gt; List[int]:\n        \"\"\"\n        Selects only full volumes that correspond to specified conditions;\n        Uses \"or\" or \"and\" between the conditions depending on logic.\n        To load the selected volumes, use load_volumes()\n\n        Args:\n            verbose: Whether to print the information about how many frames were choose/ dropped\n            conditions: a list of conditions on the annotation labels\n                in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n                and name is the name of the label of that annotation type.\n                For example [('light', 'on'), ('shape','c')]\n            logic: \"and\" or \"or\" , default is \"and\".\n        Returns:\n            list of volumes that were chosen.\n            Remember that frame numbers start at 1, but volumes start at 0.\n        \"\"\"\n        # TODO : make all indices start at 1 ?\n\n        assert isinstance(conditions, list) or isinstance(conditions, tuple), f\"conditions must be a list or a tuple,\" \\\n                                                                              f\" but got {type(conditions)} instead\"\n        if isinstance(conditions, tuple):\n            conditions = [conditions]\n\n        # get all the frames that correspond to the conditions\n        frames = self.choose_frames(conditions, logic=logic)\n        n_frames = len(frames)\n        # leave only such frames that correspond to full volumes\n        # TODO : not necessary to return the frames?\n        volumes, frames = self.db.choose_full_volumes(frames)\n        n_dropped = n_frames - len(frames)\n        if verbose:\n            print(f\"Choosing only full volumes. \"\n                  f\"Dropped {n_dropped} frames, kept {len(frames)}\")\n\n        return volumes\n\n    def load_volumes(self, volumes: Union[npt.NDArray, List[int]], verbose: bool = False) -&gt; npt.NDArray:\n        \"\"\"\n        Load volumes. Will load the specified full volumes.\n        All the returned volumes or slices should have the same number of frames in them.\n\n        Args:\n            volumes: the indexes of volumes to load.\n            verbose: Whether to print the information about the loading\n        Returns:\n            4D array with the loaded volumes. TZYX order.\n        \"\"\"\n        # if array convert to list of int\n        if isinstance(volumes, np.ndarray):\n            # make sure it is a 1D array\n            assert len(volumes.shape) == 1, \"volumes must be a 1D array\"\n\n            # make sure all the volumes can be safely converted to integers\n            assert np.all(volumes.astype(int) == volumes), \"All the volumes must be integers\"\n            volumes = volumes.astype(int).tolist()\n\n        frames = self.db.get_frames_per_volumes(volumes)\n        info = self.db.prepare_frames_for_loading(frames)\n\n        # unpack\n        data_dir, file_names, file_ids, frame_in_file, volumes_per_frame = info\n        # get unique volumes and check that they are the same as the ones we asked for\n        assert set(volumes_per_frame) == set(volumes), \"Requested volumes\" \\\n                                                       f\" {set(volumes).difference(set(volumes_per_frame))} \" \\\n                                                       \"can not be found\"\n        # make full paths to files ( remember file ids start with 1 )\n        files = [Path(data_dir, file_names[file_id - 1]) for file_id in file_ids]\n        if not hasattr(self, \"loader\"):\n            self.loader = ImageLoader(Path(data_dir, file_names[0]))\n        volumes_img = self.loader.load_volumes(frame_in_file,\n                                               files,\n                                               volumes_per_frame,\n                                               show_file_names=False,\n                                               show_progress=verbose)\n        return volumes_img\n\n    def get_volume_annotations(self, volumes: Union[npt.NDArray, List[int]],\n                               annotation_names: Optional[List[str]] = None) -&gt; Dict[str, List[str]]:\n        \"\"\"\n        Get annotations for volumes.\n        Will get the labels for the specified full volumes from each available annotation.\n\n        Args:\n            volumes: the indexes of volumes to get annotation for. If a multidimensional array is passed,\n                will flatten it and get annotations for all the volumes in it.\n            annotation_names: the names of the annotations to get. If None, will get all the annotations.\n\n        Returns:\n            a dictionary with the annotations for each annotation type.\n            The keys are the annotation types, the values are lists of labels for each volume.\n            The last key is \"volumes\" and the value is a list of volumes.\n        \"\"\"\n        # TODO: throw a warning if some volumes are not in the database\n\n        # if array convert to list of int\n        if isinstance(volumes, np.ndarray):\n            # turn into a 1D array\n            volumes = volumes.flatten()\n            # make sure all the volumes can be safely converted to integers\n            assert np.all(volumes.astype(int) == volumes), \"All the volumes must be integers\"\n            volumes = volumes.astype(int).tolist()\n\n        # get annotations for the volumes\n        annotations = self.db.get_volume_annotations(volumes, annotation_names=annotation_names)\n\n        # prepare dict for the annotations\n        annotation = {key: [] for key in annotations.keys()}\n        annotation[\"volumes\"] = []\n\n        # get a single label per volume\n        for volume in volumes:\n            for group, data in annotations.items():\n                volume_ids = np.array(data[\"volume_ids\"])\n                labels = np.array(data[\"labels\"])\n                # check that the volume has the same labels\n                labels_per_volume = set(labels[volume_ids == volume])\n                if len(labels_per_volume) &gt; 1:\n                    raise ValueError(f\"Volume {volume} has different labels ({labels_per_volume}) \"\n                                     f\"for the same annotation {group}. Can't assign a single label to the volume.\")\n                # add the label to the dict\n                annotation[group].append(list(labels_per_volume)[0])\n            # add the volume to the dict\n            annotation[\"volumes\"].append(volume)\n\n        return annotation\n\n    def get_volume_annotation_df(self, volumes: Union[npt.NDArray, List[int]],\n                                 annotation_names: Optional[List[str]] = None) -&gt; pd.DataFrame:\n        \"\"\"\n        Get annotations for volumes.\n        Will get the labels for the specified full volumes from each available annotation as pandas dataframe.\n        Args:\n            volumes: the indexes of volumes to get annotation for. If a multidimensional array is passed,\n                will flatten it and get annotations for all the volumes in it.\n            annotation_names: the names of the annotations to get. If None, will get all the annotations.\n\n        Returns:\n            a dataframe with the annotations for each annotation type.\n            The columns are volumes and the annotation types with the corresponding labels for each volume.\n        \"\"\"\n        # get annotations for the volumes\n        annotations = self.get_volume_annotations(volumes, annotation_names=annotation_names)\n        return pd.DataFrame(annotations)\n\n    def add_annotations_from_volume_annotation_df(self, volume_annotation_df: pd.DataFrame,\n                                                  annotation_names: Optional[List[str]] = None):\n        \"\"\"\n        Add annotations from volume_annotation dataframe to the experiment.\n        Use it if you have cropped the volumes from the original movie and\n        want to add the annotations to the cropped movie.\n        The format of the dataframe should be the same as the one returned by get_volume_annotation_df.\n        The length of the volumes should be the same as the length of the experiment.\n        Will only work for annotation types that are constant for the whole volume. If you have annotations that change\n        within the volume, you will need to exclude them.\n\n        Args:\n            volume_annotation_df: the dataframe with the annotations.\n            annotation_names: the names of the annotations to add. These must be the column names in the table.\n                If None, will add all the annotations in the table and will\n                assume that all the columns in the dataframe that are not \"volumes\" are the annotation names.\n                ! If you have modified the table to add additional columns that are NOT annotations,\n                you must specify the annotation names,\n                otherwise vodex will attempt to add those columns as annotations!\n        \"\"\"\n        # make a copy of the dataframe to avoid modifying the original\n        volume_annotation_df = volume_annotation_df.copy()\n\n        # get the columns in the dataframe that are not \"\n        if annotation_names is None:\n            annotation_names = list(volume_annotation_df.columns)\n            annotation_names.remove(\"volumes\")\n\n        # add duration column to the dataframe\n        volume_annotation_df[\"duration\"] = self.frames_per_volume\n\n        # get index of the volume -1 (head)\n        head_volume = volume_annotation_df[volume_annotation_df[\"volumes\"] == -1].index\n        # get index of the volume -2 (tail)\n        tail_volume = volume_annotation_df[volume_annotation_df[\"volumes\"] == -2].index\n        # set the duration for partial volumes\n        if len(head_volume) &gt; 0:\n            volume_annotation_df.loc[head_volume, \"duration\"] = self.n_head_frames\n            # assign the row to the beginning of the dataframe\n            volume_annotation_df = pd.concat([volume_annotation_df.loc[head_volume],\n                                              volume_annotation_df.drop(head_volume)])\n        if len(tail_volume) &gt; 0:\n            volume_annotation_df.loc[tail_volume, \"duration\"] = self.n_tail_frames\n            # assign the row to the end of the dataframe\n            volume_annotation_df = pd.concat([volume_annotation_df.drop(tail_volume),\n                                              volume_annotation_df.loc[tail_volume]])\n\n        # add the annotations to the experiment\n        for annotation_name in annotation_names:\n            # get the labels for the annotation\n            annotation_df = pd.DataFrame({\"group\": np.repeat(annotation_name, len(volume_annotation_df)).astype(str),\n                                          \"name\": volume_annotation_df[annotation_name].values,\n                                          \"duration_frames\": volume_annotation_df[\"duration\"].values})\n            # add the annotation\n            self.add_annotations_from_df(annotation_df)\n\n    def load_slices(self, slices: List[int], volumes: List[int] = None,\n                    skip_missing: bool = False, verbose: bool = False) -&gt; npt.NDArray:\n        \"\"\"\n        Load volumes. Will load the specified full volumes.\n        All the returned volumes or slices should have the same number of frames in them.\n\n        Args:\n            slices: the indexes of slices in the volumes to load.\n            volumes: the indexes of volumes to load slices for. If None, will load slices for all volumes.\n            skip_missing: Whether to skip missing volumes.\n                If False, will raise an error if a slice is missing for any volume.\n            verbose: Whether to print the information about the loading\n        Returns:\n            4D array with the loaded slices for selected volumes. TZYX order.\n        \"\"\"\n        if volumes is None:\n            volumes = self.db.get_volume_list()\n\n        frames = self.db.get_frames_per_volumes(volumes, slices=slices)\n        info = self.db.prepare_frames_for_loading(frames)\n\n        # unpack and load\n        data_dir, file_names, file_ids, frame_in_file, volumes_per_frame = info\n\n        # get unique volumes and check that they are the same as the ones we asked for\n        if skip_missing:  # throw a warning\n            if set(volumes_per_frame) != set(volumes):\n                warnings.warn(f\"Requested volumes {set(volumes).difference(set(volumes_per_frame))} \" +\n                              f\"are not present in the slices {slices}. \" +\n                              f\"Loaded slices for {set(volumes_per_frame)} volumes.\")\n        else:  # throw an error\n            assert set(volumes_per_frame) == set(volumes), \\\n                f\"Requested volumes {set(volumes).difference(set(volumes_per_frame))} \" \\\n                f\"are not present in the slices {slices}. \"\n\n        # make full paths to files ( remember file ids start with 1 )\n        files = [Path(data_dir, file_names[file_id - 1]) for file_id in file_ids]\n        if not hasattr(self, \"loader\"):\n            self.loader = ImageLoader(Path(data_dir, file_names[0]))\n\n        volumes_img = self.loader.load_volumes(frame_in_file,\n                                               files,\n                                               volumes_per_frame,\n                                               show_file_names=False,\n                                               show_progress=verbose)\n\n        # if the z dimension is smaller than the number of slices, throw a warning\n        if volumes_img.shape[1] &lt; len(slices):\n            warnings.warn(f\"Some of the requested slices {slices} are not present in the volumes. \" +\n                          f\"Loaded {volumes_img.shape[1]} slices instead of {len(slices)}\")\n\n        return volumes_img\n\n    def list_volumes(self) -&gt; npt.NDArray[int]:\n        \"\"\"\n        Returns a list of all the volumes IDs in the experiment.\n        If partial volumes are present: for \"head\" returns -1, for \"tail\" returns -2.\n\n        Returns:\n            list of volume IDs\n        \"\"\"\n        # TODO : Remove this function and use volumes property instead\n        warnings.warn(f\"list_volumes will be removed in vodex 1.1.0 use volumes property instead.\")\n\n        return self.volumes\n\n    def list_conditions_per_cycle(self, annotation_type: str, as_volumes: bool = True) -&gt; Tuple[List[int], List[str]]:\n        \"\"\"\n        Returns a list of conditions per cycle.\n\n        Args:\n            annotation_type: The name of the annotation for which to get the conditions list\n            as_volumes: weather to return conditions per frame (default) or per volume.\n                If as_volumes is true, it is expected that the conditions are not changing in the middle of the volume.\n                Will throw an error if it happens.\n        Returns:\n            list of the condition ids ( condition per frame or per volume) and corresponding condition names.\n        \"\"\"\n\n        # TODO : check if empty\n        if as_volumes:\n            _, condition_ids, count = self.db.get_conditionIds_per_cycle_per_volumes(annotation_type)\n            fpv = self.db.get_fpv()\n            assert np.all(np.array(count) == fpv), \"Can't list_conditions_per_cycle with as_volumes=True: \" \\\n                                                   \"some conditions don't cover the whole volume.\" \\\n                                                   \"You might want to get conditions per frame,\" \\\n                                                   \" by setting as_volumes=False\"\n        else:\n            _, condition_ids = self.db.get_conditionIds_per_cycle_per_frame(annotation_type)\n        names = self.db._get_Names_from_AnnotationTypeLabels()\n\n        return condition_ids, names\n\n    def list_cycle_iterations(self, annotation_type: str, as_volumes: bool = True) -&gt; List[int]:\n        \"\"\"\n        Returns a list of cycle iterations for a specified annotation.\n        The annotation must have been initialised from a cycle.\n\n        Args:\n            annotation_type: The name of the annotation for which to get the cycle iteratoins list\n            as_volumes: weather to return cycle iteratoins per frame ( default) or per volume.\n                If as_volumes is true, it is expected that the cycle iteratoins are not changing in the middle of the volume.\n                Will throw an error if it happens.\n            as_volumes: bool\n        Returns:\n            list of the condition ids (cycle iterations per frame or per volume)\n        \"\"\"\n\n        if as_volumes:\n            _, cycle_its, count = self.db.get_cycleIterations_per_volumes(annotation_type)\n            fpv = self.db.get_fpv()\n            assert np.all(np.array(count) == fpv), \"Can't list_cycle_iterations with as_volumes=True: \" \\\n                                                   \"some iterations don't cover the whole volume.\" \\\n                                                   \"You might want to get iterations per frame,\" \\\n                                                   \" by setting as_volumes=False\"\n        else:\n            _, cycle_its = self.db.get_cycleIterations_per_frame(annotation_type)\n\n        return cycle_its\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.annotations","title":"<code>annotations: List[str]</code>  <code>property</code>","text":"<p>Returns the list of annotation names that have been added to the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.cycles","title":"<code>cycles: List[str]</code>  <code>property</code>","text":"<p>Returns the list of cycle names that have been added to the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.data_dir","title":"<code>data_dir: str</code>  <code>property</code>","text":"<p>Returns the path to the data directory.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.file_names","title":"<code>file_names: List[str]</code>  <code>property</code>","text":"<p>Returns the list of file names that have been added to the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.frames_per_file","title":"<code>frames_per_file: List[int]</code>  <code>property</code>","text":"<p>Returns the list of frames per file that have been added to the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.frames_per_volume","title":"<code>frames_per_volume: int</code>  <code>property</code>","text":"<p>Returns the number of frames per volume.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.full_volumes","title":"<code>full_volumes: npt.NDArray</code>  <code>property</code>","text":"<p>Returns the list of full volume IDs in the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.labels","title":"<code>labels: dict</code>  <code>property</code>","text":"<p>Returns a dict with annotation names, labels and label descriptions that have been added to the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.labels_df","title":"<code>labels_df: pd.DataFrame</code>  <code>property</code>","text":"<p>Returns a dataframe with annotation names, labels and label descriptions that have been added to the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.n_frames","title":"<code>n_frames: int</code>  <code>property</code>","text":"<p>Returns the total number of frames in the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.n_full_volumes","title":"<code>n_full_volumes: int</code>  <code>property</code>","text":"<p>Returns the total number of full volumes in the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.n_head_frames","title":"<code>n_head_frames: int</code>  <code>property</code>","text":"<p>Returns the number of frames in the first partial volume, or 0 if there is no partial volume at the beginning.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.n_tail_frames","title":"<code>n_tail_frames: int</code>  <code>property</code>","text":"<p>Returns the number of frames in the last partial volume, or 0 if there is no partial volume at the end.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.n_volumes","title":"<code>n_volumes: int</code>  <code>property</code>","text":"<p>Returns the total number of volumes in the experiment. This might include partial volumes at the beginning of the experiment (ID: -1) and at the end of the experiment (ID : -2).</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.starting_slice","title":"<code>starting_slice: int</code>  <code>property</code>","text":"<p>Returns the number of the first slice in the experiment.</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.volumes","title":"<code>volumes: npt.NDArray</code>  <code>property</code>","text":"<p>Returns the list of volume IDs in the experiment. This might include partial volumes at the beginning of the experiment (ID: -1) and at the end of the experiment (ID : -2).</p>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.__init__","title":"<code>__init__(db_reader)</code>","text":"<p>Initialize the experiment with the given DbReader object.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def __init__(self, db_reader: DbReader):\n    \"\"\"\n    Initialize the experiment with the given DbReader object.\n    \"\"\"\n\n    assert isinstance(db_reader, DbReader), \"Need DbReader to initialise the Experiment\"\n\n    self.db = db_reader\n    # will add the loader the first time you are loading anything\n    # in load_frames() or load_volumes()\n    self.loader: ImageLoader\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.add_annotations","title":"<code>add_annotations(annotations)</code>","text":"<p>Adds annotations to existing experiment. Does NOT save the changes to disc! run self.save() to save.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>List[Annotation]</code> <p>a list of annotations to add to the database.</p> required Source code in <code>src/vodex/experiment.py</code> <pre><code>def add_annotations(self, annotations: List[Annotation]):\n    \"\"\"\n    Adds annotations to existing experiment.\n    Does NOT save the changes to disc! run self.save() to save.\n\n    Args:\n        annotations: a list of annotations to add to the database.\n    \"\"\"\n    DbWriter(self.db.connection).add_annotations(annotations)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.add_annotations_from_df","title":"<code>add_annotations_from_df(annotation_df, cycles=False, timing_conversion=None, groups=None, info=None)</code>","text":"<p>Adds annotations to existing experiment from a data frame. Does NOT save the changes to disc! run self.save() to save.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_df</code> <code>DataFrame</code> <p>a dataframe with the annotation information</p> required <code>cycles</code> <code>Union[List[str], bool]</code> <p>a list of the annotation names that are cycles or a boolean. If False, all annotations are assumed to be timelines. If True, all annotations are assumed to be cycles. Specified as {'cycles': }</p> <code>False</code> <code>timing_conversion</code> <code>Optional[dict]</code> <p>a dictionary to convert the timing of the annotation. For example, if you want to convert the timing from frames to seconds, and you were recording at 30 frames per second, you can use timing_conversion = {'frames': 1, 'seconds': 1/30} You can list multiple units in the dictionary, and the timing will be converted to all of them, for example if there are also 10 frames per volume, you can use: timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10} You must include 'frames' in the dictionary! The value of frames does not have to be 1, but it must be consistent with the other units. the rest of the values. for example this is valid for the example above: timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}. If timing_conversion is None, then the timing is not converted and 'duration_frames' must be provided in the dataframe.</p> <code>None</code> <code>groups</code> <code>Optional[str]</code> <p>the group of the annotation if there are multiple groups in the dataframe. If None, all groups are added.</p> <code>None</code> <code>info</code> <code>Optional[dict]</code> <p>additional information about the annotation, dictionary with keys: 'annotation name': information</p> <code>None</code> Source code in <code>src/vodex/experiment.py</code> <pre><code>def add_annotations_from_df(self, annotation_df: pd.DataFrame,\n                            cycles: Union[List[str], bool] = False,\n                            timing_conversion: Optional[dict] = None,\n                            groups: Optional[str] = None,\n                            info: Optional[dict] = None):\n    \"\"\"\n    Adds annotations to existing experiment from a data frame.\n    Does NOT save the changes to disc! run self.save() to save.\n\n    Args:\n        annotation_df: a dataframe with the annotation information\n        cycles: a list of the annotation names that are cycles or a boolean.\n            If False, all annotations are assumed to be timelines.\n            If True, all annotations are assumed to be cycles.\n            Specified as {'cycles': }\n        timing_conversion: a dictionary to convert the timing of the annotation.\n            For example, if you want to convert the timing from frames to seconds,\n            and you were recording at 30 frames per second, you can use\n            timing_conversion = {'frames': 1, 'seconds': 1/30}\n            You can list multiple units in the dictionary, and the timing will be converted to all of them,\n            for example if there are also 10 frames per volume, you can use:\n            timing_conversion = {'frames': 1, 'seconds': 1/30, 'volumes': 1/10}\n            You must include 'frames' in the dictionary! The value of frames does not have to be 1,\n            but it must be consistent with the other units. the rest of the values.\n            for example this is valid for the example above:\n            timing_conversion = {'frames': 10, 'seconds': 1/3, 'volumes': 1}.\n            If timing_conversion is None, then the timing is not converted\n            and 'duration_frames' must be provided in the dataframe.\n        groups: the group of the annotation if there are multiple groups in the dataframe.\n            If None, all groups are added.\n        info: additional information about the annotation, dictionary with keys:\n            'annotation name': information\n    \"\"\"\n    n_frames = self.db.get_n_frames()\n\n    if groups is None:\n        groups = annotation_df['group'].unique()\n\n    annotations = []\n    for group in groups:\n        group_df = annotation_df[annotation_df['group'] == group]\n\n        if cycles is True or (isinstance(cycles, list) and group in cycles):\n            is_cycle = True\n        else:\n            is_cycle = False\n\n        if info is not None and group in info:\n            group_info = info[group]\n        else:\n            group_info = None\n\n        annotations.append(Annotation.from_df(n_frames, group_df,\n                                              timing_conversion, is_cycle, group_info))\n\n    self.add_annotations(annotations)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.add_annotations_from_volume_annotation_df","title":"<code>add_annotations_from_volume_annotation_df(volume_annotation_df, annotation_names=None)</code>","text":"<p>Add annotations from volume_annotation dataframe to the experiment. Use it if you have cropped the volumes from the original movie and want to add the annotations to the cropped movie. The format of the dataframe should be the same as the one returned by get_volume_annotation_df. The length of the volumes should be the same as the length of the experiment. Will only work for annotation types that are constant for the whole volume. If you have annotations that change within the volume, you will need to exclude them.</p> <p>Parameters:</p> Name Type Description Default <code>volume_annotation_df</code> <code>DataFrame</code> <p>the dataframe with the annotations.</p> required <code>annotation_names</code> <code>Optional[List[str]]</code> <p>the names of the annotations to add. These must be the column names in the table. If None, will add all the annotations in the table and will assume that all the columns in the dataframe that are not \"volumes\" are the annotation names. ! If you have modified the table to add additional columns that are NOT annotations, you must specify the annotation names, otherwise vodex will attempt to add those columns as annotations!</p> <code>None</code> Source code in <code>src/vodex/experiment.py</code> <pre><code>def add_annotations_from_volume_annotation_df(self, volume_annotation_df: pd.DataFrame,\n                                              annotation_names: Optional[List[str]] = None):\n    \"\"\"\n    Add annotations from volume_annotation dataframe to the experiment.\n    Use it if you have cropped the volumes from the original movie and\n    want to add the annotations to the cropped movie.\n    The format of the dataframe should be the same as the one returned by get_volume_annotation_df.\n    The length of the volumes should be the same as the length of the experiment.\n    Will only work for annotation types that are constant for the whole volume. If you have annotations that change\n    within the volume, you will need to exclude them.\n\n    Args:\n        volume_annotation_df: the dataframe with the annotations.\n        annotation_names: the names of the annotations to add. These must be the column names in the table.\n            If None, will add all the annotations in the table and will\n            assume that all the columns in the dataframe that are not \"volumes\" are the annotation names.\n            ! If you have modified the table to add additional columns that are NOT annotations,\n            you must specify the annotation names,\n            otherwise vodex will attempt to add those columns as annotations!\n    \"\"\"\n    # make a copy of the dataframe to avoid modifying the original\n    volume_annotation_df = volume_annotation_df.copy()\n\n    # get the columns in the dataframe that are not \"\n    if annotation_names is None:\n        annotation_names = list(volume_annotation_df.columns)\n        annotation_names.remove(\"volumes\")\n\n    # add duration column to the dataframe\n    volume_annotation_df[\"duration\"] = self.frames_per_volume\n\n    # get index of the volume -1 (head)\n    head_volume = volume_annotation_df[volume_annotation_df[\"volumes\"] == -1].index\n    # get index of the volume -2 (tail)\n    tail_volume = volume_annotation_df[volume_annotation_df[\"volumes\"] == -2].index\n    # set the duration for partial volumes\n    if len(head_volume) &gt; 0:\n        volume_annotation_df.loc[head_volume, \"duration\"] = self.n_head_frames\n        # assign the row to the beginning of the dataframe\n        volume_annotation_df = pd.concat([volume_annotation_df.loc[head_volume],\n                                          volume_annotation_df.drop(head_volume)])\n    if len(tail_volume) &gt; 0:\n        volume_annotation_df.loc[tail_volume, \"duration\"] = self.n_tail_frames\n        # assign the row to the end of the dataframe\n        volume_annotation_df = pd.concat([volume_annotation_df.drop(tail_volume),\n                                          volume_annotation_df.loc[tail_volume]])\n\n    # add the annotations to the experiment\n    for annotation_name in annotation_names:\n        # get the labels for the annotation\n        annotation_df = pd.DataFrame({\"group\": np.repeat(annotation_name, len(volume_annotation_df)).astype(str),\n                                      \"name\": volume_annotation_df[annotation_name].values,\n                                      \"duration_frames\": volume_annotation_df[\"duration\"].values})\n        # add the annotation\n        self.add_annotations_from_df(annotation_df)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.batch_volumes","title":"<code>batch_volumes(batch_size, overlap=0, volumes=None, full_only=True)</code>","text":"<p>Returns a list of volume IDs that can be used to load batches of volumes. The batch size is given in number of volumes, and the overlap is given in number of volumes. If full_only is True, only full volumes are returned.</p> <p>Parameters:</p> Name Type Description Default <code>batch_size</code> <code>int</code> <p>the number of volumes in each batch.</p> required <code>overlap</code> <code>int</code> <p>the number of volumes that overlap between batches.</p> <code>0</code> <code>volumes</code> <code>Optional[Union[NDArray, List[int]]]</code> <p>the list of volumes to be batched.</p> <code>None</code> <code>full_only</code> <code>bool</code> <p>if True, only full volumes are returned. If volumes is not None, this argument is ignored.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[List[int]]</code> <p>A list of lists (n_batches x batch_size) of volume IDs that can be used to load batches of volumes.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def batch_volumes(self, batch_size: int, overlap: int = 0,\n                  volumes: Optional[Union[npt.NDArray, List[int]]] = None,\n                  full_only: bool = True) -&gt; List[List[int]]:\n    \"\"\"\n    Returns a list of volume IDs that can be used to load batches of volumes.\n    The batch size is given in number of volumes, and the overlap is given in number of volumes.\n    If full_only is True, only full volumes are returned.\n\n    Args:\n        batch_size: the number of volumes in each batch.\n        overlap: the number of volumes that overlap between batches.\n        volumes: the list of volumes to be batched.\n        full_only: if True, only full volumes are returned. If volumes is not None, this argument is ignored.\n\n    Returns:\n        A list of lists (n_batches x batch_size) of volume IDs that can be used to load batches of volumes.\n    \"\"\"\n    if overlap &gt;= batch_size:\n        raise ValueError(\"Overlap must be smaller than batch size.\")\n\n    if volumes is not None:\n        volume_list = volumes\n    else:\n        if full_only:\n            volume_list = self.full_volumes\n        else:\n            volume_list = self.volumes\n\n    # turn into a list if numpy array\n    if isinstance(volume_list, np.ndarray):\n        volume_list = volume_list.tolist()\n\n    batch_list = []\n    for i in range(0, len(volume_list), batch_size - overlap):\n        batch_list.append(volume_list[i:i + batch_size])\n    return batch_list\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.choose_frames","title":"<code>choose_frames(conditions, logic='and')</code>","text":"<p>Selects the frames that correspond to specified conditions; Uses \"or\" or \"and\" between the conditions depending on logic. To load the selected frames, use load_frames().</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Union[tuple, List[Tuple[str, str]]]</code> <p>a list of conditions on the annotation labels in a form [(group, name),(group, name), ...] where group is a string for the annotation type and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]</p> required <code>logic</code> <code>str</code> <p>\"and\" or \"or\" , default is \"and\".</p> <code>'and'</code> <p>Returns:     list of frame ids that were chosen. Remember that frame numbers start at 1.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def choose_frames(self, conditions: Union[tuple, List[Tuple[str, str]]], logic: str = \"and\") -&gt; List[int]:\n    \"\"\"\n    Selects the frames that correspond to specified conditions;\n    Uses \"or\" or \"and\" between the conditions depending on logic.\n    To load the selected frames, use load_frames().\n\n    Args:\n        conditions: a list of conditions on the annotation labels\n            in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n            and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]\n        logic: \"and\" or \"or\" , default is \"and\".\n    Returns:\n        list of frame ids that were chosen. Remember that frame numbers start at 1.\n    \"\"\"\n    assert logic == \"and\" or logic == \"or\", \\\n        'between_group_logic should be equal to \"and\" or \"or\"'\n    frames = []\n    if logic == \"and\":\n        frames = self.db.get_and_frames_per_annotations(conditions)\n    elif logic == \"or\":\n        frames = self.db.get_or_frames_per_annotations(conditions)\n\n    return frames\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.choose_volumes","title":"<code>choose_volumes(conditions, logic='and', verbose=False)</code>","text":"<p>Selects only full volumes that correspond to specified conditions; Uses \"or\" or \"and\" between the conditions depending on logic. To load the selected volumes, use load_volumes()</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to print the information about how many frames were choose/ dropped</p> <code>False</code> <code>conditions</code> <code>Union[tuple, List[Tuple[str, str]]]</code> <p>a list of conditions on the annotation labels in a form [(group, name),(group, name), ...] where group is a string for the annotation type and name is the name of the label of that annotation type. For example [('light', 'on'), ('shape','c')]</p> required <code>logic</code> <code>str</code> <p>\"and\" or \"or\" , default is \"and\".</p> <code>'and'</code> <p>Returns:     list of volumes that were chosen.     Remember that frame numbers start at 1, but volumes start at 0.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def choose_volumes(self, conditions: Union[tuple, List[Tuple[str, str]]], logic: str = \"and\",\n                   verbose: bool = False) -&gt; List[int]:\n    \"\"\"\n    Selects only full volumes that correspond to specified conditions;\n    Uses \"or\" or \"and\" between the conditions depending on logic.\n    To load the selected volumes, use load_volumes()\n\n    Args:\n        verbose: Whether to print the information about how many frames were choose/ dropped\n        conditions: a list of conditions on the annotation labels\n            in a form [(group, name),(group, name), ...] where group is a string for the annotation type\n            and name is the name of the label of that annotation type.\n            For example [('light', 'on'), ('shape','c')]\n        logic: \"and\" or \"or\" , default is \"and\".\n    Returns:\n        list of volumes that were chosen.\n        Remember that frame numbers start at 1, but volumes start at 0.\n    \"\"\"\n    # TODO : make all indices start at 1 ?\n\n    assert isinstance(conditions, list) or isinstance(conditions, tuple), f\"conditions must be a list or a tuple,\" \\\n                                                                          f\" but got {type(conditions)} instead\"\n    if isinstance(conditions, tuple):\n        conditions = [conditions]\n\n    # get all the frames that correspond to the conditions\n    frames = self.choose_frames(conditions, logic=logic)\n    n_frames = len(frames)\n    # leave only such frames that correspond to full volumes\n    # TODO : not necessary to return the frames?\n    volumes, frames = self.db.choose_full_volumes(frames)\n    n_dropped = n_frames - len(frames)\n    if verbose:\n        print(f\"Choosing only full volumes. \"\n              f\"Dropped {n_dropped} frames, kept {len(frames)}\")\n\n    return volumes\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.close","title":"<code>close()</code>","text":"<p>Close database connection.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close database connection.\n    \"\"\"\n    self.db.connection.close()\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.create","title":"<code>create(volume_manager, annotations, verbose=False)</code>  <code>classmethod</code>","text":"<p>Creates a database instance from the core classes and initialises the experiment.</p> <p>Parameters:</p> Name Type Description Default <code>volume_manager</code> <code>VolumeManager</code> <p>VolumeManager object that summarises the information about the image data.</p> required <code>annotations</code> <code>List[Annotation]</code> <p>list of annotations to add to the experiment descriptions.</p> required <code>verbose</code> <code>bool</code> <p>whether to print the information about Filemanager, VolumeManager and Annotations on the screen.</p> <code>False</code> <p>Returns:</p> Type Description <code>Experiment</code> <p>initialised experiment.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>@classmethod\ndef create(cls, volume_manager: VolumeManager, annotations: List[Annotation], verbose: bool = False):\n    \"\"\"\n    Creates a database instance from the core classes and initialises the experiment.\n\n    Args:\n        volume_manager: VolumeManager object that summarises the information about the image data.\n        annotations: list of annotations to add to the experiment descriptions.\n        verbose: whether to print the information about Filemanager, VolumeManager and Annotations on the screen.\n\n    Returns:\n        (Experiment): initialised experiment.\n    \"\"\"\n    if verbose:\n        print(volume_manager.file_manager)\n        print(volume_manager)\n        for annotation in annotations:\n            print(annotation)\n            if annotation.cycle is not None:\n                print(annotation.cycle_info())\n\n    db = DbWriter.create()\n    db.populate(volumes=volume_manager, annotations=annotations)\n    db_reader = DbReader(db.connection)\n    return cls(db_reader)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.delete_annotations","title":"<code>delete_annotations(annotation_names)</code>","text":"<p>Deletes annotations from existing experiment. Does NOT save the changes to disc! run self.save() to save.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_names</code> <code>List[str]</code> <p>a list of annotation names to delete from the database.</p> required Source code in <code>src/vodex/experiment.py</code> <pre><code>def delete_annotations(self, annotation_names: List[str]):\n    \"\"\"\n    Deletes annotations from existing experiment.\n    Does NOT save the changes to disc! run self.save() to save.\n\n    Args:\n        annotation_names: a list of annotation names to delete from the database.\n    \"\"\"\n    for name in annotation_names:\n        DbWriter(self.db.connection).delete_annotation(name)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.from_dir","title":"<code>from_dir(dir_name, frames_per_volume, starting_slice=0, verbose=False)</code>  <code>classmethod</code>","text":"<p>Creates a database instance from a directory and initialises the experiment. The directory should contain the image files. Annotations are not initialised, but can be added later.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>@classmethod\ndef from_dir(cls, dir_name: Union[Path, str], frames_per_volume: int,\n             starting_slice: int = 0, verbose: bool = False):\n    \"\"\"\n    Creates a database instance from a directory and initialises the experiment.\n    The directory should contain the image files.\n    Annotations are not initialised, but can be added later.\n    \"\"\"\n    # initialise volume manager\n    volume_manager = VolumeManager.from_dir(dir_name, frames_per_volume, fgf=starting_slice)\n    return cls.create(volume_manager, [], verbose)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.get_volume_annotation_df","title":"<code>get_volume_annotation_df(volumes, annotation_names=None)</code>","text":"<p>Get annotations for volumes. Will get the labels for the specified full volumes from each available annotation as pandas dataframe. Args:     volumes: the indexes of volumes to get annotation for. If a multidimensional array is passed,         will flatten it and get annotations for all the volumes in it.     annotation_names: the names of the annotations to get. If None, will get all the annotations.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>a dataframe with the annotations for each annotation type.</p> <code>DataFrame</code> <p>The columns are volumes and the annotation types with the corresponding labels for each volume.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def get_volume_annotation_df(self, volumes: Union[npt.NDArray, List[int]],\n                             annotation_names: Optional[List[str]] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Get annotations for volumes.\n    Will get the labels for the specified full volumes from each available annotation as pandas dataframe.\n    Args:\n        volumes: the indexes of volumes to get annotation for. If a multidimensional array is passed,\n            will flatten it and get annotations for all the volumes in it.\n        annotation_names: the names of the annotations to get. If None, will get all the annotations.\n\n    Returns:\n        a dataframe with the annotations for each annotation type.\n        The columns are volumes and the annotation types with the corresponding labels for each volume.\n    \"\"\"\n    # get annotations for the volumes\n    annotations = self.get_volume_annotations(volumes, annotation_names=annotation_names)\n    return pd.DataFrame(annotations)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.get_volume_annotations","title":"<code>get_volume_annotations(volumes, annotation_names=None)</code>","text":"<p>Get annotations for volumes. Will get the labels for the specified full volumes from each available annotation.</p> <p>Parameters:</p> Name Type Description Default <code>volumes</code> <code>Union[NDArray, List[int]]</code> <p>the indexes of volumes to get annotation for. If a multidimensional array is passed, will flatten it and get annotations for all the volumes in it.</p> required <code>annotation_names</code> <code>Optional[List[str]]</code> <p>the names of the annotations to get. If None, will get all the annotations.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>a dictionary with the annotations for each annotation type.</p> <code>Dict[str, List[str]]</code> <p>The keys are the annotation types, the values are lists of labels for each volume.</p> <code>Dict[str, List[str]]</code> <p>The last key is \"volumes\" and the value is a list of volumes.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def get_volume_annotations(self, volumes: Union[npt.NDArray, List[int]],\n                           annotation_names: Optional[List[str]] = None) -&gt; Dict[str, List[str]]:\n    \"\"\"\n    Get annotations for volumes.\n    Will get the labels for the specified full volumes from each available annotation.\n\n    Args:\n        volumes: the indexes of volumes to get annotation for. If a multidimensional array is passed,\n            will flatten it and get annotations for all the volumes in it.\n        annotation_names: the names of the annotations to get. If None, will get all the annotations.\n\n    Returns:\n        a dictionary with the annotations for each annotation type.\n        The keys are the annotation types, the values are lists of labels for each volume.\n        The last key is \"volumes\" and the value is a list of volumes.\n    \"\"\"\n    # TODO: throw a warning if some volumes are not in the database\n\n    # if array convert to list of int\n    if isinstance(volumes, np.ndarray):\n        # turn into a 1D array\n        volumes = volumes.flatten()\n        # make sure all the volumes can be safely converted to integers\n        assert np.all(volumes.astype(int) == volumes), \"All the volumes must be integers\"\n        volumes = volumes.astype(int).tolist()\n\n    # get annotations for the volumes\n    annotations = self.db.get_volume_annotations(volumes, annotation_names=annotation_names)\n\n    # prepare dict for the annotations\n    annotation = {key: [] for key in annotations.keys()}\n    annotation[\"volumes\"] = []\n\n    # get a single label per volume\n    for volume in volumes:\n        for group, data in annotations.items():\n            volume_ids = np.array(data[\"volume_ids\"])\n            labels = np.array(data[\"labels\"])\n            # check that the volume has the same labels\n            labels_per_volume = set(labels[volume_ids == volume])\n            if len(labels_per_volume) &gt; 1:\n                raise ValueError(f\"Volume {volume} has different labels ({labels_per_volume}) \"\n                                 f\"for the same annotation {group}. Can't assign a single label to the volume.\")\n            # add the label to the dict\n            annotation[group].append(list(labels_per_volume)[0])\n        # add the volume to the dict\n        annotation[\"volumes\"].append(volume)\n\n    return annotation\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.list_conditions_per_cycle","title":"<code>list_conditions_per_cycle(annotation_type, as_volumes=True)</code>","text":"<p>Returns a list of conditions per cycle.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The name of the annotation for which to get the conditions list</p> required <code>as_volumes</code> <code>bool</code> <p>weather to return conditions per frame (default) or per volume. If as_volumes is true, it is expected that the conditions are not changing in the middle of the volume. Will throw an error if it happens.</p> <code>True</code> <p>Returns:     list of the condition ids ( condition per frame or per volume) and corresponding condition names.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def list_conditions_per_cycle(self, annotation_type: str, as_volumes: bool = True) -&gt; Tuple[List[int], List[str]]:\n    \"\"\"\n    Returns a list of conditions per cycle.\n\n    Args:\n        annotation_type: The name of the annotation for which to get the conditions list\n        as_volumes: weather to return conditions per frame (default) or per volume.\n            If as_volumes is true, it is expected that the conditions are not changing in the middle of the volume.\n            Will throw an error if it happens.\n    Returns:\n        list of the condition ids ( condition per frame or per volume) and corresponding condition names.\n    \"\"\"\n\n    # TODO : check if empty\n    if as_volumes:\n        _, condition_ids, count = self.db.get_conditionIds_per_cycle_per_volumes(annotation_type)\n        fpv = self.db.get_fpv()\n        assert np.all(np.array(count) == fpv), \"Can't list_conditions_per_cycle with as_volumes=True: \" \\\n                                               \"some conditions don't cover the whole volume.\" \\\n                                               \"You might want to get conditions per frame,\" \\\n                                               \" by setting as_volumes=False\"\n    else:\n        _, condition_ids = self.db.get_conditionIds_per_cycle_per_frame(annotation_type)\n    names = self.db._get_Names_from_AnnotationTypeLabels()\n\n    return condition_ids, names\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.list_cycle_iterations","title":"<code>list_cycle_iterations(annotation_type, as_volumes=True)</code>","text":"<p>Returns a list of cycle iterations for a specified annotation. The annotation must have been initialised from a cycle.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_type</code> <code>str</code> <p>The name of the annotation for which to get the cycle iteratoins list</p> required <code>as_volumes</code> <code>bool</code> <p>weather to return cycle iteratoins per frame ( default) or per volume. If as_volumes is true, it is expected that the cycle iteratoins are not changing in the middle of the volume. Will throw an error if it happens.</p> <code>True</code> <code>as_volumes</code> <code>bool</code> <p>bool</p> <code>True</code> <p>Returns:     list of the condition ids (cycle iterations per frame or per volume)</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def list_cycle_iterations(self, annotation_type: str, as_volumes: bool = True) -&gt; List[int]:\n    \"\"\"\n    Returns a list of cycle iterations for a specified annotation.\n    The annotation must have been initialised from a cycle.\n\n    Args:\n        annotation_type: The name of the annotation for which to get the cycle iteratoins list\n        as_volumes: weather to return cycle iteratoins per frame ( default) or per volume.\n            If as_volumes is true, it is expected that the cycle iteratoins are not changing in the middle of the volume.\n            Will throw an error if it happens.\n        as_volumes: bool\n    Returns:\n        list of the condition ids (cycle iterations per frame or per volume)\n    \"\"\"\n\n    if as_volumes:\n        _, cycle_its, count = self.db.get_cycleIterations_per_volumes(annotation_type)\n        fpv = self.db.get_fpv()\n        assert np.all(np.array(count) == fpv), \"Can't list_cycle_iterations with as_volumes=True: \" \\\n                                               \"some iterations don't cover the whole volume.\" \\\n                                               \"You might want to get iterations per frame,\" \\\n                                               \" by setting as_volumes=False\"\n    else:\n        _, cycle_its = self.db.get_cycleIterations_per_frame(annotation_type)\n\n    return cycle_its\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.list_volumes","title":"<code>list_volumes()</code>","text":"<p>Returns a list of all the volumes IDs in the experiment. If partial volumes are present: for \"head\" returns -1, for \"tail\" returns -2.</p> <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>list of volume IDs</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def list_volumes(self) -&gt; npt.NDArray[int]:\n    \"\"\"\n    Returns a list of all the volumes IDs in the experiment.\n    If partial volumes are present: for \"head\" returns -1, for \"tail\" returns -2.\n\n    Returns:\n        list of volume IDs\n    \"\"\"\n    # TODO : Remove this function and use volumes property instead\n    warnings.warn(f\"list_volumes will be removed in vodex 1.1.0 use volumes property instead.\")\n\n    return self.volumes\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.load","title":"<code>load(file_name)</code>  <code>classmethod</code>","text":"<p>Loads a database from a file and initialises an Experiment.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[Path, str]</code> <p>full path to a file to database.</p> required <p>Return:     (Experiment): initialised experiment.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>@classmethod\ndef load(cls, file_name: Union[Path, str]):\n    \"\"\"\n    Loads a database from a file and initialises an Experiment.\n\n    Args:\n        file_name: full path to a file to database.\n    Return:\n        (Experiment): initialised experiment.\n    \"\"\"\n    db_reader = DbReader.load(file_name)\n    return cls(db_reader)\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.load_slices","title":"<code>load_slices(slices, volumes=None, skip_missing=False, verbose=False)</code>","text":"<p>Load volumes. Will load the specified full volumes. All the returned volumes or slices should have the same number of frames in them.</p> <p>Parameters:</p> Name Type Description Default <code>slices</code> <code>List[int]</code> <p>the indexes of slices in the volumes to load.</p> required <code>volumes</code> <code>List[int]</code> <p>the indexes of volumes to load slices for. If None, will load slices for all volumes.</p> <code>None</code> <code>skip_missing</code> <code>bool</code> <p>Whether to skip missing volumes. If False, will raise an error if a slice is missing for any volume.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print the information about the loading</p> <code>False</code> <p>Returns:     4D array with the loaded slices for selected volumes. TZYX order.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def load_slices(self, slices: List[int], volumes: List[int] = None,\n                skip_missing: bool = False, verbose: bool = False) -&gt; npt.NDArray:\n    \"\"\"\n    Load volumes. Will load the specified full volumes.\n    All the returned volumes or slices should have the same number of frames in them.\n\n    Args:\n        slices: the indexes of slices in the volumes to load.\n        volumes: the indexes of volumes to load slices for. If None, will load slices for all volumes.\n        skip_missing: Whether to skip missing volumes.\n            If False, will raise an error if a slice is missing for any volume.\n        verbose: Whether to print the information about the loading\n    Returns:\n        4D array with the loaded slices for selected volumes. TZYX order.\n    \"\"\"\n    if volumes is None:\n        volumes = self.db.get_volume_list()\n\n    frames = self.db.get_frames_per_volumes(volumes, slices=slices)\n    info = self.db.prepare_frames_for_loading(frames)\n\n    # unpack and load\n    data_dir, file_names, file_ids, frame_in_file, volumes_per_frame = info\n\n    # get unique volumes and check that they are the same as the ones we asked for\n    if skip_missing:  # throw a warning\n        if set(volumes_per_frame) != set(volumes):\n            warnings.warn(f\"Requested volumes {set(volumes).difference(set(volumes_per_frame))} \" +\n                          f\"are not present in the slices {slices}. \" +\n                          f\"Loaded slices for {set(volumes_per_frame)} volumes.\")\n    else:  # throw an error\n        assert set(volumes_per_frame) == set(volumes), \\\n            f\"Requested volumes {set(volumes).difference(set(volumes_per_frame))} \" \\\n            f\"are not present in the slices {slices}. \"\n\n    # make full paths to files ( remember file ids start with 1 )\n    files = [Path(data_dir, file_names[file_id - 1]) for file_id in file_ids]\n    if not hasattr(self, \"loader\"):\n        self.loader = ImageLoader(Path(data_dir, file_names[0]))\n\n    volumes_img = self.loader.load_volumes(frame_in_file,\n                                           files,\n                                           volumes_per_frame,\n                                           show_file_names=False,\n                                           show_progress=verbose)\n\n    # if the z dimension is smaller than the number of slices, throw a warning\n    if volumes_img.shape[1] &lt; len(slices):\n        warnings.warn(f\"Some of the requested slices {slices} are not present in the volumes. \" +\n                      f\"Loaded {volumes_img.shape[1]} slices instead of {len(slices)}\")\n\n    return volumes_img\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.load_volumes","title":"<code>load_volumes(volumes, verbose=False)</code>","text":"<p>Load volumes. Will load the specified full volumes. All the returned volumes or slices should have the same number of frames in them.</p> <p>Parameters:</p> Name Type Description Default <code>volumes</code> <code>Union[NDArray, List[int]]</code> <p>the indexes of volumes to load.</p> required <code>verbose</code> <code>bool</code> <p>Whether to print the information about the loading</p> <code>False</code> <p>Returns:     4D array with the loaded volumes. TZYX order.</p> Source code in <code>src/vodex/experiment.py</code> <pre><code>def load_volumes(self, volumes: Union[npt.NDArray, List[int]], verbose: bool = False) -&gt; npt.NDArray:\n    \"\"\"\n    Load volumes. Will load the specified full volumes.\n    All the returned volumes or slices should have the same number of frames in them.\n\n    Args:\n        volumes: the indexes of volumes to load.\n        verbose: Whether to print the information about the loading\n    Returns:\n        4D array with the loaded volumes. TZYX order.\n    \"\"\"\n    # if array convert to list of int\n    if isinstance(volumes, np.ndarray):\n        # make sure it is a 1D array\n        assert len(volumes.shape) == 1, \"volumes must be a 1D array\"\n\n        # make sure all the volumes can be safely converted to integers\n        assert np.all(volumes.astype(int) == volumes), \"All the volumes must be integers\"\n        volumes = volumes.astype(int).tolist()\n\n    frames = self.db.get_frames_per_volumes(volumes)\n    info = self.db.prepare_frames_for_loading(frames)\n\n    # unpack\n    data_dir, file_names, file_ids, frame_in_file, volumes_per_frame = info\n    # get unique volumes and check that they are the same as the ones we asked for\n    assert set(volumes_per_frame) == set(volumes), \"Requested volumes\" \\\n                                                   f\" {set(volumes).difference(set(volumes_per_frame))} \" \\\n                                                   \"can not be found\"\n    # make full paths to files ( remember file ids start with 1 )\n    files = [Path(data_dir, file_names[file_id - 1]) for file_id in file_ids]\n    if not hasattr(self, \"loader\"):\n        self.loader = ImageLoader(Path(data_dir, file_names[0]))\n    volumes_img = self.loader.load_volumes(frame_in_file,\n                                           files,\n                                           volumes_per_frame,\n                                           show_file_names=False,\n                                           show_progress=verbose)\n    return volumes_img\n</code></pre>"},{"location":"api/experiment/#src.vodex.experiment.Experiment.save","title":"<code>save(file_name)</code>","text":"<p>Saves a database into a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[Path, str]</code> <p>full path to a file to save database. (Usually the filename would end with .db)</p> required Source code in <code>src/vodex/experiment.py</code> <pre><code>def save(self, file_name: Union[Path, str]):\n    \"\"\"\n    Saves a database into a file.\n\n    Args:\n        file_name: full path to a file to save database.\n            (Usually the filename would end with .db)\n    \"\"\"\n    DbWriter(self.db.connection).save(file_name)\n</code></pre>"},{"location":"api/loaders/","title":"vodex.loaders module","text":"<p>This module contains classes for loading and collecting information from various file types.</p> <p>It includes:</p> <p>'Loader' - A generic class for loading files. Can be subclassed to create custom loaders for different file types.</p> <p>'TiffLoader' - A class for working with TIFF image files. A subclass of Loader, it can be used to determine the data type of the images, the number of frames in each TIFF file, and load frames from TIFF files.</p> <p>Additional loaders can be created to work with other file types. See  Contributions for details.</p>"},{"location":"api/loaders/#src.vodex.loaders.Loader","title":"<code>Loader</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The Loader class is a generic class that serves as a template for loading image data from specific file types. The class contains basic methods that need to be overwritten to create a custom loader for a specific file type.</p> <p>Any loader must be initialised by providing an example file from the dataset.</p> <p>Args: file_example: an example file from the dataset to infer the frame size and data type.</p> <p>Attributes:</p> Name Type Description <code>frame_size</code> <code>Tuple[int, int]</code> <p>a tuple containing the individual frame size (height, width)</p> <code>data_type</code> <code>dtype</code> <p>the datatype of the image frames.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>class Loader(ABC):\n    \"\"\"\n    The Loader class is a generic class that serves as a template for\n    loading image data from specific file types. The class contains basic\n    methods that need to be overwritten to create a custom loader for a\n    specific file type.\n\n    Any loader must be initialised by providing an example file from the\n    dataset.\n\n    Args: file_example: an example file from the dataset to infer the frame\n    size and data type.\n\n    Attributes:\n        frame_size: a tuple containing the individual frame size (height, width)\n        data_type: the datatype of the image frames.\n    \"\"\"\n\n    def __init__(self, file_example: Union[str, Path]):\n\n        self.frame_size: Tuple[int, int] = self.get_frame_size(file_example)\n        self.data_type: np.dtype = self.get_frame_dtype(file_example)\n\n    def __eq__(self, other):\n        \"\"\"\n        Compares two loader instances for equality.\"\n        \"\"\"\n        raise TypeError(f\"__eq__ is Not Implemented for {type(self).__name__} and {type(other).__name__}\")\n\n    @staticmethod\n    @abstractmethod\n    def get_frames_in_file(file: Union[str, Path]) -&gt; int:\n        \"\"\"\n        Computes and returns the number of frames in a file.\n\n        Args:\n            file: the path to the file to get the number of frames for.\n        Returns:\n            the number of frames in the file.\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def get_frame_size(file: Union[str, Path]) -&gt; Tuple[int, int]:\n        \"\"\"\n        Returns the size of an individual frame (height, width) in pixels.\n\n        Args:\n            file: the path to the file to get the size of the frame for.\n        Returns:\n            ( height , width ) height and width of an individual frame in pixels.\n        \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def get_frame_dtype(file: Union[str, Path]) -&gt; np.dtype:\n        \"\"\"\n        Returns the datatype of the image frames.\n\n        Args:\n            file: the path to the file to get the datatype of the frame for.\n        Returns:\n            datatype of the frame.\n        \"\"\"\n\n    @abstractmethod\n    def load_frames(self, frames: List[int], files: Union[List[str], List[Path]],\n                    show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n        \"\"\"\n        Loads the specified frames from the given files and returns them as a 3D array (frame, y, x).\n\n        Args:\n            frames: list of frames inside corresponding files to load\n            files: list of files corresponding to each frame\n            show_file_names: whether to print the file from which the frames are loaded on the screen.\n            show_progress: whether to show the progress bar of how many frames have been loaded.\n        Returns:\n            3D array of requested frames (frame, y, x)\n        \"\"\"\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.Loader.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two loader instances for equality.\"</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compares two loader instances for equality.\"\n    \"\"\"\n    raise TypeError(f\"__eq__ is Not Implemented for {type(self).__name__} and {type(other).__name__}\")\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.Loader.get_frame_dtype","title":"<code>get_frame_dtype(file)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the datatype of the image frames.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>the path to the file to get the datatype of the frame for.</p> required <p>Returns:     datatype of the frame.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_frame_dtype(file: Union[str, Path]) -&gt; np.dtype:\n    \"\"\"\n    Returns the datatype of the image frames.\n\n    Args:\n        file: the path to the file to get the datatype of the frame for.\n    Returns:\n        datatype of the frame.\n    \"\"\"\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.Loader.get_frame_size","title":"<code>get_frame_size(file)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Returns the size of an individual frame (height, width) in pixels.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>the path to the file to get the size of the frame for.</p> required <p>Returns:     ( height , width ) height and width of an individual frame in pixels.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_frame_size(file: Union[str, Path]) -&gt; Tuple[int, int]:\n    \"\"\"\n    Returns the size of an individual frame (height, width) in pixels.\n\n    Args:\n        file: the path to the file to get the size of the frame for.\n    Returns:\n        ( height , width ) height and width of an individual frame in pixels.\n    \"\"\"\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.Loader.get_frames_in_file","title":"<code>get_frames_in_file(file)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Computes and returns the number of frames in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>the path to the file to get the number of frames for.</p> required <p>Returns:     the number of frames in the file.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_frames_in_file(file: Union[str, Path]) -&gt; int:\n    \"\"\"\n    Computes and returns the number of frames in a file.\n\n    Args:\n        file: the path to the file to get the number of frames for.\n    Returns:\n        the number of frames in the file.\n    \"\"\"\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.Loader.load_frames","title":"<code>load_frames(frames, files, show_file_names=False, show_progress=True)</code>  <code>abstractmethod</code>","text":"<p>Loads the specified frames from the given files and returns them as a 3D array (frame, y, x).</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>List[int]</code> <p>list of frames inside corresponding files to load</p> required <code>files</code> <code>Union[List[str], List[Path]]</code> <p>list of files corresponding to each frame</p> required <code>show_file_names</code> <code>bool</code> <p>whether to print the file from which the frames are loaded on the screen.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>whether to show the progress bar of how many frames have been loaded.</p> <code>True</code> <p>Returns:     3D array of requested frames (frame, y, x)</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@abstractmethod\ndef load_frames(self, frames: List[int], files: Union[List[str], List[Path]],\n                show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n    \"\"\"\n    Loads the specified frames from the given files and returns them as a 3D array (frame, y, x).\n\n    Args:\n        frames: list of frames inside corresponding files to load\n        files: list of files corresponding to each frame\n        show_file_names: whether to print the file from which the frames are loaded on the screen.\n        show_progress: whether to show the progress bar of how many frames have been loaded.\n    Returns:\n        3D array of requested frames (frame, y, x)\n    \"\"\"\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.TiffLoader","title":"<code>TiffLoader</code>","text":"<p>             Bases: <code>Loader</code></p> <p>A class to work with tiff image files. It is used to get the datatype of the images, get the number of frames in each tiff file and load frames from tiff files. You can create your own loaders to work with other file types.</p> <p>Parameters:</p> Name Type Description Default <code>file_example</code> <code>Union[str, Path]</code> <p>An example tif file from the dataset to infer the frame size and data type.</p> required <p>Attributes:</p> Name Type Description <code>frame_size</code> <p>individual frame size (hight, width).</p> <code>data_type</code> <p>datatype.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>class TiffLoader(Loader):\n    \"\"\"\n    A class to work with tiff image files.\n    It is used to get the datatype of the images, get the number\n    of frames in each tiff file and load frames from tiff files.\n    You can create your own loaders to work with other file types.\n\n    Args:\n        file_example: An example tif file from the dataset\n            to infer the frame size and data type.\n\n    Attributes:\n        frame_size: individual frame size (hight, width).\n        data_type: datatype.\n    \"\"\"\n\n    def __eq__(self, other):\n        if isinstance(other, TiffLoader):\n            same_fs = self.frame_size == other.frame_size\n            same_dt = self.data_type == other.data_type\n            return same_fs and same_dt\n\n        else:\n            print(f\"__eq__ is Not Implemented for {TiffLoader} and {type(other)}\")\n            return NotImplemented\n\n    @staticmethod\n    def get_frames_in_file(file: Union[str, Path]) -&gt; int:\n        \"\"\"\n        Compute and return the number of frames in a file.\n\n        Args:\n            file: the name of a file relative to data_dir to get the number of frames for.\n        Returns:\n            the number of frames in the file.\n        \"\"\"\n        # TODO : try-catch here ?\n        # setting multifile to false since sometimes there is a problem with the corrupted metadata\n        # not using metadata, since for some files it is corrupted for unknown reason ...\n        stack = TiffFile(file, _multifile=False)\n        n_frames = len(stack.pages)\n        stack.close()\n\n        return n_frames\n\n    @staticmethod\n    def get_frame_size(file: Union[str, Path]) -&gt; Tuple[int, int]:\n        \"\"\"\n        Gets frame size ( height , width ) from a tiff file.\n\n        Args:\n            file: the path to the file to get the size of the frame for.\n        Returns:\n            ( height , width ) height and width of an individual frame in pixels.\n        \"\"\"\n        # TODO : try-catch here ?\n        # setting multifile to false since sometimes there is a problem with the corrupted metadata\n        # not using metadate, since for some files it is corrupted for unknown reason ...\n        stack = TiffFile(file, _multifile=False)\n        page = stack.pages.get(0)\n        h, w = page.shape\n        stack.close()\n        return h, w\n\n    @staticmethod\n    def get_frame_dtype(file: Union[str, Path]) -&gt; np.dtype:\n        \"\"\"\n        Gets the datatype of the frame.\n\n        Args:\n            file: the path to the file to get the datatype of the frame for.\n        Returns:\n            datatype of the frame.\n        \"\"\"\n        # TODO : try-catch here ?\n        # setting multifile to false since sometimes there is a problem with the corrupted metadata\n        # not using metadate, since for some files it is corrupted for unknown reason ...\n        stack = TiffFile(file, _multifile=False)\n        page = stack.pages.get(0)\n        data_type = page.dtype\n        stack.close()\n        return data_type\n\n    def load_frames(self, frames: List[int], files: Union[List[str], List[Path]],\n                    show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n        \"\"\"\n        Load frames from files and return as an array (frame, y, x).\n\n        Args:\n            frames: list of frames inside corresponding files to load\n            files: list of files corresponding to each frame\n            show_file_names: whether to print the file from which the frames are loaded on the screen.\n            show_progress: whether to show the progress bar of how many frames have been loaded.\n        Returns:\n            3D array of requested frames (frame, y, x)\n        \"\"\"\n\n        def print_file_name():\n            if show_file_names:\n                print(f'Loading from file:\\n {tif_file}')\n\n        if show_file_names:\n            # Setting show_progress to False, show_progress can't be True when show_file_names is True\n            if show_progress:\n                show_progress = False\n        hide_progress = not show_progress\n\n        # prepare an empty array:\n        h, w = self.frame_size\n        img = np.zeros((len(frames), h, w), dtype=self.data_type)\n\n        # initialise tif file and open the stack\n        tif_file = files[0]\n        stack = TiffFile(tif_file, _multifile=False)\n\n        print_file_name()\n        for i, frame in enumerate(tqdm(frames, disable=hide_progress, unit='frames')):\n            # check if the frame belongs to an opened file\n            if files[i] != tif_file:\n                # switch to a different file\n                tif_file = files[i]\n                stack.close()\n                print_file_name()\n                stack = TiffFile(tif_file, _multifile=False)\n            img[i, :, :] = stack.asarray(frame)\n        stack.close()\n        return img\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.TiffLoader.get_frame_dtype","title":"<code>get_frame_dtype(file)</code>  <code>staticmethod</code>","text":"<p>Gets the datatype of the frame.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>the path to the file to get the datatype of the frame for.</p> required <p>Returns:     datatype of the frame.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@staticmethod\ndef get_frame_dtype(file: Union[str, Path]) -&gt; np.dtype:\n    \"\"\"\n    Gets the datatype of the frame.\n\n    Args:\n        file: the path to the file to get the datatype of the frame for.\n    Returns:\n        datatype of the frame.\n    \"\"\"\n    # TODO : try-catch here ?\n    # setting multifile to false since sometimes there is a problem with the corrupted metadata\n    # not using metadate, since for some files it is corrupted for unknown reason ...\n    stack = TiffFile(file, _multifile=False)\n    page = stack.pages.get(0)\n    data_type = page.dtype\n    stack.close()\n    return data_type\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.TiffLoader.get_frame_size","title":"<code>get_frame_size(file)</code>  <code>staticmethod</code>","text":"<p>Gets frame size ( height , width ) from a tiff file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>the path to the file to get the size of the frame for.</p> required <p>Returns:     ( height , width ) height and width of an individual frame in pixels.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@staticmethod\ndef get_frame_size(file: Union[str, Path]) -&gt; Tuple[int, int]:\n    \"\"\"\n    Gets frame size ( height , width ) from a tiff file.\n\n    Args:\n        file: the path to the file to get the size of the frame for.\n    Returns:\n        ( height , width ) height and width of an individual frame in pixels.\n    \"\"\"\n    # TODO : try-catch here ?\n    # setting multifile to false since sometimes there is a problem with the corrupted metadata\n    # not using metadate, since for some files it is corrupted for unknown reason ...\n    stack = TiffFile(file, _multifile=False)\n    page = stack.pages.get(0)\n    h, w = page.shape\n    stack.close()\n    return h, w\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.TiffLoader.get_frames_in_file","title":"<code>get_frames_in_file(file)</code>  <code>staticmethod</code>","text":"<p>Compute and return the number of frames in a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>the name of a file relative to data_dir to get the number of frames for.</p> required <p>Returns:     the number of frames in the file.</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>@staticmethod\ndef get_frames_in_file(file: Union[str, Path]) -&gt; int:\n    \"\"\"\n    Compute and return the number of frames in a file.\n\n    Args:\n        file: the name of a file relative to data_dir to get the number of frames for.\n    Returns:\n        the number of frames in the file.\n    \"\"\"\n    # TODO : try-catch here ?\n    # setting multifile to false since sometimes there is a problem with the corrupted metadata\n    # not using metadata, since for some files it is corrupted for unknown reason ...\n    stack = TiffFile(file, _multifile=False)\n    n_frames = len(stack.pages)\n    stack.close()\n\n    return n_frames\n</code></pre>"},{"location":"api/loaders/#src.vodex.loaders.TiffLoader.load_frames","title":"<code>load_frames(frames, files, show_file_names=False, show_progress=True)</code>","text":"<p>Load frames from files and return as an array (frame, y, x).</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>List[int]</code> <p>list of frames inside corresponding files to load</p> required <code>files</code> <code>Union[List[str], List[Path]]</code> <p>list of files corresponding to each frame</p> required <code>show_file_names</code> <code>bool</code> <p>whether to print the file from which the frames are loaded on the screen.</p> <code>False</code> <code>show_progress</code> <code>bool</code> <p>whether to show the progress bar of how many frames have been loaded.</p> <code>True</code> <p>Returns:     3D array of requested frames (frame, y, x)</p> Source code in <code>src/vodex/loaders.py</code> <pre><code>def load_frames(self, frames: List[int], files: Union[List[str], List[Path]],\n                show_file_names: bool = False, show_progress: bool = True) -&gt; npt.NDArray:\n    \"\"\"\n    Load frames from files and return as an array (frame, y, x).\n\n    Args:\n        frames: list of frames inside corresponding files to load\n        files: list of files corresponding to each frame\n        show_file_names: whether to print the file from which the frames are loaded on the screen.\n        show_progress: whether to show the progress bar of how many frames have been loaded.\n    Returns:\n        3D array of requested frames (frame, y, x)\n    \"\"\"\n\n    def print_file_name():\n        if show_file_names:\n            print(f'Loading from file:\\n {tif_file}')\n\n    if show_file_names:\n        # Setting show_progress to False, show_progress can't be True when show_file_names is True\n        if show_progress:\n            show_progress = False\n    hide_progress = not show_progress\n\n    # prepare an empty array:\n    h, w = self.frame_size\n    img = np.zeros((len(frames), h, w), dtype=self.data_type)\n\n    # initialise tif file and open the stack\n    tif_file = files[0]\n    stack = TiffFile(tif_file, _multifile=False)\n\n    print_file_name()\n    for i, frame in enumerate(tqdm(frames, disable=hide_progress, unit='frames')):\n        # check if the frame belongs to an opened file\n        if files[i] != tif_file:\n            # switch to a different file\n            tif_file = files[i]\n            stack.close()\n            print_file_name()\n            stack = TiffFile(tif_file, _multifile=False)\n        img[i, :, :] = stack.asarray(frame)\n    stack.close()\n    return img\n</code></pre>"},{"location":"napari/","title":"napari_vodex: A napari plugin for VoDEx.","text":"<p>A graphical interface for vodex is available as a napari plugin: napari-vodex. It allows to create experimental annotation without any coding and to load volumetric data directly into napari viewer.</p> <p>napari-vodex is written  using PyQt and the source code is available at LemonJust/napari-vodex</p> <p> </p>"},{"location":"napari/#installation","title":"Installation","text":"<p>You can install <code>napari-vodex</code> via [pip]:</p> <pre><code>pip install napari-vodex\n</code></pre> <p>Or through napari plugin manager.</p>"},{"location":"napari/#usage","title":"Usage","text":"<p>To get started with <code>napari_vodex</code> plugin, please see details and examples in Usage.</p>"},{"location":"napari/how-to/","title":"Usage","text":"<p>This section contains instructions how to use napari-vodex.</p>"},{"location":"napari/how-to/#launch-napari-vodex","title":"Launch napari-vodex","text":"<p>After following the installation instructions, you should see napari-vodex in your napari under <code>Plugis --&gt; Vodex Data Loader (napari-vodex)</code>. When you start it, it creates two buttons - <code>Load Saved Experiment</code> and <code>Create New Experiment</code></p>"},{"location":"napari/how-to/#create-new-experiment","title":"Create New Experiment","text":"<p>Let's create the annotation for the toy dataset. Hit <code>Create New Experiment</code>. It will initialize three tabs:</p> <p>The Image Data tab contains the information about the image files, their order and the information about the volumes : frames per volume and the first frame in the recording that is at the beginning of a volume.</p> <p>The Time Annotation tab will contain the information about the time annotations ;)</p> <p>The Load/Save Data tab allows to load individual volumes: based on their ID or based on the time annotation and also allows to save experiment (the information from the Image Data and Time Annotation tabs) to a database for future use with vodex or napari-vodex.</p>"},{"location":"napari/how-to/#1-image-data","title":"1. Image Data","text":"<p> Start with the Image Data tab.</p> <p>You can see an example of a fully filled out tab for the Toy Dataset on the right. For more details on how it was filled out, see the expandable box at the bottom.</p> <ol> <li>Click <code>Browse</code> and choose the folder that contains your recording. The recording could be saved as multiple files.</li> <li>Choose <code>file type</code>. Currently only TIFF files are supported, but if you added the support to your type of files, as described in Contributions, your file type should appear here.</li> <li>Hit <code>Fetch files</code>. Vodex will search the directory for the files of the type that you choose. The files will appear in the window below.</li> <li>Inspect the files carefully! The files appear in the order (top to bottom) in which they will be read by vodex. It is very important that they are in the correct order, or the rest of the annotations will be off. You can <code>drag the files to change the order</code> and delete the files that you don't want by clicking <code>Delete File</code> with a file selected. Click <code>Save File Order</code> when you are done.</li> <li>Enter <code>frames per volume</code>. If you work with a 2D data but still want to use vodex, leave frames per volume as 1.</li> <li>If your recording was not synchronized with the volumes, you can specify the first frame in the recording that correspond to the beginning of a full volume (<code>first good frame</code>). It the beginning of the recording is at the beginning of a volume, leave it as 0.</li> <li>Hit <code>Save Volume Info</code>.</li> <li>Read carefully the short description of your data that: how many total frames, how many full volumes and how many frames that don't make a full volume at the beginning and at the end of the recording. If everything looks good, hit <code>Create Experiment</code>. This will allow you to load volumes using their ID numbers (For example volumes number 3, 8 and 30 to 40) and to add time annotations.</li> </ol> Toy Dataset: Creating experiment <p>The data used in these examples is a toy dataset, described in Data. You can download the toy dataset from GitHub. To create an experiment, we click <code>Browse</code>, locate the folder with the three tif files. Choose TIFF from the <code>file type</code> drop down menu, and click <code>Fetch files</code>. The files are in the proper prder already, so we click <code>Save File Order</code>. We enter 10 for <code>frames per volume</code> and click <code>Save Volume Info</code>. You can see that the total number of frames is 42, which is correct, there are 4 volumes and 2 extra frames at the end, which is also correct. Finally, we click <code>Create Experiment</code>.  </p>"},{"location":"napari/how-to/#2-time-annotation","title":"2. Time Annotation","text":"<p> Start with the Image Data tab. Switch to Time Annotation tab and click <code>Add annotation</code>. You will be asked to create an annotation name: this is the name of the phenomena that you are describing. It could be some kind of stimuli/ drug/ behaviour, etc. After you name the annotation, the tab to enter the labels and the actual annotation of your recording.</p> <p>You can see an example of a filled out tab for <code>light</code> annotation for the Toy Dataset on the right. For more details on how it was filled out, see the expandable box at the bottom.</p> <ol> <li> <p>Click <code>Add label</code> to create a label. A label is a particular condition: a certain state of the phenomena that you are describing. Add as many labels as you need. Double click on the description cell to add the description for each label (optional). You can delete a line by selecting it and clicking <code>Delete selected</code>.</p> </li> <li> <p>Choose if the annotation is a <code>Cycle</code> or a <code>Timeline</code>. Cycles can describe a short period of time and will be repeated to cover the duration of the whole recording. Timelines must describe the whole recording.</p> </li> <li>Next you need to describe the order in which the conditions are following and their duration (in frames). Click <code>Add condition</code> to add a line to the annotation. You can delete a line by selecting it and clicking <code>Delete condition</code>.</li> <li>After you are done, click <code>Add annotation to the experiment</code>. This will record the annotation and you can now use it at the <code>Load/Save Data</code> tab to choose the volumes that you want to load.</li> </ol> <p>One experiment can have multiple annotations. Add as many annotations as you need. You can switch between the annotations with the combobox at the top-right corner of the tab, by the <code>Available annotations:</code> label.</p> <p>Remember that you must press the <code>Add annotation to the experiment</code> button to be able to use the annotation to load volumes and to save it when you are saving the experiment to a DataBase.</p> Toy Dataset: Adding time annotation <p> By following the time annotation description, for the toy dataset, we fill out the three annotation types. The other two annotations for the toy experiment are on the right (click to expand).</p>"},{"location":"napari/how-to/#3-save-experiment-to-a-database","title":"3. Save Experiment to a DataBase","text":"<p> Once you filled out the Image data information and added the annotations, you can save the experiment into a database. While you don't have to save the experiment before loading the volumes, we highly recommend that you do so for your future reference, especially if you plan to use the volumes that were loaded with VoDEx in the subsequent analysis. This will give you the ability to come back to the annotation later and recheck that you did not make any mistakes.</p> <p>You can see an example of a <code>Load/Save Data</code> tab after we saved our annotation on the right [click on image to zoom in]. The bottom line shows the saved file location.</p> <p>Go to the <code>Load/Save Data</code> tab and click <code>Save</code> button at the bottom. Choose the folder and give your database a name (*.db).</p> How to explore the DataBase content <p>The DataBase is using SQLite and we recommend using a DB Browser for SQLite to explore the DataBase content. It is also a good place to test out your queries if you want to add some functionality to the vodex dbmethods module.</p>"},{"location":"napari/how-to/#load-saved-experiment","title":"Load Saved Experiment","text":"<p>To load the experiment, choose <code>Load Saved Experiment</code> after launching napari-vodex. Then click the <code>Load</code> button to search for the saved database file. Vodex will load the experiment and fill out all the <code>Image Data</code> and <code>Time Annotation</code> information, that you can see in the corresponding tabs.</p> <p>You can edit and delete time annotations and add more. These changes will not be saved to the original file, remember to save the file to keep the changes.</p> Toy Dataset: Loading an experiment <p>After we load the example that we saved in the previous section, all the fields look the same as when we filled them out. [click on image to zoom in]. </p>"},{"location":"napari/how-to/#load-volumes-into-napari-viewer","title":"Load Volumes into Napari Viewer","text":"<p>Finally, you can use napari-vodex to load volumes into napari. To do so you must have experiment created ( or loaded) and head to the <code>Load/Save Data</code> tab.</p>"},{"location":"napari/how-to/#load-based-on-volumes-id","title":"Load based on volumes ID","text":"<p>Volume IDs are simply the numbers in which they follow from the beginning of the recording. The volumes numbering starts with 0: the first full volume's ID is 0, the second volume's ID is 1, the third's ID is 2 , etc. Enter the IDs of the volumes at the <code>Volumes:</code> edit line on top of the tab and press <code>Load</code>. Vodex will load the requested volumes and name them with the same text that you used to request them.</p> How to specify the volumes <p>You can specify the volumes as a line of integers separated by a comma (3, 4, 5, 6, 7) or request a slice by specifying the first and the last volume to load (3:7). Both examples will load the volumes with IDs 3, 4, 5, 6, and 7. You can mix the two methods. For example 2, 5:8, 3, 6:9 will load the volumes with IDs 2, 5, 6, 7, 8, 3, 6, 7, 8, 9 in this order. Note how the same volume can be loaded many times and the volume IDs do not have to be all ascending.</p> Toy Dataset: Loading volumes based on volume IDs <p> An example shows the first slice in the two volumes, that we loaded : volumes with IDs 0 and 3. Note that the image layer created in napari (in the left panel) is clled <code>0,3</code> as well. [click on image to zoom in].</p> <p>Note: frames numbers start at 1 , while volume IDs and slice numbers start at 0.</p>"},{"location":"napari/how-to/#load-based-on-experimental-conditions","title":"Load based on experimental conditions","text":"<p>To load volumes based on conditions, you must have at least one time annotation added to the experiment (make sure you pressed that <code>Add annotation to the experiment</code> button).</p> <p>If you have added time annotations to the experiment, you will see the annotation's names and labels. <code>Click the checkboxes</code> by the labels for which you want to get the volumes and choose how to combine them with a logical <code>or</code> or a logical <code>and</code>. Then click <code>Find volumes</code> button to get a list of volume IDs that correspond to the chosen conditions, or  <code>Load</code> to load all such volumes into napari.</p> <p>When you are choosing <code>or</code> all the conditions you picked will be combined with a logical or. Meaning, vodex will pick volumes with slices that correspond to at least one condition that you picked. It doesn't mean that the whole volume corresponds to one of the conditions: half of the slices in the volume can correspond to one condition and the other half to the other.</p> <p>When you are choosing <code>and</code>, vodex will pick volumes with slices that correspond to all the condition that you picked at the same time. If at least one slice in a volume does not correspond to all the conditions, such volume will not be picked.</p> Toy Dataset: Loading volumes based on conditions <p> An example shows the first slice in the two volumes, that we loaded, such that both is true at the same time: the background is dark and C1 label is present on every slice of the volumes. These happen to be volumes with IDs 0 and 3. Note that the image layer created in napari (in the left panel) is named according to our query <code>c label-c1_and_light-off</code>. [click on image to zoom in].</p> Toy Dataset: About <code>or</code> and <code>and</code> logic <ol> <li> <p> Compare the <code>or</code> and <code>and</code> behavior at the two images on the right. Note how when the logic is set to <code>or</code>, volumes 0 and 3 are being picked. Even though only half of each volume corresponds to <code>shape-c</code> [click on image to zoom in]. When we swith logic to <code>and</code> , no volumes satisfy the condition.  </p> </li> <li> <p> Note how when the logic is set to <code>or</code>, if you have all the conditions in any annotation picked, it will always return all the volumes in the recording, ignoring the rest of the labels that you choose and even if no full volumes correspond to each of the conditions individually. [click on image to zoom in].  </p> </li> <li> <p> Note that you do not have to pick conditions from all the annotations. When no labels are picked for a particular annotation, that annotation is ignored. [click on image to zoom in].</p> </li> </ol>"},{"location":"qstart/","title":"Quick start","text":"<p>This is a quick start example of how to use the <code>vodex</code> library. If you need more information on volumetric functional imaging, and library structure, refer to Guide. The data used in this tutorial is a Toy Dataset.</p> <p>Some code is also available as a jupyter notebook.</p> <p>XXX The core module is responsible for providing the core classes that vodex needs to manage the experimental data. These classes are used to handle the various aspects of the data, such as the images themselves, the files they are stored in, and the annotations associated with them. The Experiment class, uses these core classes to create and manage the database, and provides methods for searching, loading, and saving the data. The loaders module helps with reading and collecting information from specific file types, such as TIFF images. The dbmethods module provides the functionality to interact with the database, such as writing and reading information.</p> <p>XXX Using the code allows for more flexibility, while the napari plugin provides a user-friendly interface for manual annotation and data organization.</p> <p>Saving the data to a database allows to verify and share the information with others. It also allows you to later load the information without having to re-enter it, making the process more efficient and less prone to errors. The Experiment class has a save() method that can be used to save the information to a database file. Once saved, you can use the Experiment.load() method to load it back and initialize an Experiment object, then use the Experiment.choose_frames() method to select specific frames based on certain conditions, and the Experiment.load_frames() method to load the image data for those frames. You can also use the Experiment.add_annotations() method to add more annotations to the experiment later, and the Experiment.save() method to save the updated experiment to the database again.</p>"},{"location":"qstart/#create-experiment","title":"Create Experiment","text":"<p>Create Experiment describes how to create a new experiment and save it to a database file for later use.</p>"},{"location":"qstart/#load-experiment","title":"Load Experiment","text":"<p>Load Experiment describes how to load a saved experiment from a database file.</p>"},{"location":"qstart/#load-volumes","title":"Load Volumes","text":"<p>Load Volumes describes how to load individual volumes with vodex.</p>"},{"location":"qstart/load_experiment/","title":"Load Experiment from a Database","text":"<p>Use the Database to initialize the Experiment:</p> <pre><code>import vodex as vx\n\n# Provide the path to the database file\nexperiment = vx.Experiment.load(\"test.db\")\n</code></pre>"},{"location":"qstart/load_volumes/","title":"Load Volumes","text":""},{"location":"qstart/load_volumes/#load-based-on-volume-id","title":"Load based on volume ID","text":"<p>The volume ID is it's number from the beginning of the recording (volume IDs start at 0!).</p> <p>You can use <code>list_volumes</code> method to get a list of all available volume IDs. You will see ID <code>-1</code> if there is a non-full volume at the beginning of the recording, and <code>-2</code> for the non-full volume at the end of the recording. <pre><code>import vodex as vx\nexperiment = vx.Experiment.load(\"test.db\")\nexperiment.list_volumes()\n</code></pre> <pre><code>array([-2,  0,  1,  2,  3])\n</code></pre></p> <p>Here's how you can load some volumes: <pre><code># so we have 4 full volumes : 0,1,2,3 and some extra frames at the end (-2)\n# let's load two full volumes , 0 and 2:\nvol02 = experiment.load_volumes([0,2])\nprint(vol02.shape)\n</code></pre> <pre><code>(2, 10, 200, 200)\n</code></pre> We loaded two volumes, each has 10 slices and each frame is 200 by 200 pixels.</p> <p>If you want to have a look at the fames at the end of the recording that do not form a full volume,  you can do so by asking for the volume ID <code>-2</code>: <pre><code>volm2 = experiment.load_volumes([-2])\nprint(volm2.shape)\n</code></pre> <pre><code>((1, 2, 200, 200))\n</code></pre> Notice how this volume only has 2 frames!</p>"},{"location":"qstart/load_volumes/#load-based-on-experimental-conditions","title":"Load based on experimental conditions","text":"<p>You will use to method <code>choose_volumes</code> to get the IDs of the volumes that correspond to certain conditions and then <code>load_volumes</code> to actually load the volumes.</p> <p>You can choose volumes based on any annotation. Let's see what volumes correspond to light \"off\": <pre><code>light_off_ids = experiment.choose_volumes([(\"light\",\"off\")])\nlight_off_ids\n</code></pre> <pre><code>[0, 3]\n</code></pre> Volumes 0 and 3 have light off for every frame. Use <code>load_volumes</code> to load these volumes: <pre><code>vol_light_off = experiment.load_volumes(light_off_ids)\n</code></pre></p> <p>You can also combine the conditions with a logical <code>and</code> or logical <code>or</code>. You can go and experiment with this: what volumes correspond to the times when the light is off <code>or</code> the c label is c2 ? <pre><code>light_off_ids = experiment.choose_volumes([(\"light\",\"off\"),(\"c label\",\"c2\")], logic=\"or\")\nlight_off_ids\n</code></pre> <pre><code>[0, 1, 3]\n</code></pre> How about such volumes that the light is \"off\" <code>and</code> \"on\" <pre><code>light_off_ids = experiment.choose_volumes([(\"light\",\"off\"),(\"light\",\"on\")], logic=\"and\")\nlight_off_ids\n</code></pre> <pre><code>[]\n</code></pre> We got an empty list : no such volumes, since the light can't be on <code>and</code> off at the same time. What if we had an <code>or</code>? <pre><code>light_off_ids = experiment.choose_volumes([(\"light\",\"off\"),(\"light\",\"on\")], logic=\"or\")\nlight_off_ids\n</code></pre> <pre><code>[0, 1, 2, 3]\n</code></pre> on <code>or</code> off returns all full volumes, since for every frame the light was either on or off.</p>"},{"location":"qstart/new_experiment/","title":"Create a new Experiment and save to a Database","text":"<p>Below is a quick example how-to create and experiment. For a line-by-line explanation, see the rest of the section. <pre><code>### Imports\n\nimport vodex as vx\n\n### Adding information about the Image Data\n\n# the folder with the 3 movies of the toy dataset\ndata_dir = \"data/test/test_movie\"\nframes_per_volume = 10\nvolume_m = vx.VolumeManager.from_dir(data_dir, frames_per_volume)\n\n### Adding information about the Time Annotation\n\n#### Create a Cycle\n\nc_label = vx.Labels(# label type (group name), string\n                    \"c label\",\n                    # label names, keep this brief\n                    # same rules as for variable names:\n                    # no leading numbers, no spaces, no special characters\n                    [\"c1\", \"c2\", \"c3\"],\n                    # optional: info about the labels\n                    # {label_name : label information}\n                    state_info={\"c1\": \"written c1\", \"c2\": \"written c1\"})\nc_label_cyc = vx.Cycle(# order of label presentation\n                       # how they go in cycle\n                       [c_label.c1, c_label.c2, c_label.c3],\n                       # duration of each presentation  \n                       [10,10,10])                                         \n\nshape = vx.Labels(\"shape\",\n                   [\"c\", \"s\"],\n                   state_info={\"c\": \"circle on the screen\", \"s\": \"square on the screen\"})\nshape_cyc = vx.Cycle([shape.c, shape.s, shape.c],\n                    [5,10,5])\n\n#### Create a Timeline\n\nlight = vx.Labels(\"light\",\n                  [\"on\", \"off\"],\n                  state_info={\"on\": \"the intensity of the background is high\",\n                           \"off\": \"the intensity of the background is low\"},\n                 # optional: information about the group, string\n                  group_info=\"Light on inverts the colors\")\n\nlight_tml = vx.Timeline(# order of label presentation\n                        # how they go in WHOLE RECORDING\n                        [light.off, light.on, light.off],\n                        # duration of each presentation\n                        # for timeline:\n                        # the total duration MUST sum up\n                        # to the total number of frames in the recording\n                        [10,20,12])\n\n#### Creating the annotations\n\nn_frames = volume_m.n_frames # 42\nc_label_an = vx.Annotation.from_cycle(  # the total number of frames in the recording\n                                        n_frames,\n                                        # the labels for the corresponding annotation\n                                        c_label,\n                                        # the annotation itself: a cycle, a timeline or a file\n                                        c_label_cyc)\nshape_an = vx.Annotation.from_cycle(n_frames, shape, shape_cyc)\nlight_an = vx.Annotation.from_timeline(n_frames, light, light_tml)\n\n### Creating and Saving the Experiment\n\nexperiment = vx.Experiment.create(volume_m, [shape_an, c_label_an, light_an])\nexperiment.save(\"test.db\")\n</code></pre></p>"},{"location":"qstart/new_experiment/#imports","title":"Imports","text":"<p>Import vodex:</p> <pre><code>import vodex as vx\n</code></pre>"},{"location":"qstart/new_experiment/#adding-information-about-the-image-data","title":"Adding information about the Image Data","text":"<p>You need to create a VolumeManager object, that will summarize and preprocess the information about the image data. To create one, you need to provide the following:</p> <ul> <li>the folder with the image data that you will work with,</li> <li>the type of the image files</li> <li>frames per volume ( if you work with a 2D data but still want to use vodex, set frames per volume to 1)</li> <li>first good frame ( OPTIONAL: if your recording was not synchronized with the volumes, you can specify the first frame in the recording that correspond to the beginning of a full volume )</li> </ul> <p>Vodex will look into the folder and find all the files of the specified type. Vodex assumes that all the files are a recording of one continuous movie, so it is a good practice to store each imaging session in a separate folder. If you have to modify the order of the files or exclude some files from the movie, you can do so using FileManager.change_files_order (not shown in this example) Finally, vodex will use the frames per volume and first good frame to build a mapping of what frames correspond to which volume in the recording.</p> <p>Create a VolumeManager object: <pre><code># the folder with the 3 movies of the toy dataset\ndata_dir = \"data/test/test_movie\"\nframes_per_volume = 10\nvolume_m = vx.VolumeManager.from_dir(data_dir, frames_per_volume)\n</code></pre> Inspect the located image files by looking at the FileManager: <pre><code>print(volume_m.file_manager)\n</code></pre> <pre><code>files directory: data/test/test_movie\nfiles [number of frames]:\n0) mov0.tif [7]\n1) mov1.tif [18]\n2) mov2.tif [17]\n</code></pre> Inspect the volume information: <pre><code>print(volume_m.file_manager)\n</code></pre> <pre><code>Total frames : 42\nVolumes start on frame : 0\nTotal good volumes : 4\nFrames per volume : 10\nTailing frames (not a full volume , at the end) : 2\n</code></pre> Everything looks correct! We can move on to creating the experiment!</p>"},{"location":"qstart/new_experiment/#adding-information-about-the-time-annotation","title":"Adding information about the Time Annotation","text":"<p>You need to create aa Annotation object, that will summarize and preprocess the information about the time annotation. You can have many annotations for the same data. The easiest way to create one, is by first creating a Cycle , if the experimental conditions repeat through the experiment, or a Timeline, if they do not repeat. Cycles can describe a short period of time and will be repeated to cover the duration of the whole recording. Timelines must describe the whole recording.</p>"},{"location":"qstart/new_experiment/#create-a-cycle","title":"Create a Cycle","text":"<p>To create a Cycle, you need to provide:</p> <ul> <li>labels used to build the annotation (what type of conditions does this annotation describe),</li> <li>the order in which the labels are following in a cycle</li> <li>their duration of the conditions in the cycle ( in frames)</li> </ul> <p>Create a Cycles to describe the  <code>c label</code> and the <code>shape</code> changes in the Toy Dataset. First create the Labels: <pre><code>c_label = vx.Labels(# label type (group name), string\n                    \"c label\",\n                    # label names, keep this brief\n                    # same rules as for variable names:\n                    # no leading numbers, no spaces, no special characters\n                    [\"c1\", \"c2\", \"c3\"],\n                    # optional: info about the labels\n                    # {label_name : label information}\n                    state_info={\"c1\": \"written c1\", \"c2\": \"written c1\"})\n</code></pre> Now construct the Cycle. Note how you can use the names of the labels as the <code>c_label</code> attribute: <pre><code>c_label_cyc = vx.Cycle(# order of label presentation\n                       # how they go in cycle\n                       [c_label.c1, c_label.c2, c_label.c3],\n                       # duration of each presentation  \n                       [10,10,10])\n</code></pre> Inspect the information about the cycles: <pre><code>print(c_label_cyc)\n</code></pre> <pre><code>Cycle : c label\nLength: 30\nLabel c1: for 10 frames\nLabel c2: for 10 frames\nLabel c3: for 10 frames\n</code></pre> The above information is correct. Now, create the shape Cycle: <pre><code>shape = vx.Labels(\"shape\",\n                   [\"c\", \"s\"],\n                   state_info={\"c\": \"circle on the screen\", \"s\": \"square on the screen\"})\nshape_cyc = vx.Cycle([shape.c, shape.s, shape.c],\n                    [5,10,5])\n</code></pre> <pre><code>print(c_label_cyc)\n</code></pre> <pre><code>Cycle : shape\nLength: 20\nLabel c: for 5 frames\nLabel s: for 10 frames\nLabel c: for 5 frames\n</code></pre></p>"},{"location":"qstart/new_experiment/#create-a-timeline","title":"Create a Timeline","text":"<p>To create a Timeline, you need to provide:</p> <ul> <li>labels used to build the annotation (what type of conditions does this annotation describe),</li> <li>the order in which the labels are following in the whole recording</li> <li>their duration of the conditions in the cycle ( in frames). The total number of frames in the Timeline must be equal to the total number of frames in the recording.</li> </ul> <p>Create a Timeline to describe the  <code>light</code> in the Toy Dataset: First create the Labels: <pre><code>light = vx.Labels(\"light\",\n                  [\"on\", \"off\"],\n                  state_info={\"on\": \"the intensity of the background is high\",\n                           \"off\": \"the intensity of the background is low\"},\n                 # optional: information about the group, string\n                  group_info=\"Light on inverts the colors\")\n\nlight_tml = vx.Timeline(# order of label presentation\n                        # how they go in WHOLE RECORDING\n                        [light.off, light.on, light.off],\n                        # duration of each presentation\n                        # for timeline:\n                        # the total duration MUST sum up\n                        # to the total number of frames in the recording\n                        [10,20,12])\n</code></pre> Inspect the information about the timeline: <pre><code>print(light_tml)\n</code></pre> <pre><code>Timeline : light\nLength: 42\nLabel off: for 10 frames\nLabel on: for 20 frames\nLabel off: for 12 frames\n</code></pre></p>"},{"location":"qstart/new_experiment/#create-a-annotations","title":"Create a annotations","text":"<p>Use the cycles and the timeline that you created to create three time annotations. You will need to provide the total number of frames in the recording ( you can get it from the <code>volume_m</code>)</p> <p><pre><code>n_frames = volume_m.n_frames # 42\nc_label_an = vx.Annotation.from_cycle(  # the total number of frames in the recording\n                                        n_frames,\n                                        # the labels for the corresponding annotation\n                                        c_label,\n                                        # the cycle\n                                        c_label_cyc)\nshape_an = vx.Annotation.from_cycle(n_frames, shape, shape_cyc)\nlight_an = vx.Annotation.from_timeline(n_frames, light, light_tml)\n</code></pre> With this, you can create the Experiment!</p>"},{"location":"qstart/new_experiment/#creating-and-saving-the-experiment","title":"Creating and Saving the Experiment","text":"<p>The Experiment will summarize the information about the Image Data and Annotations. It will create the Database that we can save and use it next time to initialize the Experiment with the exact same parameters. Experiment allows to search the frames based on volumes/ annotations and loads the image data using the appropriate ImageLoader.</p> <p>Create and save the experiment for the Toy Dataset: <pre><code>experiment = vx.Experiment.create(volume_m, [shape_an, c_label_an, light_an])\nexperiment.save(\"test.db\")\n</code></pre> Alternatively, you can first create the experiment without any Time Annotation, and add it some later: <pre><code>experiment = vx.Experiment.create(volume_m, [])\n...\nexperiment.add_annotations([shape_an, c_label_an, light_an])\nexperiment.save(\"test.db\")\n</code></pre></p>"}]}